(function () {
'use strict';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var riot_compiler = createCommonjsModule(function (module, exports) {
/* Riot v3.4.2, @license MIT */
(function (global, factory) {
  module.exports = factory();
})(commonjsGlobal, function () {
  'use strict';

  var __TAGS_CACHE = [];
  var __TAG_IMPL = {};
  var GLOBAL_MIXIN = '__global_mixin';
  var ATTRS_PREFIX = 'riot-';
  var REF_DIRECTIVES = ['ref', 'data-ref'];
  var IS_DIRECTIVE = 'data-is';
  var CONDITIONAL_DIRECTIVE = 'if';
  var LOOP_DIRECTIVE = 'each';
  var LOOP_NO_REORDER_DIRECTIVE = 'no-reorder';
  var SHOW_DIRECTIVE = 'show';
  var HIDE_DIRECTIVE = 'hide';
  var RIOT_EVENTS_KEY = '__riot-events__';
  var T_STRING = 'string';
  var T_OBJECT = 'object';
  var T_UNDEF = 'undefined';
  var T_FUNCTION = 'function';
  var XLINK_NS = 'http://www.w3.org/1999/xlink';
  var XLINK_REGEX = /^xlink:(\w+)/;
  var WIN = typeof window === T_UNDEF ? undefined : window;
  var RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;
  var RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;
  var RE_EVENTS_PREFIX = /^on/;
  var RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;
  var RE_HTML_ATTRS = /([-\w]+) ?= ?(?:"([^"]*)|'([^']*)|({[^}]*}))/g;
  var CASE_SENSITIVE_ATTRIBUTES = { 'viewbox': 'viewBox' };
  var RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;
  var IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;

  /**
   * Check Check if the passed argument is undefined
   * @param   { String } value -
   * @returns { Boolean } -
   */
  function isBoolAttr(value) {
    return RE_BOOL_ATTRS.test(value);
  }

  /**
   * Check if passed argument is a function
   * @param   { * } value -
   * @returns { Boolean } -
   */
  function isFunction(value) {
    return typeof value === T_FUNCTION;
  }

  /**
   * Check if passed argument is an object, exclude null
   * NOTE: use isObject(x) && !isArray(x) to excludes arrays.
   * @param   { * } value -
   * @returns { Boolean } -
   */
  function isObject(value) {
    return value && typeof value === T_OBJECT; // typeof null is 'object'
  }

  /**
   * Check if passed argument is undefined
   * @param   { * } value -
   * @returns { Boolean } -
   */
  function isUndefined(value) {
    return typeof value === T_UNDEF;
  }

  /**
   * Check if passed argument is a string
   * @param   { * } value -
   * @returns { Boolean } -
   */
  function isString(value) {
    return typeof value === T_STRING;
  }

  /**
   * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank
   * @param { * } value -
   * @returns { Boolean } -
   */
  function isBlank(value) {
    return isUndefined(value) || value === null || value === '';
  }

  /**
   * Check if passed argument is a kind of array
   * @param   { * } value -
   * @returns { Boolean } -
   */
  function isArray(value) {
    return Array.isArray(value) || value instanceof Array;
  }

  /**
   * Check whether object's property could be overridden
   * @param   { Object }  obj - source object
   * @param   { String }  key - object property
   * @returns { Boolean } -
   */
  function isWritable(obj, key) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, key);
    return isUndefined(obj[key]) || descriptor && descriptor.writable;
  }

  /**
   * Check if passed argument is a reserved name
   * @param   { String } value -
   * @returns { Boolean } -
   */
  function isReservedName(value) {
    return RE_RESERVED_NAMES.test(value);
  }

  var check = Object.freeze({
    isBoolAttr: isBoolAttr,
    isFunction: isFunction,
    isObject: isObject,
    isUndefined: isUndefined,
    isString: isString,
    isBlank: isBlank,
    isArray: isArray,
    isWritable: isWritable,
    isReservedName: isReservedName
  });

  /**
   * Shorter and fast way to select multiple nodes in the DOM
   * @param   { String } selector - DOM selector
   * @param   { Object } ctx - DOM node where the targets of our search will is located
   * @returns { Object } dom nodes found
   */
  function $$(selector, ctx) {
    return (ctx || document).querySelectorAll(selector);
  }

  /**
   * Shorter and fast way to select a single node in the DOM
   * @param   { String } selector - unique dom selector
   * @param   { Object } ctx - DOM node where the target of our search will is located
   * @returns { Object } dom node found
   */
  function $(selector, ctx) {
    return (ctx || document).querySelector(selector);
  }

  /**
   * Create a document fragment
   * @returns { Object } document fragment
   */
  function createFrag() {
    return document.createDocumentFragment();
  }

  /**
   * Create a document text node
   * @returns { Object } create a text node to use as placeholder
   */
  function createDOMPlaceholder() {
    return document.createTextNode('');
  }

  /**
   * Create a generic DOM node
   * @param   { String } name - name of the DOM node we want to create
   * @returns { Object } DOM node just created
   */
  function mkEl(name) {
    return document.createElement(name);
  }

  /**
   * Set the inner html of any DOM node SVGs included
   * @param { Object } container - DOM node where we'll inject new html
   * @param { String } html - html to inject
   */
  /* istanbul ignore next */
  function setInnerHTML(container, html) {
    if (!isUndefined(container.innerHTML)) {
      container.innerHTML = html;
    }
    // some browsers do not support innerHTML on the SVGs tags
    else {
        var doc = new DOMParser().parseFromString(html, 'application/xml');
        var node = container.ownerDocument.importNode(doc.documentElement, true);
        container.appendChild(node);
      }
  }

  /**
   * Toggle the visibility of any DOM node
   * @param   { Object }  dom - DOM node we want to hide
   * @param   { Boolean } show - do we want to show it?
   */

  function toggleVisibility(dom, show) {
    dom.style.display = show ? '' : 'none';
    dom['hidden'] = show ? false : true;
  }

  /**
   * Remove any DOM attribute from a node
   * @param   { Object } dom - DOM node we want to update
   * @param   { String } name - name of the property we want to remove
   */
  function remAttr(dom, name) {
    dom.removeAttribute(name);
  }

  /**
   * Convert a style object to a string
   * @param   { Object } style - style object we need to parse
   * @returns { String } resulting css string
   * @example
   * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'
   */
  function styleObjectToString(style) {
    return Object.keys(style).reduce(function (acc, prop) {
      return acc + " " + prop + ": " + style[prop] + ";";
    }, '');
  }

  /**
   * Get the value of any DOM attribute on a node
   * @param   { Object } dom - DOM node we want to parse
   * @param   { String } name - name of the attribute we want to get
   * @returns { String | undefined } name of the node attribute whether it exists
   */
  function getAttr(dom, name) {
    return dom.getAttribute(name);
  }

  /**
   * Set any DOM attribute
   * @param { Object } dom - DOM node we want to update
   * @param { String } name - name of the property we want to set
   * @param { String } val - value of the property we want to set
   */
  function setAttr(dom, name, val) {
    var xlink = XLINK_REGEX.exec(name);
    if (xlink && xlink[1]) {
      dom.setAttributeNS(XLINK_NS, xlink[1], val);
    } else {
      dom.setAttribute(name, val);
    }
  }

  /**
   * Insert safely a tag to fix #1962 #1649
   * @param   { HTMLElement } root - children container
   * @param   { HTMLElement } curr - node to insert
   * @param   { HTMLElement } next - node that should preceed the current node inserted
   */
  function safeInsert(root, curr, next) {
    root.insertBefore(curr, next.parentNode && next);
  }

  /**
   * Minimize risk: only zero or one _space_ between attr & value
   * @param   { String }   html - html string we want to parse
   * @param   { Function } fn - callback function to apply on any attribute found
   */
  function walkAttrs(html, fn) {
    if (!html) {
      return;
    }
    var m;
    while (m = RE_HTML_ATTRS.exec(html)) {
      fn(m[1].toLowerCase(), m[2] || m[3] || m[4]);
    }
  }

  /**
   * Walk down recursively all the children tags starting dom node
   * @param   { Object }   dom - starting node where we will start the recursion
   * @param   { Function } fn - callback to transform the child node just found
   * @param   { Object }   context - fn can optionally return an object, which is passed to children
   */
  function walkNodes(dom, fn, context) {
    if (dom) {
      var res = fn(dom, context);
      var next;
      // stop the recursion
      if (res === false) {
        return;
      }

      dom = dom.firstChild;

      while (dom) {
        next = dom.nextSibling;
        walkNodes(dom, fn, res);
        dom = next;
      }
    }
  }

  var dom = Object.freeze({
    $$: $$,
    $: $,
    createFrag: createFrag,
    createDOMPlaceholder: createDOMPlaceholder,
    mkEl: mkEl,
    setInnerHTML: setInnerHTML,
    toggleVisibility: toggleVisibility,
    remAttr: remAttr,
    styleObjectToString: styleObjectToString,
    getAttr: getAttr,
    setAttr: setAttr,
    safeInsert: safeInsert,
    walkAttrs: walkAttrs,
    walkNodes: walkNodes
  });

  var styleNode;
  var cssTextProp;
  var byName = {};
  var remainder = [];
  var needsInject = false;

  // skip the following code on the server
  if (WIN) {
    styleNode = function () {
      // create a new style element with the correct type
      var newNode = mkEl('style');
      setAttr(newNode, 'type', 'text/css');

      // replace any user node or insert the new one into the head
      var userNode = $('style[type=riot]');
      /* istanbul ignore next */
      if (userNode) {
        if (userNode.id) {
          newNode.id = userNode.id;
        }
        userNode.parentNode.replaceChild(newNode, userNode);
      } else {
        document.getElementsByTagName('head')[0].appendChild(newNode);
      }

      return newNode;
    }();
    cssTextProp = styleNode.styleSheet;
  }

  /**
   * Object that will be used to inject and manage the css of every tag instance
   */
  var styleManager = {
    styleNode: styleNode,
    /**
     * Save a tag style to be later injected into DOM
     * @param { String } css - css string
     * @param { String } name - if it's passed we will map the css to a tagname
     */
    add: function add(css, name) {
      if (name) {
        byName[name] = css;
      } else {
        remainder.push(css);
      }
      needsInject = true;
    },
    /**
     * Inject all previously saved tag styles into DOM
     * innerHTML seems slow: http://jsperf.com/riot-insert-style
     */
    inject: function inject() {
      if (!WIN || !needsInject) {
        return;
      }
      needsInject = false;
      var style = Object.keys(byName).map(function (k) {
        return byName[k];
      }).concat(remainder).join('\n');
      /* istanbul ignore next */
      if (cssTextProp) {
        cssTextProp.cssText = style;
      } else {
        styleNode.innerHTML = style;
      }
    }
  };

  /**
   * The riot template engine
   * @version v3.0.3
   */
  /**
   * riot.util.brackets
   *
   * - `brackets    ` - Returns a string or regex based on its parameter
   * - `brackets.set` - Change the current riot brackets
   *
   * @module
   */

  /* global riot */

  /* istanbul ignore next */
  var brackets = function (UNDEF) {

    var REGLOB = 'g',
        R_MLCOMMS = /\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g,
        R_STRINGS = /"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'|`[^`\\]*(?:\\[\S\s][^`\\]*)*`/g,
        S_QBLOCKS = R_STRINGS.source + '|' + /(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source + '|' + /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?(\/)[gim]*/.source,
        UNSUPPORTED = RegExp('[\\' + 'x00-\\x1F<>a-zA-Z0-9\'",;\\\\]'),
        NEED_ESCAPE = /(?=[[\]()*+?.^$|])/g,
        FINDBRACES = {
      '(': RegExp('([()])|' + S_QBLOCKS, REGLOB),
      '[': RegExp('([[\\]])|' + S_QBLOCKS, REGLOB),
      '{': RegExp('([{}])|' + S_QBLOCKS, REGLOB)
    },
        DEFAULT = '{ }';

    var _pairs = ['{', '}', '{', '}', /{[^}]*}/, /\\([{}])/g, /\\({)|{/g, RegExp('\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB), DEFAULT, /^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/, /(^|[^\\]){=[\S\s]*?}/];

    var cachedBrackets = UNDEF,
        _regex,
        _cache = [],
        _settings;

    function _loopback(re) {
      return re;
    }

    function _rewrite(re, bp) {
      if (!bp) {
        bp = _cache;
      }
      return new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : '');
    }

    function _create(pair) {
      if (pair === DEFAULT) {
        return _pairs;
      }

      var arr = pair.split(' ');

      if (arr.length !== 2 || UNSUPPORTED.test(pair)) {
        throw new Error('Unsupported brackets "' + pair + '"');
      }
      arr = arr.concat(pair.replace(NEED_ESCAPE, '\\').split(' '));

      arr[4] = _rewrite(arr[1].length > 1 ? /{[\S\s]*?}/ : _pairs[4], arr);
      arr[5] = _rewrite(pair.length > 3 ? /\\({|})/g : _pairs[5], arr);
      arr[6] = _rewrite(_pairs[6], arr);
      arr[7] = RegExp('\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);
      arr[8] = pair;
      return arr;
    }

    function _brackets(reOrIdx) {
      return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx];
    }

    _brackets.split = function split(str, tmpl, _bp) {
      // istanbul ignore next: _bp is for the compiler
      if (!_bp) {
        _bp = _cache;
      }

      var parts = [],
          match,
          isexpr,
          start,
          pos,
          re = _bp[6];

      isexpr = start = re.lastIndex = 0;

      while (match = re.exec(str)) {

        pos = match.index;

        if (isexpr) {

          if (match[2]) {
            re.lastIndex = skipBraces(str, match[2], re.lastIndex);
            continue;
          }
          if (!match[3]) {
            continue;
          }
        }

        if (!match[1]) {
          unescapeStr(str.slice(start, pos));
          start = re.lastIndex;
          re = _bp[6 + (isexpr ^= 1)];
          re.lastIndex = start;
        }
      }

      if (str && start < str.length) {
        unescapeStr(str.slice(start));
      }

      return parts;

      function unescapeStr(s) {
        if (tmpl || isexpr) {
          parts.push(s && s.replace(_bp[5], '$1'));
        } else {
          parts.push(s);
        }
      }

      function skipBraces(s, ch, ix) {
        var match,
            recch = FINDBRACES[ch];

        recch.lastIndex = ix;
        ix = 1;
        while (match = recch.exec(s)) {
          if (match[1] && !(match[1] === ch ? ++ix : --ix)) {
            break;
          }
        }
        return ix ? s.length : recch.lastIndex;
      }
    };

    _brackets.hasExpr = function hasExpr(str) {
      return _cache[4].test(str);
    };

    _brackets.loopKeys = function loopKeys(expr) {
      var m = expr.match(_cache[9]);

      return m ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] } : { val: expr.trim() };
    };

    _brackets.array = function array(pair) {
      return pair ? _create(pair) : _cache;
    };

    function _reset(pair) {
      if ((pair || (pair = DEFAULT)) !== _cache[8]) {
        _cache = _create(pair);
        _regex = pair === DEFAULT ? _loopback : _rewrite;
        _cache[9] = _regex(_pairs[9]);
      }
      cachedBrackets = pair;
    }

    function _setSettings(o) {
      var b;

      o = o || {};
      b = o.brackets;
      Object.defineProperty(o, 'brackets', {
        set: _reset,
        get: function () {
          return cachedBrackets;
        },
        enumerable: true
      });
      _settings = o;
      _reset(b);
    }

    Object.defineProperty(_brackets, 'settings', {
      set: _setSettings,
      get: function () {
        return _settings;
      }
    });

    /* istanbul ignore next: in the browser riot is always in the scope */
    _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};
    _brackets.set = _reset;

    _brackets.R_STRINGS = R_STRINGS;
    _brackets.R_MLCOMMS = R_MLCOMMS;
    _brackets.S_QBLOCKS = S_QBLOCKS;

    return _brackets;
  }();

  /**
   * @module tmpl
   *
   * tmpl          - Root function, returns the template value, render with data
   * tmpl.hasExpr  - Test the existence of a expression inside a string
   * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)
   */

  /* istanbul ignore next */
  var tmpl = function () {

    var _cache = {};

    function _tmpl(str, data) {
      if (!str) {
        return str;
      }

      return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr);
    }

    _tmpl.hasExpr = brackets.hasExpr;

    _tmpl.loopKeys = brackets.loopKeys;

    // istanbul ignore next
    _tmpl.clearCache = function () {
      _cache = {};
    };

    _tmpl.errorHandler = null;

    function _logErr(err, ctx) {

      err.riotData = {
        tagName: ctx && ctx.__ && ctx.__.tagName,
        _riot_id: ctx && ctx._riot_id //eslint-disable-line camelcase
      };

      if (_tmpl.errorHandler) {
        _tmpl.errorHandler(err);
      } else if (typeof console !== 'undefined' && typeof console.error === 'function') {
        if (err.riotData.tagName) {
          console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);
        }
        console.error(err);
      }
    }

    function _create(str) {
      var expr = _getTmpl(str);

      if (expr.slice(0, 11) !== 'try{return ') {
        expr = 'return ' + expr;
      }

      return new Function('E', expr + ';'); // eslint-disable-line no-new-func
    }

    var CH_IDEXPR = String.fromCharCode(0x2057),
        RE_CSNAME = /^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\u2057(\d+)~):/,
        RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),
        RE_DQUOTE = /\u2057/g,
        RE_QBMARK = /\u2057(\d+)~/g;

    function _getTmpl(str) {
      var qstr = [],
          expr,
          parts = brackets.split(str.replace(RE_DQUOTE, '"'), 1);

      if (parts.length > 2 || parts[0]) {
        var i,
            j,
            list = [];

        for (i = j = 0; i < parts.length; ++i) {

          expr = parts[i];

          if (expr && (expr = i & 1 ? _parseExpr(expr, 1, qstr) : '"' + expr.replace(/\\/g, '\\\\').replace(/\r\n?|\n/g, '\\n').replace(/"/g, '\\"') + '"')) {
            list[j++] = expr;
          }
        }

        expr = j < 2 ? list[0] : '[' + list.join(',') + '].join("")';
      } else {

        expr = _parseExpr(parts[1], 0, qstr);
      }

      if (qstr[0]) {
        expr = expr.replace(RE_QBMARK, function (_, pos) {
          return qstr[pos].replace(/\r/g, '\\r').replace(/\n/g, '\\n');
        });
      }
      return expr;
    }

    var RE_BREND = {
      '(': /[()]/g,
      '[': /[[\]]/g,
      '{': /[{}]/g
    };

    function _parseExpr(expr, asText, qstr) {

      expr = expr.replace(RE_QBLOCK, function (s, div) {
        return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s;
      }).replace(/\s+/g, ' ').trim().replace(/\ ?([[\({},?\.:])\ ?/g, '$1');

      if (expr) {
        var list = [],
            cnt = 0,
            match;

        while (expr && (match = expr.match(RE_CSNAME)) && !match.index) {
          var key,
              jsb,
              re = /,|([[{(])|$/g;

          expr = RegExp.rightContext;
          key = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\s+/g, ' ') : match[1];

          while (jsb = (match = re.exec(expr))[1]) {
            skipBraces(jsb, re);
          }

          jsb = expr.slice(0, match.index);
          expr = RegExp.rightContext;

          list[cnt++] = _wrapExpr(jsb, 1, key);
        }

        expr = !cnt ? _wrapExpr(expr, asText) : cnt > 1 ? '[' + list.join(',') + '].join(" ").trim()' : list[0];
      }
      return expr;

      function skipBraces(ch, re) {
        var mm,
            lv = 1,
            ir = RE_BREND[ch];

        ir.lastIndex = re.lastIndex;
        while (mm = ir.exec(expr)) {
          if (mm[0] === ch) {
            ++lv;
          } else if (! --lv) {
            break;
          }
        }
        re.lastIndex = lv ? expr.length : ir.lastIndex;
      }
    }

    // istanbul ignore next: not both
    var // eslint-disable-next-line max-len
    JS_CONTEXT = '"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',
        JS_VARNAME = /[,{][\$\w]+(?=:)|(^ *|[^$\w\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g,
        JS_NOPROPS = /^(?=(\.[$\w]+))\1(?:[^.[(]|$)/;

    function _wrapExpr(expr, asText, key) {
      var tb;

      expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {
        if (mvar) {
          pos = tb ? 0 : pos + match.length;

          if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {
            match = p + '("' + mvar + JS_CONTEXT + mvar;
            if (pos) {
              tb = (s = s[pos]) === '.' || s === '(' || s === '[';
            }
          } else if (pos) {
            tb = !JS_NOPROPS.test(s.slice(pos));
          }
        }
        return match;
      });

      if (tb) {
        expr = 'try{return ' + expr + '}catch(e){E(e,this)}';
      }

      if (key) {

        expr = (tb ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')') + '?"' + key + '":""';
      } else if (asText) {

        expr = 'function(v){' + (tb ? expr.replace('return ', 'v=') : 'v=(' + expr + ')') + ';return v||v===0?v:""}.call(this)';
      }

      return expr;
    }

    _tmpl.version = brackets.version = 'v3.0.3';

    return _tmpl;
  }();

  /* istanbul ignore next */
  var observable$1 = function (el) {

    /**
     * Extend the original object or create a new empty one
     * @type { Object }
     */

    el = el || {};

    /**
     * Private variables
     */
    var callbacks = {},
        slice = Array.prototype.slice;

    /**
     * Public Api
     */

    // extend the el object adding the observable methods
    Object.defineProperties(el, {
      /**
       * Listen to the given `event` ands
       * execute the `callback` each time an event is triggered.
       * @param  { String } event - event id
       * @param  { Function } fn - callback function
       * @returns { Object } el
       */
      on: {
        value: function (event, fn) {
          if (typeof fn == 'function') {
            (callbacks[event] = callbacks[event] || []).push(fn);
          }
          return el;
        },
        enumerable: false,
        writable: false,
        configurable: false
      },

      /**
       * Removes the given `event` listeners
       * @param   { String } event - event id
       * @param   { Function } fn - callback function
       * @returns { Object } el
       */
      off: {
        value: function (event, fn) {
          if (event == '*' && !fn) {
            callbacks = {};
          } else {
            if (fn) {
              var arr = callbacks[event];
              for (var i = 0, cb; cb = arr && arr[i]; ++i) {
                if (cb == fn) {
                  arr.splice(i--, 1);
                }
              }
            } else {
              delete callbacks[event];
            }
          }
          return el;
        },
        enumerable: false,
        writable: false,
        configurable: false
      },

      /**
       * Listen to the given `event` and
       * execute the `callback` at most once
       * @param   { String } event - event id
       * @param   { Function } fn - callback function
       * @returns { Object } el
       */
      one: {
        value: function (event, fn) {
          function on() {
            el.off(event, on);
            fn.apply(el, arguments);
          }
          return el.on(event, on);
        },
        enumerable: false,
        writable: false,
        configurable: false
      },

      /**
       * Execute all callback functions that listen to
       * the given `event`
       * @param   { String } event - event id
       * @returns { Object } el
       */
      trigger: {
        value: function (event) {
          var arguments$1 = arguments;

          // getting the arguments
          var arglen = arguments.length - 1,
              args = new Array(arglen),
              fns,
              fn,
              i;

          for (i = 0; i < arglen; i++) {
            args[i] = arguments$1[i + 1]; // skip first argument
          }

          fns = slice.call(callbacks[event] || [], 0);

          for (i = 0; fn = fns[i]; ++i) {
            fn.apply(el, args);
          }

          if (callbacks['*'] && event != '*') {
            el.trigger.apply(el, ['*', event].concat(args));
          }

          return el;
        },
        enumerable: false,
        writable: false,
        configurable: false
      }
    });

    return el;
  };

  /**
   * Specialized function for looping an array-like collection with `each={}`
   * @param   { Array } list - collection of items
   * @param   {Function} fn - callback function
   * @returns { Array } the array looped
   */
  function each(list, fn) {
    var len = list ? list.length : 0;
    var i = 0;
    for (; i < len; ++i) {
      fn(list[i], i);
    }
    return list;
  }

  /**
   * Check whether an array contains an item
   * @param   { Array } array - target array
   * @param   { * } item - item to test
   * @returns { Boolean } -
   */
  function contains(array, item) {
    return array.indexOf(item) !== -1;
  }

  /**
   * Convert a string containing dashes to camel case
   * @param   { String } str - input string
   * @returns { String } my-string -> myString
   */
  function toCamel(str) {
    return str.replace(/-(\w)/g, function (_, c) {
      return c.toUpperCase();
    });
  }

  /**
   * Faster String startsWith alternative
   * @param   { String } str - source string
   * @param   { String } value - test string
   * @returns { Boolean } -
   */
  function startsWith(str, value) {
    return str.slice(0, value.length) === value;
  }

  /**
   * Helper function to set an immutable property
   * @param   { Object } el - object where the new property will be set
   * @param   { String } key - object key where the new property will be stored
   * @param   { * } value - value of the new property
   * @param   { Object } options - set the propery overriding the default options
   * @returns { Object } - the initial object
   */
  function defineProperty(el, key, value, options) {
    Object.defineProperty(el, key, extend({
      value: value,
      enumerable: false,
      writable: false,
      configurable: true
    }, options));
    return el;
  }

  /**
   * Extend any object with other properties
   * @param   { Object } src - source object
   * @returns { Object } the resulting extended object
   *
   * var obj = { foo: 'baz' }
   * extend(obj, {bar: 'bar', foo: 'bar'})
   * console.log(obj) => {bar: 'bar', foo: 'bar'}
   *
   */
  function extend(src) {
    var obj,
        args = arguments;
    for (var i = 1; i < args.length; ++i) {
      if (obj = args[i]) {
        for (var key in obj) {
          // check if this property of the source object could be overridden
          if (isWritable(src, key)) {
            src[key] = obj[key];
          }
        }
      }
    }
    return src;
  }

  var misc = Object.freeze({
    each: each,
    contains: contains,
    toCamel: toCamel,
    startsWith: startsWith,
    defineProperty: defineProperty,
    extend: extend
  });

  var settings$1 = extend(Object.create(brackets.settings), {
    skipAnonymousTags: true
  });

  /**
   * Trigger DOM events
   * @param   { HTMLElement } dom - dom element target of the event
   * @param   { Function } handler - user function
   * @param   { Object } e - event object
   */
  function handleEvent(dom, handler, e) {
    var ptag = this.__.parent,
        item = this.__.item;

    if (!item) {
      while (ptag && !item) {
        item = ptag.__.item;
        ptag = ptag.__.parent;
      }
    }

    // override the event properties
    /* istanbul ignore next */
    if (isWritable(e, 'currentTarget')) {
      e.currentTarget = dom;
    }
    /* istanbul ignore next */
    if (isWritable(e, 'target')) {
      e.target = e.srcElement;
    }
    /* istanbul ignore next */
    if (isWritable(e, 'which')) {
      e.which = e.charCode || e.keyCode;
    }

    e.item = item;

    handler.call(this, e);

    if (!e.preventUpdate) {
      var p = getImmediateCustomParentTag(this);
      // fixes #2083
      if (p.isMounted) {
        p.update();
      }
    }
  }

  /**
   * Attach an event to a DOM node
   * @param { String } name - event name
   * @param { Function } handler - event callback
   * @param { Object } dom - dom node
   * @param { Tag } tag - tag instance
   */
  function setEventHandler(name, handler, dom, tag) {
    var eventName,
        cb = handleEvent.bind(tag, dom, handler);

    // normalize event name
    eventName = name.replace(RE_EVENTS_PREFIX, '');

    // cache the listener into the listeners array
    if (!contains(tag.__.listeners, dom)) {
      tag.__.listeners.push(dom);
    }
    if (!dom[RIOT_EVENTS_KEY]) {
      dom[RIOT_EVENTS_KEY] = {};
    }
    if (dom[RIOT_EVENTS_KEY][name]) {
      dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]);
    }

    dom[RIOT_EVENTS_KEY][name] = cb;
    dom.addEventListener(eventName, cb, false);
  }

  /**
   * Update dynamically created data-is tags with changing expressions
   * @param { Object } expr - expression tag and expression info
   * @param { Tag }    parent - parent for tag creation
   * @param { String } tagName - tag implementation we want to use
   */
  function updateDataIs(expr, parent, tagName) {
    var conf, isVirtual, head, ref;

    if (expr.tag && expr.tagName === tagName) {
      expr.tag.update();
      return;
    }

    isVirtual = expr.dom.tagName === 'VIRTUAL';
    // sync _parent to accommodate changing tagnames
    if (expr.tag) {

      // need placeholder before unmount
      if (isVirtual) {
        head = expr.tag.__.head;
        ref = createDOMPlaceholder();
        head.parentNode.insertBefore(ref, head);
      }

      expr.tag.unmount(true);
    }

    expr.impl = __TAG_IMPL[tagName];
    conf = { root: expr.dom, parent: parent, hasImpl: true, tagName: tagName };
    expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);
    each(expr.attrs, function (a) {
      return setAttr(expr.tag.root, a.name, a.value);
    });
    expr.tagName = tagName;
    expr.tag.mount();
    if (isVirtual) {
      makeReplaceVirtual(expr.tag, ref || expr.tag.root);
    } // root exist first time, after use placeholder

    // parent is the placeholder tag, not the dynamic tag so clean up
    parent.__.onUnmount = function () {
      var delName = expr.tag.opts.dataIs,
          tags = expr.tag.parent.tags,
          _tags = expr.tag.__.parent.tags;
      arrayishRemove(tags, delName, expr.tag);
      arrayishRemove(_tags, delName, expr.tag);
      expr.tag.unmount();
    };
  }

  /**
   * Nomalize any attribute removing the "riot-" prefix
   * @param   { String } attrName - original attribute name
   * @returns { String } valid html attribute name
   */
  function normalizeAttrName(attrName) {
    if (!attrName) {
      return null;
    }
    attrName = attrName.replace(ATTRS_PREFIX, '');
    if (CASE_SENSITIVE_ATTRIBUTES[attrName]) {
      attrName = CASE_SENSITIVE_ATTRIBUTES[attrName];
    }
    return attrName;
  }

  /**
   * Update on single tag expression
   * @this Tag
   * @param { Object } expr - expression logic
   * @returns { undefined }
   */
  function updateExpression(expr) {
    if (this.root && getAttr(this.root, 'virtualized')) {
      return;
    }

    var dom = expr.dom,

    // remove the riot- prefix
    attrName = normalizeAttrName(expr.attr),
        isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName),
        isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',
        parent = dom && (expr.parent || dom.parentNode),

    // detect the style attributes
    isStyleAttr = attrName === 'style',
        isClassAttr = attrName === 'class',
        isObj,
        value;

    // if it's a tag we could totally skip the rest
    if (expr._riot_id) {
      if (expr.isMounted) {
        expr.update();
        // if it hasn't been mounted yet, do that now.
      } else {
        expr.mount();
        if (isVirtual) {
          makeReplaceVirtual(expr, expr.root);
        }
      }
      return;
    }
    // if this expression has the update method it means it can handle the DOM changes by itself
    if (expr.update) {
      return expr.update();
    }

    // ...it seems to be a simple expression so we try to calculat its value
    value = tmpl(expr.expr, this);
    isObj = isObject(value);

    // convert the style/class objects to strings
    if (isObj) {
      isObj = !isClassAttr && !isStyleAttr;
      if (isClassAttr) {
        value = tmpl(JSON.stringify(value), this);
      } else if (isStyleAttr) {
        value = styleObjectToString(value);
      }
    }

    // remove original attribute
    if (expr.attr && (!expr.isAttrRemoved || !value)) {
      remAttr(dom, expr.attr);
      expr.isAttrRemoved = true;
    }

    // for the boolean attributes we don't need the value
    // we can convert it to checked=true to checked=checked
    if (expr.bool) {
      value = value ? attrName : false;
    }
    if (expr.isRtag) {
      return updateDataIs(expr, this, value);
    }
    if (expr.wasParsedOnce && expr.value === value) {
      return;
    }

    // update the expression value
    expr.value = value;
    expr.wasParsedOnce = true;

    // if the value is an object we can not do much more with it
    if (isObj && !isToggle) {
      return;
    }
    // avoid to render undefined/null values
    if (isBlank(value)) {
      value = '';
    }

    // textarea and text nodes have no attribute name
    if (!attrName) {
      // about #815 w/o replace: the browser converts the value to a string,
      // the comparison by "==" does too, but not in the server
      value += '';
      // test for parent avoids error with invalid assignment to nodeValue
      if (parent) {
        // cache the parent node because somehow it will become null on IE
        // on the next iteration
        expr.parent = parent;
        if (parent.tagName === 'TEXTAREA') {
          parent.value = value; // #1113
          if (!IE_VERSION) {
            dom.nodeValue = value;
          } // #1625 IE throws here, nodeValue
        } // will be available on 'updated'
        else {
            dom.nodeValue = value;
          }
      }
      return;
    }

    // event handler
    if (isFunction(value)) {
      setEventHandler(attrName, value, dom, this);
      // show / hide
    } else if (isToggle) {
      toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);
      // handle attributes
    } else {
      if (expr.bool) {
        dom[attrName] = value;
      }

      if (attrName === 'value' && dom.value !== value) {
        dom.value = value;
      }

      if (!isBlank(value) && value !== false) {
        setAttr(dom, attrName, value);
      }

      // make sure that in case of style changes
      // the element stays hidden
      if (isStyleAttr && dom.hidden) {
        toggleVisibility(dom, false);
      }
    }
  }

  /**
   * Update all the expressions in a Tag instance
   * @this Tag
   * @param { Array } expressions - expression that must be re evaluated
   */
  function updateAllExpressions(expressions) {
    each(expressions, updateExpression.bind(this));
  }

  var IfExpr = {
    init: function init(dom, tag, expr) {
      remAttr(dom, CONDITIONAL_DIRECTIVE);
      this.tag = tag;
      this.expr = expr;
      this.stub = document.createTextNode('');
      this.pristine = dom;

      var p = dom.parentNode;
      p.insertBefore(this.stub, dom);
      p.removeChild(dom);

      return this;
    },
    update: function update() {
      this.value = tmpl(this.expr, this.tag);

      if (this.value && !this.current) {
        // insert
        this.current = this.pristine.cloneNode(true);
        this.stub.parentNode.insertBefore(this.current, this.stub);
        this.expressions = [];
        parseExpressions.apply(this.tag, [this.current, this.expressions, true]);
      } else if (!this.value && this.current) {
        // remove
        unmountAll(this.expressions);
        if (this.current._tag) {
          this.current._tag.unmount();
        } else if (this.current.parentNode) {
          this.current.parentNode.removeChild(this.current);
        }
        this.current = null;
        this.expressions = [];
      }

      if (this.value) {
        updateAllExpressions.call(this.tag, this.expressions);
      }
    },
    unmount: function unmount() {
      unmountAll(this.expressions || []);
      delete this.pristine;
      delete this.parentNode;
      delete this.stub;
    }
  };

  var RefExpr = {
    init: function init(dom, parent, attrName, attrValue) {
      this.dom = dom;
      this.attr = attrName;
      this.rawValue = attrValue;
      this.parent = parent;
      this.hasExp = tmpl.hasExpr(attrValue);
      return this;
    },
    update: function update() {
      var old = this.value;
      var customParent = this.parent && getImmediateCustomParentTag(this.parent);
      // if the referenced element is a custom tag, then we set the tag itself, rather than DOM
      var tagOrDom = this.tag || this.dom;

      this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue;

      // the name changed, so we need to remove it from the old key (if present)
      if (!isBlank(old) && customParent) {
        arrayishRemove(customParent.refs, old, tagOrDom);
      }

      if (isBlank(this.value)) {
        // if the value is blank, we remove it
        remAttr(this.dom, this.attr);
      } else {
        // add it to the refs of parent tag (this behavior was changed >=3.0)
        if (customParent) {
          arrayishAdd(customParent.refs, this.value, tagOrDom,
          // use an array if it's a looped node and the ref is not an expression
          null, this.parent.__.index);
        }
        // set the actual DOM attr
        setAttr(this.dom, this.attr, this.value);
      }
    },
    unmount: function unmount() {
      var tagOrDom = this.tag || this.dom;
      var customParent = this.parent && getImmediateCustomParentTag(this.parent);
      if (!isBlank(this.value) && customParent) {
        arrayishRemove(customParent.refs, this.value, tagOrDom);
      }
      delete this.dom;
      delete this.parent;
    }
  };

  /**
   * Convert the item looped into an object used to extend the child tag properties
   * @param   { Object } expr - object containing the keys used to extend the children tags
   * @param   { * } key - value to assign to the new object returned
   * @param   { * } val - value containing the position of the item in the array
   * @param   { Object } base - prototype object for the new item
   * @returns { Object } - new object containing the values of the original item
   *
   * The variables 'key' and 'val' are arbitrary.
   * They depend on the collection type looped (Array, Object)
   * and on the expression used on the each tag
   *
   */
  function mkitem(expr, key, val, base) {
    var item = base ? Object.create(base) : {};
    item[expr.key] = key;
    if (expr.pos) {
      item[expr.pos] = val;
    }
    return item;
  }

  /**
   * Unmount the redundant tags
   * @param   { Array } items - array containing the current items to loop
   * @param   { Array } tags - array containing all the children tags
   */
  function unmountRedundant(items, tags) {
    var i = tags.length,
        j = items.length;

    while (i > j) {
      i--;
      remove.apply(tags[i], [tags, i]);
    }
  }

  /**
   * Remove a child tag
   * @this Tag
   * @param   { Array } tags - tags collection
   * @param   { Number } i - index of the tag to remove
   */
  function remove(tags, i) {
    tags.splice(i, 1);
    this.unmount();
    arrayishRemove(this.parent, this, this.__.tagName, true);
  }

  /**
   * Move the nested custom tags in non custom loop tags
   * @this Tag
   * @param   { Number } i - current position of the loop tag
   */
  function moveNestedTags(i) {
    var this$1 = this;

    each(Object.keys(this.tags), function (tagName) {
      moveChildTag.apply(this$1.tags[tagName], [tagName, i]);
    });
  }

  /**
   * Move a child tag
   * @this Tag
   * @param   { HTMLElement } root - dom node containing all the loop children
   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move
   * @param   { Boolean } isVirtual - is it a virtual tag?
   */
  function move(root, nextTag, isVirtual) {
    if (isVirtual) {
      moveVirtual.apply(this, [root, nextTag]);
    } else {
      safeInsert(root, this.root, nextTag.root);
    }
  }

  /**
   * Insert and mount a child tag
   * @this Tag
   * @param   { HTMLElement } root - dom node containing all the loop children
   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert
   * @param   { Boolean } isVirtual - is it a virtual tag?
   */
  function insert(root, nextTag, isVirtual) {
    if (isVirtual) {
      makeVirtual.apply(this, [root, nextTag]);
    } else {
      safeInsert(root, this.root, nextTag.root);
    }
  }

  /**
   * Append a new tag into the DOM
   * @this Tag
   * @param   { HTMLElement } root - dom node containing all the loop children
   * @param   { Boolean } isVirtual - is it a virtual tag?
   */
  function append(root, isVirtual) {
    if (isVirtual) {
      makeVirtual.call(this, root);
    } else {
      root.appendChild(this.root);
    }
  }

  /**
   * Manage tags having the 'each'
   * @param   { HTMLElement } dom - DOM node we need to loop
   * @param   { Tag } parent - parent tag instance where the dom node is contained
   * @param   { String } expr - string contained in the 'each' attribute
   * @returns { Object } expression object for this each loop
   */
  function _each(dom, parent, expr) {

    // remove the each property from the original tag
    remAttr(dom, LOOP_DIRECTIVE);

    var mustReorder = typeof getAttr(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || remAttr(dom, LOOP_NO_REORDER_DIRECTIVE),
        tagName = getTagName(dom),
        impl = __TAG_IMPL[tagName],
        parentNode = dom.parentNode,
        placeholder = createDOMPlaceholder(),
        child = getTag(dom),
        ifExpr = getAttr(dom, CONDITIONAL_DIRECTIVE),
        tags = [],
        oldItems = [],
        hasKeys,
        isLoop = true,
        isAnonymous = !__TAG_IMPL[tagName],
        isVirtual = dom.tagName === 'VIRTUAL';

    // parse the each expression
    expr = tmpl.loopKeys(expr);
    expr.isLoop = true;

    if (ifExpr) {
      remAttr(dom, CONDITIONAL_DIRECTIVE);
    }

    // insert a marked where the loop tags will be injected
    parentNode.insertBefore(placeholder, dom);
    parentNode.removeChild(dom);

    expr.update = function updateEach() {
      // get the new items collection
      expr.value = tmpl(expr.val, parent);

      var frag = createFrag(),
          items = expr.value,
          isObject$$1 = !isArray(items) && !isString(items),
          root = placeholder.parentNode;

      // object loop. any changes cause full redraw
      if (isObject$$1) {
        hasKeys = items || false;
        items = hasKeys ? Object.keys(items).map(function (key) {
          return mkitem(expr, items[key], key);
        }) : [];
      } else {
        hasKeys = false;
      }

      if (ifExpr) {
        items = items.filter(function (item, i) {
          if (expr.key && !isObject$$1) {
            return !!tmpl(ifExpr, mkitem(expr, item, i, parent));
          }

          return !!tmpl(ifExpr, extend(Object.create(parent), item));
        });
      }

      // loop all the new items
      each(items, function (item, i) {
        // reorder only if the items are objects
        var doReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,
            oldPos = oldItems.indexOf(item),
            isNew = oldPos === -1,
            pos = !isNew && doReorder ? oldPos : i,

        // does a tag exist in this position?
        tag = tags[pos],
            mustAppend = i >= oldItems.length,
            mustCreate = doReorder && isNew || !doReorder && !tag;

        item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;

        // new tag
        if (mustCreate) {
          tag = new Tag$1(impl, {
            parent: parent,
            isLoop: isLoop,
            isAnonymous: isAnonymous,
            tagName: tagName,
            root: dom.cloneNode(isAnonymous),
            item: item,
            index: i
          }, dom.innerHTML);

          // mount the tag
          tag.mount();

          if (mustAppend) {
            append.apply(tag, [frag || root, isVirtual]);
          } else {
            insert.apply(tag, [root, tags[i], isVirtual]);
          }

          if (!mustAppend) {
            oldItems.splice(i, 0, item);
          }
          tags.splice(i, 0, tag);
          if (child) {
            arrayishAdd(parent.tags, tagName, tag, true);
          }
        } else if (pos !== i && doReorder) {
          // move
          if (contains(items, oldItems[pos])) {
            move.apply(tag, [root, tags[i], isVirtual]);
            // move the old tag instance
            tags.splice(i, 0, tags.splice(pos, 1)[0]);
            // move the old item
            oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);
          }

          // update the position attribute if it exists
          if (expr.pos) {
            tag[expr.pos] = i;
          }

          // if the loop tags are not custom
          // we need to move all their custom tags into the right position
          if (!child && tag.tags) {
            moveNestedTags.call(tag, i);
          }
        }

        // cache the original item to use it in the events bound to this node
        // and its children
        tag.__.item = item;
        tag.__.index = i;
        tag.__.parent = parent;

        if (!mustCreate) {
          tag.update(item);
        }
      });

      // remove the redundant tags
      unmountRedundant(items, tags);

      // clone the items array
      oldItems = items.slice();

      root.insertBefore(frag, placeholder);
    };

    expr.unmount = function () {
      each(tags, function (t) {
        t.unmount();
      });
    };

    return expr;
  }

  /**
   * Walk the tag DOM to detect the expressions to evaluate
   * @this Tag
   * @param   { HTMLElement } root - root tag where we will start digging the expressions
   * @param   { Array } expressions - empty array where the expressions will be added
   * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well
   * @returns { Object } an object containing the root noode and the dom tree
   */
  function parseExpressions(root, expressions, mustIncludeRoot) {
    var this$1 = this;

    var tree = { parent: { children: expressions } };

    walkNodes(root, function (dom, ctx) {
      var type = dom.nodeType,
          parent = ctx.parent,
          attr,
          expr,
          tagImpl;
      if (!mustIncludeRoot && dom === root) {
        return { parent: parent };
      }

      // text node
      if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue)) {
        parent.children.push({ dom: dom, expr: dom.nodeValue });
      }

      if (type !== 1) {
        return ctx;
      } // not an element

      var isVirtual = dom.tagName === 'VIRTUAL';

      // loop. each does it's own thing (for now)
      if (attr = getAttr(dom, LOOP_DIRECTIVE)) {
        if (isVirtual) {
          setAttr(dom, 'loopVirtual', true);
        } // ignore here, handled in _each
        parent.children.push(_each(dom, this$1, attr));
        return false;
      }

      // if-attrs become the new parent. Any following expressions (either on the current
      // element, or below it) become children of this expression.
      if (attr = getAttr(dom, CONDITIONAL_DIRECTIVE)) {
        parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));
        return false;
      }

      if (expr = getAttr(dom, IS_DIRECTIVE)) {
        if (tmpl.hasExpr(expr)) {
          parent.children.push({ isRtag: true, expr: expr, dom: dom, attrs: [].slice.call(dom.attributes) });
          return false;
        }
      }

      // if this is a tag, stop traversing here.
      // we ignore the root, since parseExpressions is called while we're mounting that root
      tagImpl = getTag(dom);
      if (isVirtual) {
        if (getAttr(dom, 'virtualized')) {
          dom.parentElement.removeChild(dom);
        } // tag created, remove from dom
        if (!tagImpl && !getAttr(dom, 'virtualized') && !getAttr(dom, 'loopVirtual')) // ok to create virtual tag
          {
            tagImpl = { tmpl: dom.outerHTML };
          }
      }

      if (tagImpl && (dom !== root || mustIncludeRoot)) {
        if (isVirtual && !getAttr(dom, IS_DIRECTIVE)) {
          // handled in update
          // can not remove attribute like directives
          // so flag for removal after creation to prevent maximum stack error
          setAttr(dom, 'virtualized', true);

          var tag = new Tag$1({ tmpl: dom.outerHTML }, { root: dom, parent: this$1 }, dom.innerHTML);
          parent.children.push(tag); // no return, anonymous tag, keep parsing
        } else {
          var conf = { root: dom, parent: this$1, hasImpl: true };
          parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));
          return false;
        }
      }

      // attribute expressions
      parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {
        if (!expr) {
          return;
        }
        parent.children.push(expr);
      }]);

      // whatever the parent is, all child elements get the same parent.
      // If this element had an if-attr, that's the parent for all child elements
      return { parent: parent };
    }, tree);
  }

  /**
   * Calls `fn` for every attribute on an element. If that attr has an expression,
   * it is also passed to fn.
   * @this Tag
   * @param   { HTMLElement } dom - dom node to parse
   * @param   { Array } attrs - array of attributes
   * @param   { Function } fn - callback to exec on any iteration
   */
  function parseAttributes(dom, attrs, fn) {
    var this$1 = this;

    each(attrs, function (attr) {
      var name = attr.name,
          bool = isBoolAttr(name),
          expr;

      if (contains(REF_DIRECTIVES, name)) {
        expr = Object.create(RefExpr).init(dom, this$1, name, attr.value);
      } else if (tmpl.hasExpr(attr.value)) {
        expr = { dom: dom, expr: attr.value, attr: name, bool: bool };
      }

      fn(attr, expr);
    });
  }

  /*
    Includes hacks needed for the Internet Explorer version 9 and below
    See: http://kangax.github.io/compat-table/es5/#ie8
         http://codeplanet.io/dropping-ie8/
  */

  var reHasYield = /<yield\b/i;
  var reYieldAll = /<yield\s*(?:\/>|>([\S\s]*?)<\/yield\s*>|>)/ig;
  var reYieldSrc = /<yield\s+to=['"]([^'">]*)['"]\s*>([\S\s]*?)<\/yield\s*>/ig;
  var reYieldDest = /<yield\s+from=['"]?([-\w]+)['"]?\s*(?:\/>|>([\S\s]*?)<\/yield\s*>)/ig;
  var rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };
  var tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;
  var GENERIC = 'div';

  /*
    Creates the root element for table or select child elements:
    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup
  */
  function specialTags(el, tmpl, tagName) {

    var select = tagName[0] === 'o',
        parent = select ? 'select>' : 'table>';

    // trim() is important here, this ensures we don't have artifacts,
    // so we can check if we have only one element inside the parent
    el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;
    parent = el.firstChild;

    // returns the immediate parent if tr/th/td/col is the only element, if not
    // returns the whole tree, as this can include additional elements
    /* istanbul ignore next */
    if (select) {
      parent.selectedIndex = -1; // for IE9, compatible w/current riot behavior
    } else {
      // avoids insertion of cointainer inside container (ex: tbody inside tbody)
      var tname = rootEls[tagName];
      if (tname && parent.childElementCount === 1) {
        parent = $(tname, parent);
      }
    }
    return parent;
  }

  /*
    Replace the yield tag from any tag template with the innerHTML of the
    original tag in the page
  */
  function replaceYield(tmpl, html) {
    // do nothing if no yield
    if (!reHasYield.test(tmpl)) {
      return tmpl;
    }

    // be careful with #1343 - string on the source having `$1`
    var src = {};

    html = html && html.replace(reYieldSrc, function (_, ref, text) {
      src[ref] = src[ref] || text; // preserve first definition
      return '';
    }).trim();

    return tmpl.replace(reYieldDest, function (_, ref, def) {
      // yield with from - to attrs
      return src[ref] || def || '';
    }).replace(reYieldAll, function (_, def) {
      // yield without any "from"
      return html || def || '';
    });
  }

  /**
   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be
   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.
   *
   * @param   { String } tmpl  - The template coming from the custom tag definition
   * @param   { String } html - HTML content that comes from the DOM element where you
   *           will mount the tag, mostly the original tag in the page
   * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.
   */
  function mkdom(tmpl, html) {
    var match = tmpl && tmpl.match(/^\s*<([-\w]+)/),
        tagName = match && match[1].toLowerCase(),
        el = mkEl(GENERIC);

    // replace all the yield tags with the tag inner html
    tmpl = replaceYield(tmpl, html);

    /* istanbul ignore next */
    if (tblTags.test(tagName)) {
      el = specialTags(el, tmpl, tagName);
    } else {
      setInnerHTML(el, tmpl);
    }

    return el;
  }

  /**
   * Another way to create a riot tag a bit more es6 friendly
   * @param { HTMLElement } el - tag DOM selector or DOM node/s
   * @param { Object } opts - tag logic
   * @returns { Tag } new riot tag instance
   */
  function Tag$2(el, opts) {
    // get the tag properties from the class constructor
    var ref = this;
    var name = ref.name;
    var tmpl = ref.tmpl;
    var css = ref.css;
    var attrs = ref.attrs;
    var onCreate = ref.onCreate;
    // register a new tag and cache the class prototype
    if (!__TAG_IMPL[name]) {
      tag$1(name, tmpl, css, attrs, onCreate);
      // cache the class constructor
      __TAG_IMPL[name].class = this.constructor;
    }

    // mount the tag using the class instance
    mountTo(el, name, opts, this);
    // inject the component css
    if (css) {
      styleManager.inject();
    }

    return this;
  }

  /**
   * Create a new riot tag implementation
   * @param   { String }   name - name/id of the new riot tag
   * @param   { String }   tmpl - tag template
   * @param   { String }   css - custom tag css
   * @param   { String }   attrs - root tag attributes
   * @param   { Function } fn - user function
   * @returns { String } name/id of the tag just created
   */
  function tag$1(name, tmpl, css, attrs, fn) {
    if (isFunction(attrs)) {
      fn = attrs;

      if (/^[\w\-]+\s?=/.test(css)) {
        attrs = css;
        css = '';
      } else {
        attrs = '';
      }
    }

    if (css) {
      if (isFunction(css)) {
        fn = css;
      } else {
        styleManager.add(css);
      }
    }

    name = name.toLowerCase();
    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };

    return name;
  }

  /**
   * Create a new riot tag implementation (for use by the compiler)
   * @param   { String }   name - name/id of the new riot tag
   * @param   { String }   tmpl - tag template
   * @param   { String }   css - custom tag css
   * @param   { String }   attrs - root tag attributes
   * @param   { Function } fn - user function
   * @returns { String } name/id of the tag just created
   */
  function tag2$1(name, tmpl, css, attrs, fn) {
    if (css) {
      styleManager.add(css, name);
    }

    __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };

    return name;
  }

  /**
   * Mount a tag using a specific tag implementation
   * @param   { * } selector - tag DOM selector or DOM node/s
   * @param   { String } tagName - tag implementation name
   * @param   { Object } opts - tag logic
   * @returns { Array } new tags instances
   */
  function mount$2(selector, tagName, opts) {
    var tags = [];

    function pushTagsTo(root) {
      if (root.tagName) {
        var riotTag = getAttr(root, IS_DIRECTIVE);

        // have tagName? force riot-tag to be the same
        if (tagName && riotTag !== tagName) {
          riotTag = tagName;
          setAttr(root, IS_DIRECTIVE, tagName);
        }

        var tag = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);

        if (tag) {
          tags.push(tag);
        }
      } else if (root.length) {
        each(root, pushTagsTo);
      } // assume nodeList
    }

    // inject styles into DOM
    styleManager.inject();

    if (isObject(tagName)) {
      opts = tagName;
      tagName = 0;
    }

    var elem;
    var allTags;

    // crawl the DOM to find the tag
    if (isString(selector)) {
      selector = selector === '*' ?
      // select all registered tags
      // & tags found with the riot-tag attribute set
      allTags = selectTags() :
      // or just the ones named like the selector
      selector + selectTags(selector.split(/, */));

      // make sure to pass always a selector
      // to the querySelectorAll function
      elem = selector ? $$(selector) : [];
    } else
      // probably you have passed already a tag or a NodeList
      {
        elem = selector;
      }

    // select all the registered and mount them inside their root elements
    if (tagName === '*') {
      // get all custom tags
      tagName = allTags || selectTags();
      // if the root els it's just a single tag
      if (elem.tagName) {
        elem = $$(tagName, elem);
      } else {
        // select all the children for all the different root elements
        var nodeList = [];

        each(elem, function (_el) {
          return nodeList.push($$(tagName, _el));
        });

        elem = nodeList;
      }
      // get rid of the tagName
      tagName = 0;
    }

    pushTagsTo(elem);

    return tags;
  }

  // Create a mixin that could be globally shared across all the tags
  var mixins = {};
  var globals = mixins[GLOBAL_MIXIN] = {};
  var mixins_id = 0;

  /**
   * Create/Return a mixin by its name
   * @param   { String }  name - mixin name (global mixin if object)
   * @param   { Object }  mix - mixin logic
   * @param   { Boolean } g - is global?
   * @returns { Object }  the mixin logic
   */
  function mixin$1(name, mix, g) {
    // Unnamed global
    if (isObject(name)) {
      mixin$1("__unnamed_" + mixins_id++, name, true);
      return;
    }

    var store = g ? globals : mixins;

    // Getter
    if (!mix) {
      if (isUndefined(store[name])) {
        throw new Error('Unregistered mixin: ' + name);
      }

      return store[name];
    }

    // Setter
    store[name] = isFunction(mix) ? extend(mix.prototype, store[name] || {}) && mix : extend(store[name] || {}, mix);
  }

  /**
   * Update all the tags instances created
   * @returns { Array } all the tags instances
   */
  function update$1() {
    return each(__TAGS_CACHE, function (tag) {
      return tag.update();
    });
  }

  function unregister$1(name) {
    delete __TAG_IMPL[name];
  }

  var version$1 = 'v3.4.2';

  var core = Object.freeze({
    Tag: Tag$2,
    tag: tag$1,
    tag2: tag2$1,
    mount: mount$2,
    mixin: mixin$1,
    update: update$1,
    unregister: unregister$1,
    version: version$1
  });

  // counter to give a unique id to all the Tag instances
  var __uid = 0;

  /**
   * We need to update opts for this tag. That requires updating the expressions
   * in any attributes on the tag, and then copying the result onto opts.
   * @this Tag
   * @param   {Boolean} isLoop - is it a loop tag?
   * @param   { Tag }  parent - parent tag node
   * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)
   * @param   { Object }  opts - tag options
   * @param   { Array }  instAttrs - tag attributes array
   */
  function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {
    // isAnonymous `each` tags treat `dom` and `root` differently. In this case
    // (and only this case) we don't need to do updateOpts, because the regular parse
    // will update those attrs. Plus, isAnonymous tags don't need opts anyway
    if (isLoop && isAnonymous) {
      return;
    }

    var ctx = !isAnonymous && isLoop ? this : parent || this;
    each(instAttrs, function (attr) {
      if (attr.expr) {
        updateAllExpressions.call(ctx, [attr.expr]);
      }
      // normalize the attribute names
      opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;
    });
  }

  /**
   * Tag class
   * @constructor
   * @param { Object } impl - it contains the tag template, and logic
   * @param { Object } conf - tag options
   * @param { String } innerHTML - html that eventually we need to inject in the tag
   */
  function Tag$1(impl, conf, innerHTML) {
    if (impl === void 0) impl = {};
    if (conf === void 0) conf = {};

    var opts = extend({}, conf.opts),
        parent = conf.parent,
        isLoop = conf.isLoop,
        isAnonymous = !!conf.isAnonymous,
        skipAnonymous = settings$1.skipAnonymousTags && isAnonymous,
        item = cleanUpData(conf.item),
        index = conf.index,
        // available only for the looped nodes
    instAttrs = [],
        // All attributes on the Tag when it's first parsed
    implAttrs = [],
        // expressions on this type of Tag
    expressions = [],
        root = conf.root,
        tagName = conf.tagName || getTagName(root),
        isVirtual = tagName === 'virtual',
        propsInSyncWithParent = [],
        dom;

    // make this tag observable
    if (!skipAnonymous) {
      observable$1(this);
    }
    // only call unmount if we have a valid __TAG_IMPL (has name property)
    if (impl.name && root._tag) {
      root._tag.unmount(true);
    }

    // not yet mounted
    this.isMounted = false;

    defineProperty(this, '__', {
      isAnonymous: isAnonymous,
      instAttrs: instAttrs,
      innerHTML: innerHTML,
      tagName: tagName,
      index: index,
      isLoop: isLoop,
      // tags having event listeners
      // it would be better to use weak maps here but we can not introduce breaking changes now
      listeners: [],
      // these vars will be needed only for the virtual tags
      virts: [],
      tail: null,
      head: null,
      parent: null,
      item: null
    });

    // create a unique id to this tag
    // it could be handy to use it also to improve the virtual dom rendering speed
    defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id
    defineProperty(this, 'root', root);
    extend(this, { opts: opts }, item);
    // protect the "tags" and "refs" property from being overridden
    defineProperty(this, 'parent', parent || null);
    defineProperty(this, 'tags', {});
    defineProperty(this, 'refs', {});

    dom = isLoop && isAnonymous ? root : mkdom(impl.tmpl, innerHTML, isLoop);

    /**
     * Update the tag expressions and options
     * @param   { * }  data - data we want to use to extend the tag properties
     * @returns { Tag } the current tag instance
     */
    defineProperty(this, 'update', function tagUpdate(data) {
      var nextOpts = {},
          canTrigger = this.isMounted && !skipAnonymous;

      // make sure the data passed will not override
      // the component core methods
      data = cleanUpData(data);
      extend(this, data);
      updateOpts.apply(this, [isLoop, parent, isAnonymous, nextOpts, instAttrs]);

      if (canTrigger && this.isMounted && isFunction(this.shouldUpdate) && !this.shouldUpdate(data, nextOpts)) {
        return this;
      }

      // inherit properties from the parent, but only for isAnonymous tags
      if (isLoop && isAnonymous) {
        inheritFrom.apply(this, [this.parent, propsInSyncWithParent]);
      }
      extend(opts, nextOpts);
      if (canTrigger) {
        this.trigger('update', data);
      }
      updateAllExpressions.call(this, expressions);
      if (canTrigger) {
        this.trigger('updated');
      }

      return this;
    }.bind(this));

    /**
     * Add a mixin to this tag
     * @returns { Tag } the current tag instance
     */
    defineProperty(this, 'mixin', function tagMixin() {
      var this$1 = this;

      each(arguments, function (mix) {
        var instance, obj;
        var props = [];

        // properties blacklisted and will not be bound to the tag instance
        var propsBlacklist = ['init', '__proto__'];

        mix = isString(mix) ? mixin$1(mix) : mix;

        // check if the mixin is a function
        if (isFunction(mix)) {
          // create the new mixin instance
          instance = new mix();
        } else {
          instance = mix;
        }

        var proto = Object.getPrototypeOf(instance);

        // build multilevel prototype inheritance chain property list
        do {
          props = props.concat(Object.getOwnPropertyNames(obj || instance));
        } while (obj = Object.getPrototypeOf(obj || instance));

        // loop the keys in the function prototype or the all object keys
        each(props, function (key) {
          // bind methods to this
          // allow mixins to override other properties/parent mixins
          if (!contains(propsBlacklist, key)) {
            // check for getters/setters
            var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);
            var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);

            // apply method only if it does not already exist on the instance
            if (!this$1.hasOwnProperty(key) && hasGetterSetter) {
              Object.defineProperty(this$1, key, descriptor);
            } else {
              this$1[key] = isFunction(instance[key]) ? instance[key].bind(this$1) : instance[key];
            }
          }
        });

        // init method will be called automatically
        if (instance.init) {
          instance.init.bind(this$1)();
        }
      });
      return this;
    }.bind(this));

    /**
     * Mount the current tag instance
     * @returns { Tag } the current tag instance
     */
    defineProperty(this, 'mount', function tagMount() {
      var this$1 = this;

      root._tag = this; // keep a reference to the tag just created

      // Read all the attrs on this instance. This give us the info we need for updateOpts
      parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {
        if (!isAnonymous && RefExpr.isPrototypeOf(expr)) {
          expr.tag = this$1;
        }
        attr.expr = expr;
        instAttrs.push(attr);
      }]);

      // update the root adding custom attributes coming from the compiler
      implAttrs = [];
      walkAttrs(impl.attrs, function (k, v) {
        implAttrs.push({ name: k, value: v });
      });
      parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {
        if (expr) {
          expressions.push(expr);
        } else {
          setAttr(root, attr.name, attr.value);
        }
      }]);

      // initialiation
      updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);

      // add global mixins
      var globalMixin = mixin$1(GLOBAL_MIXIN);

      if (globalMixin && !skipAnonymous) {
        for (var i in globalMixin) {
          if (globalMixin.hasOwnProperty(i)) {
            this$1.mixin(globalMixin[i]);
          }
        }
      }

      if (impl.fn) {
        impl.fn.call(this, opts);
      }

      if (!skipAnonymous) {
        this.trigger('before-mount');
      }

      // parse layout after init. fn may calculate args for nested custom tags
      parseExpressions.apply(this, [dom, expressions, isAnonymous]);

      this.update(item);

      if (!isAnonymous) {
        while (dom.firstChild) {
          root.appendChild(dom.firstChild);
        }
      }

      defineProperty(this, 'root', root);
      defineProperty(this, 'isMounted', true);

      if (skipAnonymous) {
        return;
      }

      // if it's not a child tag we can trigger its mount event
      if (!this.parent) {
        this.trigger('mount');
      }
      // otherwise we need to wait that the parent "mount" or "updated" event gets triggered
      else {
          var p = getImmediateCustomParentTag(this.parent);
          p.one(!p.isMounted ? 'mount' : 'updated', function () {
            this$1.trigger('mount');
          });
        }

      return this;
    }.bind(this));

    /**
     * Unmount the tag instance
     * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed
     * @returns { Tag } the current tag instance
     */
    defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {
      var this$1 = this;

      var el = this.root,
          p = el.parentNode,
          ptag,
          tagIndex = __TAGS_CACHE.indexOf(this);

      if (!skipAnonymous) {
        this.trigger('before-unmount');
      }

      // clear all attributes coming from the mounted tag
      walkAttrs(impl.attrs, function (name) {
        if (startsWith(name, ATTRS_PREFIX)) {
          name = name.slice(ATTRS_PREFIX.length);
        }
        remAttr(root, name);
      });

      // remove all the event listeners
      this.__.listeners.forEach(function (dom) {
        Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {
          dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);
        });
      });

      // remove this tag instance from the global virtualDom variable
      if (tagIndex !== -1) {
        __TAGS_CACHE.splice(tagIndex, 1);
      }

      if (p || isVirtual) {
        if (parent) {
          ptag = getImmediateCustomParentTag(parent);

          if (isVirtual) {
            Object.keys(this.tags).forEach(function (tagName) {
              arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);
            });
          } else {
            arrayishRemove(ptag.tags, tagName, this);
            if (parent !== ptag) // remove from _parent too
              {
                arrayishRemove(parent.tags, tagName, this);
              }
          }
        } else {
          // remove the tag contents
          setInnerHTML(el, '');
        }

        if (p && !mustKeepRoot) {
          p.removeChild(el);
        }
      }

      if (this.__.virts) {
        each(this.__.virts, function (v) {
          if (v.parentNode) {
            v.parentNode.removeChild(v);
          }
        });
      }

      // allow expressions to unmount themselves
      unmountAll(expressions);
      each(instAttrs, function (a) {
        return a.expr && a.expr.unmount && a.expr.unmount();
      });

      // custom internal unmount function to avoid relying on the observable
      if (this.__.onUnmount) {
        this.__.onUnmount();
      }

      if (!skipAnonymous) {
        this.trigger('unmount');
        this.off('*');
      }

      defineProperty(this, 'isMounted', false);

      delete this.root._tag;

      return this;
    }.bind(this));
  }

  /**
   * Detect the tag implementation by a DOM node
   * @param   { Object } dom - DOM node we need to parse to get its tag implementation
   * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)
   */
  function getTag(dom) {
    return dom.tagName && __TAG_IMPL[getAttr(dom, IS_DIRECTIVE) || getAttr(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()];
  }

  /**
   * Inherit properties from a target tag instance
   * @this Tag
   * @param   { Tag } target - tag where we will inherit properties
   * @param   { Array } propsInSyncWithParent - array of properties to sync with the target
   */
  function inheritFrom(target, propsInSyncWithParent) {
    var this$1 = this;

    each(Object.keys(target), function (k) {
      // some properties must be always in sync with the parent tag
      var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);

      if (isUndefined(this$1[k]) || mustSync) {
        // track the property to keep in sync
        // so we can keep it updated
        if (!mustSync) {
          propsInSyncWithParent.push(k);
        }
        this$1[k] = target[k];
      }
    });
  }

  /**
   * Move the position of a custom tag in its parent tag
   * @this Tag
   * @param   { String } tagName - key where the tag was stored
   * @param   { Number } newPos - index where the new tag will be stored
   */
  function moveChildTag(tagName, newPos) {
    var parent = this.parent,
        tags;
    // no parent no move
    if (!parent) {
      return;
    }

    tags = parent.tags[tagName];

    if (isArray(tags)) {
      tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]);
    } else {
      arrayishAdd(parent.tags, tagName, this);
    }
  }

  /**
   * Create a new child tag including it correctly into its parent
   * @param   { Object } child - child tag implementation
   * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted
   * @param   { String } innerHTML - inner html of the child node
   * @param   { Object } parent - instance of the parent tag including the child custom tag
   * @returns { Object } instance of the new child tag just created
   */
  function initChildTag(child, opts, innerHTML, parent) {
    var tag = new Tag$1(child, opts, innerHTML),
        tagName = opts.tagName || getTagName(opts.root, true),
        ptag = getImmediateCustomParentTag(parent);
    // fix for the parent attribute in the looped elements
    defineProperty(tag, 'parent', ptag);
    // store the real parent tag
    // in some cases this could be different from the custom parent tag
    // for example in nested loops
    tag.__.parent = parent;

    // add this tag to the custom parent tag
    arrayishAdd(ptag.tags, tagName, tag);

    // and also to the real parent tag
    if (ptag !== parent) {
      arrayishAdd(parent.tags, tagName, tag);
    }

    // empty the child node once we got its template
    // to avoid that its children get compiled multiple times
    opts.root.innerHTML = '';

    return tag;
  }

  /**
   * Loop backward all the parents tree to detect the first custom parent tag
   * @param   { Object } tag - a Tag instance
   * @returns { Object } the instance of the first custom parent tag found
   */
  function getImmediateCustomParentTag(tag) {
    var ptag = tag;
    while (ptag.__.isAnonymous) {
      if (!ptag.parent) {
        break;
      }
      ptag = ptag.parent;
    }
    return ptag;
  }

  /**
   * Trigger the unmount method on all the expressions
   * @param   { Array } expressions - DOM expressions
   */
  function unmountAll(expressions) {
    each(expressions, function (expr) {
      if (expr instanceof Tag$1) {
        expr.unmount(true);
      } else if (expr.tagName) {
        expr.tag.unmount(true);
      } else if (expr.unmount) {
        expr.unmount();
      }
    });
  }

  /**
   * Get the tag name of any DOM node
   * @param   { Object } dom - DOM node we want to parse
   * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent
   * @returns { String } name to identify this dom node in riot
   */
  function getTagName(dom, skipDataIs) {
    var child = getTag(dom),
        namedTag = !skipDataIs && getAttr(dom, IS_DIRECTIVE);
    return namedTag && !tmpl.hasExpr(namedTag) ? namedTag : child ? child.name : dom.tagName.toLowerCase();
  }

  /**
   * With this function we avoid that the internal Tag methods get overridden
   * @param   { Object } data - options we want to use to extend the tag instance
   * @returns { Object } clean object without containing the riot internal reserved words
   */
  function cleanUpData(data) {
    if (!(data instanceof Tag$1) && !(data && isFunction(data.trigger))) {
      return data;
    }

    var o = {};
    for (var key in data) {
      if (!RE_RESERVED_NAMES.test(key)) {
        o[key] = data[key];
      }
    }
    return o;
  }

  /**
   * Set the property of an object for a given key. If something already
   * exists there, then it becomes an array containing both the old and new value.
   * @param { Object } obj - object on which to set the property
   * @param { String } key - property name
   * @param { Object } value - the value of the property to be set
   * @param { Boolean } ensureArray - ensure that the property remains an array
   * @param { Number } index - add the new item in a certain array position
   */
  function arrayishAdd(obj, key, value, ensureArray, index) {
    var dest = obj[key];
    var isArr = isArray(dest);
    var hasIndex = !isUndefined(index);

    if (dest && dest === value) {
      return;
    }

    // if the key was never set, set it once
    if (!dest && ensureArray) {
      obj[key] = [value];
    } else if (!dest) {
      obj[key] = value;
    }
    // if it was an array and not yet set
    else {
        if (isArr) {
          var oldIndex = dest.indexOf(value);
          // this item never changed its position
          if (oldIndex === index) {
            return;
          }
          // remove the item from its old position
          if (oldIndex !== -1) {
            dest.splice(oldIndex, 1);
          }
          // move or add the item
          if (hasIndex) {
            dest.splice(index, 0, value);
          } else {
            dest.push(value);
          }
        } else {
          obj[key] = [dest, value];
        }
      }
  }

  /**
   * Removes an item from an object at a given key. If the key points to an array,
   * then the item is just removed from the array.
   * @param { Object } obj - object on which to remove the property
   * @param { String } key - property name
   * @param { Object } value - the value of the property to be removed
   * @param { Boolean } ensureArray - ensure that the property remains an array
  */
  function arrayishRemove(obj, key, value, ensureArray) {
    if (isArray(obj[key])) {
      var index = obj[key].indexOf(value);
      if (index !== -1) {
        obj[key].splice(index, 1);
      }
      if (!obj[key].length) {
        delete obj[key];
      } else if (obj[key].length === 1 && !ensureArray) {
        obj[key] = obj[key][0];
      }
    } else {
      delete obj[key];
    } // otherwise just delete the key
  }

  /**
   * Mount a tag creating new Tag instance
   * @param   { Object } root - dom node where the tag will be mounted
   * @param   { String } tagName - name of the riot tag we want to mount
   * @param   { Object } opts - options to pass to the Tag instance
   * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )
   * @returns { Tag } a new Tag instance
   */
  function mountTo(root, tagName, opts, ctx) {
    var impl = __TAG_IMPL[tagName],
        implClass = __TAG_IMPL[tagName].class,
        tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),

    // cache the inner HTML to fix #855
    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;

    // clear the inner html
    root.innerHTML = '';

    var conf = extend({ root: root, opts: opts }, { parent: opts ? opts.parent : null });

    if (impl && root) {
      Tag$1.apply(tag, [impl, conf, innerHTML]);
    }

    if (tag && tag.mount) {
      tag.mount(true);
      // add this tag to the virtualDom variable
      if (!contains(__TAGS_CACHE, tag)) {
        __TAGS_CACHE.push(tag);
      }
    }

    return tag;
  }

  /**
   * makes a tag virtual and replaces a reference in the dom
   * @this Tag
   * @param { tag } the tag to make virtual
   * @param { ref } the dom reference location
   */
  function makeReplaceVirtual(tag, ref) {
    var frag = createFrag();
    makeVirtual.call(tag, frag);
    ref.parentNode.replaceChild(frag, ref);
  }

  /**
   * Adds the elements for a virtual tag
   * @this Tag
   * @param { Node } src - the node that will do the inserting or appending
   * @param { Tag } target - only if inserting, insert before this tag's first child
   */
  function makeVirtual(src, target) {
    var this$1 = this;

    var head = createDOMPlaceholder(),
        tail = createDOMPlaceholder(),
        frag = createFrag(),
        sib,
        el;

    this.root.insertBefore(head, this.root.firstChild);
    this.root.appendChild(tail);

    this.__.head = el = head;
    this.__.tail = tail;

    while (el) {
      sib = el.nextSibling;
      frag.appendChild(el);
      this$1.__.virts.push(el); // hold for unmounting
      el = sib;
    }

    if (target) {
      src.insertBefore(frag, target.__.head);
    } else {
      src.appendChild(frag);
    }
  }

  /**
   * Move virtual tag and all child nodes
   * @this Tag
   * @param { Node } src  - the node that will do the inserting
   * @param { Tag } target - insert before this tag's first child
   */
  function moveVirtual(src, target) {
    var this$1 = this;

    var el = this.__.head,
        frag = createFrag(),
        sib;

    while (el) {
      sib = el.nextSibling;
      frag.appendChild(el);
      el = sib;
      if (el === this$1.__.tail) {
        frag.appendChild(el);
        src.insertBefore(frag, target.__.head);
        break;
      }
    }
  }

  /**
   * Get selectors for tags
   * @param   { Array } tags - tag names to select
   * @returns { String } selector
   */
  function selectTags(tags) {
    // select all tags
    if (!tags) {
      var keys = Object.keys(__TAG_IMPL);
      return keys + selectTags(keys);
    }

    return tags.filter(function (t) {
      return !/[^-\w]/.test(t);
    }).reduce(function (list, t) {
      var name = t.trim().toLowerCase();
      return list + ",[" + IS_DIRECTIVE + "=\"" + name + "\"]";
    }, '');
  }

  var tags = Object.freeze({
    getTag: getTag,
    inheritFrom: inheritFrom,
    moveChildTag: moveChildTag,
    initChildTag: initChildTag,
    getImmediateCustomParentTag: getImmediateCustomParentTag,
    unmountAll: unmountAll,
    getTagName: getTagName,
    cleanUpData: cleanUpData,
    arrayishAdd: arrayishAdd,
    arrayishRemove: arrayishRemove,
    mountTo: mountTo,
    makeReplaceVirtual: makeReplaceVirtual,
    makeVirtual: makeVirtual,
    moveVirtual: moveVirtual,
    selectTags: selectTags
  });

  /**
   * Riot public api
   */
  var settings = settings$1;
  var util = {
    tmpl: tmpl,
    brackets: brackets,
    styleManager: styleManager,
    vdom: __TAGS_CACHE,
    styleNode: styleManager.styleNode,
    // export the riot internal utils as well
    dom: dom,
    check: check,
    misc: misc,
    tags: tags
  };

  // export the core props/methods
  var Tag$$1 = Tag$2;
  var tag$$1 = tag$1;
  var tag2$$1 = tag2$1;
  var mount$1 = mount$2;
  var mixin$$1 = mixin$1;
  var update$$1 = update$1;
  var unregister$$1 = unregister$1;
  var version$$1 = version$1;
  var observable = observable$1;

  var riot$1 = extend({}, core, {
    observable: observable$1,
    settings: settings,
    util: util
  });

  var riot$2 = Object.freeze({
    settings: settings,
    util: util,
    Tag: Tag$$1,
    tag: tag$$1,
    tag2: tag2$$1,
    mount: mount$1,
    mixin: mixin$$1,
    update: update$$1,
    unregister: unregister$$1,
    version: version$$1,
    observable: observable,
    default: riot$1
  });

  /**
   * Compiler for riot custom tags
   * @version v3.2.1
   */

  // istanbul ignore next
  function safeRegex(re) {
    var arguments$1 = arguments;

    var src = re.source;
    var opt = re.global ? 'g' : '';

    if (re.ignoreCase) {
      opt += 'i';
    }
    if (re.multiline) {
      opt += 'm';
    }

    for (var i = 1; i < arguments.length; i++) {
      src = src.replace('@', '\\' + arguments$1[i]);
    }

    return new RegExp(src, opt);
  }

  /**
   * @module parsers
   */
  var parsers$1 = function (win) {

    var _p = {};

    function _r(name) {
      var parser = win[name];

      if (parser) {
        return parser;
      }

      throw new Error('Parser "' + name + '" not loaded.');
    }

    function _req(name) {
      var parts = name.split('.');

      if (parts.length !== 2) {
        throw new Error('Bad format for parsers._req');
      }

      var parser = _p[parts[0]][parts[1]];
      if (parser) {
        return parser;
      }

      throw new Error('Parser "' + name + '" not found.');
    }

    function extend(obj, props) {
      if (props) {
        for (var prop in props) {
          /* istanbul ignore next */
          if (props.hasOwnProperty(prop)) {
            obj[prop] = props[prop];
          }
        }
      }
      return obj;
    }

    function renderPug(compilerName, html, opts, url) {
      opts = extend({
        pretty: true,
        filename: url,
        doctype: 'html'
      }, opts);
      return _r(compilerName).render(html, opts);
    }

    _p.html = {
      jade: function (html, opts, url) {
        /* eslint-disable */
        console.log('DEPRECATION WARNING: jade was renamed "pug" - The jade parser will be removed in riot@3.0.0!');
        /* eslint-enable */
        return renderPug('jade', html, opts, url);
      },
      pug: function (html, opts, url) {
        return renderPug('pug', html, opts, url);
      }
    };
    _p.css = {
      less: function (tag, css, opts, url) {
        var ret;

        opts = extend({
          sync: true,
          syncImport: true,
          filename: url
        }, opts);
        _r('less').render(css, opts, function (err, result) {
          // istanbul ignore next
          if (err) {
            throw err;
          }
          ret = result.css;
        });
        return ret;
      }
    };
    _p.js = {

      es6: function (js, opts, url) {
        return _r('Babel').transform( // eslint-disable-line
        js, extend({
          plugins: [['transform-es2015-template-literals', { loose: true }], 'transform-es2015-literals', 'transform-es2015-function-name', 'transform-es2015-arrow-functions', 'transform-es2015-block-scoped-functions', ['transform-es2015-classes', { loose: true }], 'transform-es2015-object-super', 'transform-es2015-shorthand-properties', 'transform-es2015-duplicate-keys', ['transform-es2015-computed-properties', { loose: true }], ['transform-es2015-for-of', { loose: true }], 'transform-es2015-sticky-regex', 'transform-es2015-unicode-regex', 'check-es2015-constants', ['transform-es2015-spread', { loose: true }], 'transform-es2015-parameters', ['transform-es2015-destructuring', { loose: true }], 'transform-es2015-block-scoping', 'transform-es2015-typeof-symbol', ['transform-es2015-modules-commonjs', { allowTopLevelThis: true }], ['transform-regenerator', { async: false, asyncGenerators: false }]]
        }, opts)).code;
      },
      buble: function (js, opts, url) {
        opts = extend({
          source: url,
          modules: false
        }, opts);
        return _r('buble').transform(js, opts).code;
      },
      coffee: function (js, opts) {
        return _r('CoffeeScript').compile(js, extend({ bare: true }, opts));
      },
      livescript: function (js, opts) {
        return _r('livescript').compile(js, extend({ bare: true, header: false }, opts));
      },
      typescript: function (js, opts) {
        return _r('typescript')(js, opts);
      },
      none: function (js) {
        return js;
      }
    };
    _p.js.javascript = _p.js.none;
    _p.js.coffeescript = _p.js.coffee;
    _p._req = _req;
    _p.utils = {
      extend: extend
    };

    return _p;
  }(window || commonjsGlobal);

  /**
   * @module compiler
   */

  var extend$1 = parsers$1.utils.extend;
  /* eslint-enable */

  var S_LINESTR = /"[^"\n\\]*(?:\\[\S\s][^"\n\\]*)*"|'[^'\n\\]*(?:\\[\S\s][^'\n\\]*)*'/.source;

  var S_STRINGS = brackets.R_STRINGS.source;

  var HTML_ATTRS = / *([-\w:\xA0-\xFF]+) ?(?:= ?('[^']*'|"[^"]*"|\S+))?/g;

  var HTML_COMMS = RegExp(/<!--(?!>)[\S\s]*?-->/.source + '|' + S_LINESTR, 'g');

  var HTML_TAGS = /<(-?[A-Za-z][-\w\xA0-\xFF]*)(?:\s+([^"'\/>]*(?:(?:"[^"]*"|'[^']*'|\/[^>])[^'"\/>]*)*)|\s*)(\/?)>/g;

  var HTML_PACK = />[ \t]+<(-?[A-Za-z]|\/[-A-Za-z])/g;

  var RIOT_ATTRS = ['style', 'src', 'd', 'value'];

  var VOID_TAGS = /^(?:input|img|br|wbr|hr|area|base|col|embed|keygen|link|meta|param|source|track)$/;

  var PRE_TAGS = /<pre(?:\s+(?:[^">]*|"[^"]*")*)?>([\S\s]+?)<\/pre\s*>/gi;

  var SPEC_TYPES = /^"(?:number|date(?:time)?|time|month|email|color)\b/i;

  var IMPORT_STATEMENT = /^\s*import(?!\w)(?:(?:\s|[^\s'"])*)['|"].*\n?/gm;

  var TRIM_TRAIL = /[ \t]+$/gm;

  var RE_HASEXPR = safeRegex(/@#\d/, 'x01');
  var RE_REPEXPR = safeRegex(/@#(\d+)/g, 'x01');
  var CH_IDEXPR = '\x01#';
  var CH_DQCODE = '\u2057';
  var DQ = '"';
  var SQ = "'";

  function cleanSource(src) {
    var mm,
        re = HTML_COMMS;

    if (~src.indexOf('\r')) {
      src = src.replace(/\r\n?/g, '\n');
    }

    re.lastIndex = 0;
    while (mm = re.exec(src)) {
      if (mm[0][0] === '<') {
        src = RegExp.leftContext + RegExp.rightContext;
        re.lastIndex = mm[3] + 1;
      }
    }
    return src;
  }

  function parseAttribs(str, pcex) {
    var list = [],
        match,
        type,
        vexp;

    HTML_ATTRS.lastIndex = 0;

    str = str.replace(/\s+/g, ' ');

    while (match = HTML_ATTRS.exec(str)) {
      var k = match[1].toLowerCase(),
          v = match[2];

      if (!v) {
        list.push(k);
      } else {

        if (v[0] !== DQ) {
          v = DQ + (v[0] === SQ ? v.slice(1, -1) : v) + DQ;
        }

        if (k === 'type' && SPEC_TYPES.test(v)) {
          type = v;
        } else {
          if (RE_HASEXPR.test(v)) {

            if (k === 'value') {
              vexp = 1;
            }
            if (~RIOT_ATTRS.indexOf(k)) {
              k = 'riot-' + k;
            }
          }

          list.push(k + '=' + v);
        }
      }
    }

    if (type) {
      if (vexp) {
        type = DQ + pcex._bp[0] + SQ + type.slice(1, -1) + SQ + pcex._bp[1] + DQ;
      }
      list.push('type=' + type);
    }
    return list.join(' ');
  }

  function splitHtml(html, opts, pcex) {
    var _bp = pcex._bp;

    if (html && _bp[4].test(html)) {
      var jsfn = opts.expr && (opts.parser || opts.type) ? _compileJS : 0,
          list = brackets.split(html, 0, _bp),
          expr;

      for (var i = 1; i < list.length; i += 2) {
        expr = list[i];
        if (expr[0] === '^') {
          expr = expr.slice(1);
        } else if (jsfn) {
          expr = jsfn(expr, opts).trim();
          if (expr.slice(-1) === ';') {
            expr = expr.slice(0, -1);
          }
        }
        list[i] = CH_IDEXPR + (pcex.push(expr) - 1) + _bp[1];
      }
      html = list.join('');
    }
    return html;
  }

  function restoreExpr(html, pcex) {
    if (pcex.length) {
      html = html.replace(RE_REPEXPR, function (_, d) {

        return pcex._bp[0] + pcex[d].trim().replace(/[\r\n]+/g, ' ').replace(/"/g, CH_DQCODE);
      });
    }
    return html;
  }

  function _compileHTML(html, opts, pcex) {
    if (!/\S/.test(html)) {
      return '';
    }

    html = splitHtml(html, opts, pcex).replace(HTML_TAGS, function (_, name, attr, ends) {

      name = name.toLowerCase();

      ends = ends && !VOID_TAGS.test(name) ? '></' + name : '';

      if (attr) {
        name += ' ' + parseAttribs(attr, pcex);
      }

      return '<' + name + ends + '>';
    });

    if (!opts.whitespace) {
      var p = [];

      if (/<pre[\s>]/.test(html)) {
        html = html.replace(PRE_TAGS, function (q) {
          p.push(q);
          return '\u0002';
        });
      }

      html = html.trim().replace(/\s+/g, ' ');

      if (p.length) {
        html = html.replace(/\u0002/g, function () {
          return p.shift();
        });
      }
    }

    if (opts.compact) {
      html = html.replace(HTML_PACK, '><$1');
    }

    return restoreExpr(html, pcex).replace(TRIM_TRAIL, '');
  }

  function compileHTML(html, opts, pcex) {

    if (Array.isArray(opts)) {
      pcex = opts;
      opts = {};
    } else {
      if (!pcex) {
        pcex = [];
      }
      if (!opts) {
        opts = {};
      }
    }

    pcex._bp = brackets.array(opts.brackets);

    return _compileHTML(cleanSource(html), opts, pcex);
  }

  var JS_ES6SIGN = /^[ \t]*(((?:async|\*)\s*)?([$_A-Za-z][$\w]*))\s*\([^()]*\)\s*{/m;

  var JS_ES6END = RegExp('[{}]|' + brackets.S_QBLOCKS, 'g');

  var JS_COMMS = RegExp(brackets.R_MLCOMMS.source + '|//[^\r\n]*|' + brackets.S_QBLOCKS, 'g');

  function riotjs(js) {
    var parts = [],
        match,
        toes5,
        pos,
        method,
        prefix,
        name,
        RE = RegExp;

    if (~js.indexOf('/')) {
      js = rmComms(js, JS_COMMS);
    }

    while (match = js.match(JS_ES6SIGN)) {

      parts.push(RE.leftContext);
      js = RE.rightContext;
      pos = skipBody(js, JS_ES6END);

      method = match[1];
      prefix = match[2] || '';
      name = match[3];

      toes5 = !/^(?:if|while|for|switch|catch|function)$/.test(name);

      if (toes5) {
        name = match[0].replace(method, 'this.' + name + ' =' + prefix + ' function');
      } else {
        name = match[0];
      }

      parts.push(name, js.slice(0, pos));
      js = js.slice(pos);

      if (toes5 && !/^\s*.\s*bind\b/.test(js)) {
        parts.push('.bind(this)');
      }
    }

    return parts.length ? parts.join('') + js : js;

    function rmComms(s, r, m) {
      r.lastIndex = 0;
      while (m = r.exec(s)) {
        if (m[0][0] === '/' && !m[1] && !m[2]) {
          s = RE.leftContext + ' ' + RE.rightContext;
          r.lastIndex = m[3] + 1;
        }
      }
      return s;
    }

    function skipBody(s, r) {
      var m,
          i = 1;

      r.lastIndex = 0;
      while (i && (m = r.exec(s))) {
        if (m[0] === '{') {
          ++i;
        } else if (m[0] === '}') {
          --i;
        }
      }
      return i ? s.length : r.lastIndex;
    }
  }

  function _compileJS(js, opts, type, parserOpts, url) {
    if (!/\S/.test(js)) {
      return '';
    }
    if (!type) {
      type = opts.type;
    }

    var parser = opts.parser || type && parsers$1._req('js.' + type, true) || riotjs;

    return parser(js, parserOpts, url).replace(/\r\n?/g, '\n').replace(TRIM_TRAIL, '');
  }

  function compileJS(js, opts, type, userOpts) {
    if (typeof opts === 'string') {
      userOpts = type;
      type = opts;
      opts = {};
    }
    if (type && typeof type === 'object') {
      userOpts = type;
      type = '';
    }
    if (!userOpts) {
      userOpts = {};
    }

    return _compileJS(js, opts || {}, type, userOpts.parserOptions, userOpts.url);
  }

  var CSS_SELECTOR = RegExp('([{}]|^)[; ]*((?:[^@ ;{}][^{}]*)?[^@ ;{}:] ?)(?={)|' + S_LINESTR, 'g');

  function scopedCSS(tag, css) {
    var scope = ':scope';

    return css.replace(CSS_SELECTOR, function (m, p1, p2) {

      if (!p2) {
        return m;
      }

      p2 = p2.replace(/[^,]+/g, function (sel) {
        var s = sel.trim();

        if (s.indexOf(tag) === 0) {
          return sel;
        }

        if (!s || s === 'from' || s === 'to' || s.slice(-1) === '%') {
          return sel;
        }

        if (s.indexOf(scope) < 0) {
          s = tag + ' ' + s + ',[data-is="' + tag + '"] ' + s;
        } else {
          s = s.replace(scope, tag) + ',' + s.replace(scope, '[data-is="' + tag + '"]');
        }
        return s;
      });

      return p1 ? p1 + ' ' + p2 : p2;
    });
  }

  function _compileCSS(css, tag, type, opts) {
    opts = opts || {};

    if (type) {
      if (type !== 'css') {

        var parser = parsers$1._req('css.' + type, true);
        css = parser(tag, css, opts.parserOpts || {}, opts.url);
      }
    }

    css = css.replace(brackets.R_MLCOMMS, '').replace(/\s+/g, ' ').trim();
    if (tag) {
      css = scopedCSS(tag, css);
    }

    return css;
  }

  function compileCSS(css, type, opts) {
    if (type && typeof type === 'object') {
      opts = type;
      type = '';
    } else if (!opts) {
      opts = {};
    }

    return _compileCSS(css, opts.tagName, type, opts);
  }

  var TYPE_ATTR = /\stype\s*=\s*(?:(['"])(.+?)\1|(\S+))/i;

  var MISC_ATTR = '\\s*=\\s*(' + S_STRINGS + '|{[^}]+}|\\S+)';

  var END_TAGS = /\/>\n|^<(?:\/?-?[A-Za-z][-\w\xA0-\xFF]*\s*|-?[A-Za-z][-\w\xA0-\xFF]*\s+[-\w:\xA0-\xFF][\S\s]*?)>\n/;

  function _q(s, r) {
    if (!s) {
      return "''";
    }
    s = SQ + s.replace(/\\/g, '\\\\').replace(/'/g, "\\'") + SQ;
    return r && ~s.indexOf('\n') ? s.replace(/\n/g, '\\n') : s;
  }

  function mktag(name, html, css, attr, js, imports, opts) {
    var c = opts.debug ? ',\n  ' : ', ',
        s = '});';

    if (js && js.slice(-1) !== '\n') {
      s = '\n' + s;
    }

    return imports + 'riot.tag2(\'' + name + SQ + c + _q(html, 1) + c + _q(css) + c + _q(attr) + ', function(opts) {\n' + js + s;
  }

  function splitBlocks(str) {
    if (/<[-\w]/.test(str)) {
      var m,
          k = str.lastIndexOf('<'),
          n = str.length;

      while (~k) {
        m = str.slice(k, n).match(END_TAGS);
        if (m) {
          k += m.index + m[0].length;
          m = str.slice(0, k);
          if (m.slice(-5) === '<-/>\n') {
            m = m.slice(0, -5);
          }
          return [m, str.slice(k)];
        }
        n = k;
        k = str.lastIndexOf('<', k - 1);
      }
    }
    return ['', str];
  }

  function getType(attribs) {
    if (attribs) {
      var match = attribs.match(TYPE_ATTR);

      match = match && (match[2] || match[3]);
      if (match) {
        return match.replace('text/', '');
      }
    }
    return '';
  }

  function getAttrib(attribs, name) {
    if (attribs) {
      var match = attribs.match(RegExp('\\s' + name + MISC_ATTR, 'i'));

      match = match && match[1];
      if (match) {
        return (/^['"]/.test(match) ? match.slice(1, -1) : match
        );
      }
    }
    return '';
  }

  function unescapeHTML(str) {
    return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#039;/g, '\'');
  }

  function getParserOptions(attribs) {
    var opts = unescapeHTML(getAttrib(attribs, 'options'));

    return opts ? JSON.parse(opts) : null;
  }

  function getCode(code, opts, attribs, base) {
    var type = getType(attribs),
        src = getAttrib(attribs, 'src'),
        jsParserOptions = extend$1({}, opts.parserOptions.js);

    if (src) {
      return false;
    }

    return _compileJS(code, opts, type, extend$1(jsParserOptions, getParserOptions(attribs)), base);
  }

  function cssCode(code, opts, attribs, url, tag) {
    var parserStyleOptions = extend$1({}, opts.parserOptions.style),
        extraOpts = {
      parserOpts: extend$1(parserStyleOptions, getParserOptions(attribs)),
      url: url
    };

    return _compileCSS(code, tag, getType(attribs) || opts.style, extraOpts);
  }

  function compileTemplate(html, url, lang, opts) {

    var parser = parsers$1._req('html.' + lang, true);
    return parser(html, opts, url);
  }

  var CUST_TAG = RegExp(/^([ \t]*)<(-?[A-Za-z][-\w\xA0-\xFF]*)(?:\s+([^'"\/>]+(?:(?:@|\/[^>])[^'"\/>]*)*)|\s*)?(?:\/>|>[ \t]*\n?([\S\s]*)^\1<\/\2\s*>|>(.*)<\/\2\s*>)/.source.replace('@', S_STRINGS), 'gim');
  var SCRIPTS = /<script(\s+[^>]*)?>\n?([\S\s]*?)<\/script\s*>/gi;
  var STYLES = /<style(\s+[^>]*)?>\n?([\S\s]*?)<\/style\s*>/gi;

  function compile$1(src, opts, url) {
    var parts = [],
        included,
        defaultParserptions = {

      template: {},
      js: {},
      style: {}
    };

    if (!opts) {
      opts = {};
    }

    opts.parserOptions = extend$1(defaultParserptions, opts.parserOptions || {});

    included = opts.exclude ? function (s) {
      return opts.exclude.indexOf(s) < 0;
    } : function () {
      return 1;
    };

    if (!url) {
      url = '';
    }

    var _bp = brackets.array(opts.brackets);

    if (opts.template) {
      src = compileTemplate(src, url, opts.template, opts.parserOptions.template);
    }

    src = cleanSource(src).replace(CUST_TAG, function (_, indent, tagName, attribs, body, body2) {
      var jscode = '',
          styles = '',
          html = '',
          imports = '',
          pcex = [];

      pcex._bp = _bp;

      tagName = tagName.toLowerCase();

      attribs = attribs && included('attribs') ? restoreExpr(parseAttribs(splitHtml(attribs, opts, pcex), pcex), pcex) : '';

      if ((body || (body = body2)) && /\S/.test(body)) {

        if (body2) {

          if (included('html')) {
            html = _compileHTML(body2, opts, pcex);
          }
        } else {

          body = body.replace(RegExp('^' + indent, 'gm'), '');

          body = body.replace(SCRIPTS, function (_m, _attrs, _script) {
            if (included('js')) {
              var code = getCode(_script, opts, _attrs, url);

              if (code) {
                jscode += (jscode ? '\n' : '') + code;
              }
            }
            return '';
          });

          body = body.replace(STYLES, function (_m, _attrs, _style) {
            if (included('css')) {
              styles += (styles ? ' ' : '') + cssCode(_style, opts, _attrs, url, tagName);
            }
            return '';
          });

          var blocks = splitBlocks(body.replace(TRIM_TRAIL, ''));

          if (included('html')) {
            html = _compileHTML(blocks[0], opts, pcex);
          }

          if (included('js')) {
            body = _compileJS(blocks[1], opts, null, null, url);
            if (body) {
              jscode += (jscode ? '\n' : '') + body;
            }
            jscode = jscode.replace(IMPORT_STATEMENT, function (s) {
              imports += s.trim() + '\n';
              return '';
            });
          }
        }
      }

      jscode = /\S/.test(jscode) ? jscode.replace(/\n{3,}/g, '\n\n') : '';

      if (opts.entities) {
        parts.push({
          tagName: tagName,
          html: html,
          css: styles,
          attribs: attribs,
          js: jscode,
          imports: imports
        });
        return '';
      }

      return mktag(tagName, html, styles, attribs, jscode, imports, opts);
    });

    if (opts.entities) {
      return parts;
    }

    return src;
  }

  var version$2 = 'v3.2.1';

  var compiler = {
    compile: compile$1,
    compileHTML: compileHTML,
    compileCSS: compileCSS,
    compileJS: compileJS,
    parsers: parsers$1,
    version: version$2
  };

  var promise;
  var ready; // all the scripts were compiled?

  // gets the source of an external tag with an async call
  function GET(url, fn, opts) {
    var req = new XMLHttpRequest();

    req.onreadystatechange = function () {
      if (req.readyState === 4 && (req.status === 200 || !req.status && req.responseText.length)) {
        fn(req.responseText, opts, url);
      }
    };
    req.open('GET', url, true);
    req.send('');
  }

  // evaluates a compiled tag within the global context
  function globalEval(js, url) {
    if (typeof js === T_STRING) {
      var node = mkEl('script'),
          root = document.documentElement;

      // make the source available in the "(no domain)" tab
      // of Chrome DevTools, with a .js extension
      if (url) {
        js += '\n//# sourceURL=' + url + '.js';
      }

      node.text = js;
      root.appendChild(node);
      root.removeChild(node);
    }
  }

  // compiles all the internal and external tags on the page
  function compileScripts(fn, xopt) {
    var scripts = $$('script[type="riot/tag"]'),
        scriptsAmount = scripts.length;

    function done() {
      promise.trigger('ready');
      ready = true;
      if (fn) {
        fn();
      }
    }

    function compileTag(src, opts, url) {
      var code = compiler.compile(src, opts, url);

      globalEval(code, url);
      if (! --scriptsAmount) {
        done();
      }
    }

    if (!scriptsAmount) {
      done();
    } else {
      for (var i = 0; i < scripts.length; ++i) {
        var script = scripts[i],
            opts = extend({ template: getAttr(script, 'template') }, xopt),
            url = getAttr(script, 'src') || getAttr(script, 'data-src');

        url ? GET(url, compileTag, opts) : compileTag(script.innerHTML, opts);
      }
    }
  }

  var parsers = compiler.parsers;

  /*
    Compilation for the browser
  */
  var compile = function (arg, fn, opts) {

    if (typeof arg === T_STRING) {

      // 2nd parameter is optional, but can be null
      if (isObject(fn)) {
        opts = fn;
        fn = false;
      }

      // `riot.compile(tag [, callback | true][, options])`
      if (/^\s*</m.test(arg)) {
        var js = compiler.compile(arg, opts);
        if (fn !== true) {
          globalEval(js);
        }
        if (isFunction(fn)) {
          fn(js, arg, opts);
        }
        return js;
      }

      // `riot.compile(url [, callback][, options])`
      GET(arg, function (str, opts, url) {
        var js = compiler.compile(str, opts, url);
        globalEval(js, url);
        if (fn) {
          fn(js, str, opts);
        }
      }, opts);
    } else if (isArray(arg)) {
      var i = arg.length;
      // `riot.compile([urlsList] [, callback][, options])`
      arg.forEach(function (str) {
        GET(str, function (str, opts, url) {
          var js = compiler.compile(str, opts, url);
          globalEval(js, url);
          i--;
          if (!i && fn) {
            fn(js, str, opts);
          }
        }, opts);
      });
    } else {

      // `riot.compile([callback][, options])`
      if (isFunction(arg)) {
        opts = fn;
        fn = arg;
      } else {
        opts = arg;
        fn = undefined;
      }

      if (ready) {
        return fn && fn();
      }

      if (promise) {
        if (fn) {
          promise.on('ready', fn);
        }
      } else {
        promise = observable$1();
        compileScripts(fn, opts);
      }
    }
  };

  function mount$$1() {
    var args = [],
        len = arguments.length;
    while (len--) args[len] = arguments[len];

    var ret;
    compile(function () {
      ret = mount$1.apply(riot$2, args);
    });
    return ret;
  }

  var riot_compiler = extend({}, riot$2, {
    mount: mount$$1,
    compile: compile,
    parsers: parsers
  });

  return riot_compiler;
});
});

/**
 * The riot template engine
 * @version v3.0.3
 */
/**
 * riot.util.brackets
 *
 * - `brackets    ` - Returns a string or regex based on its parameter
 * - `brackets.set` - Change the current riot brackets
 *
 * @module
 */

/* global riot */

var brackets = function (UNDEF) {

  var REGLOB = 'g',
      R_MLCOMMS = /\/\*[^*]*\*+(?:[^*\/][^*]*\*+)*\//g,
      R_STRINGS = /"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'|`[^`\\]*(?:\\[\S\s][^`\\]*)*`/g,
      S_QBLOCKS = R_STRINGS.source + '|' + /(?:\breturn\s+|(?:[$\w\)\]]|\+\+|--)\s*(\/)(?![*\/]))/.source + '|' + /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?(\/)[gim]*/.source,
      UNSUPPORTED = RegExp('[\\' + 'x00-\\x1F<>a-zA-Z0-9\'",;\\\\]'),
      NEED_ESCAPE = /(?=[[\]()*+?.^$|])/g,
      FINDBRACES = {
    '(': RegExp('([()])|' + S_QBLOCKS, REGLOB),
    '[': RegExp('([[\\]])|' + S_QBLOCKS, REGLOB),
    '{': RegExp('([{}])|' + S_QBLOCKS, REGLOB)
  },
      DEFAULT = '{ }';

  var _pairs = ['{', '}', '{', '}', /{[^}]*}/, /\\([{}])/g, /\\({)|{/g, RegExp('\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB), DEFAULT, /^\s*{\^?\s*([$\w]+)(?:\s*,\s*(\S+))?\s+in\s+(\S.*)\s*}/, /(^|[^\\]){=[\S\s]*?}/];

  var cachedBrackets = UNDEF,
      _regex,
      _cache = [],
      _settings;

  function _loopback(re) {
    return re;
  }

  function _rewrite(re, bp) {
    if (!bp) bp = _cache;
    return new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : '');
  }

  function _create(pair) {
    if (pair === DEFAULT) return _pairs;

    var arr = pair.split(' ');

    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {
      throw new Error('Unsupported brackets "' + pair + '"');
    }
    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\').split(' '));

    arr[4] = _rewrite(arr[1].length > 1 ? /{[\S\s]*?}/ : _pairs[4], arr);
    arr[5] = _rewrite(pair.length > 3 ? /\\({|})/g : _pairs[5], arr);
    arr[6] = _rewrite(_pairs[6], arr);
    arr[7] = RegExp('\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);
    arr[8] = pair;
    return arr;
  }

  function _brackets(reOrIdx) {
    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx];
  }

  _brackets.split = function split(str, tmpl, _bp) {
    // istanbul ignore next: _bp is for the compiler
    if (!_bp) _bp = _cache;

    var parts = [],
        match,
        isexpr,
        start,
        pos,
        re = _bp[6];

    isexpr = start = re.lastIndex = 0;

    while (match = re.exec(str)) {

      pos = match.index;

      if (isexpr) {

        if (match[2]) {
          re.lastIndex = skipBraces(str, match[2], re.lastIndex);
          continue;
        }
        if (!match[3]) {
          continue;
        }
      }

      if (!match[1]) {
        unescapeStr(str.slice(start, pos));
        start = re.lastIndex;
        re = _bp[6 + (isexpr ^= 1)];
        re.lastIndex = start;
      }
    }

    if (str && start < str.length) {
      unescapeStr(str.slice(start));
    }

    return parts;

    function unescapeStr(s) {
      if (tmpl || isexpr) {
        parts.push(s && s.replace(_bp[5], '$1'));
      } else {
        parts.push(s);
      }
    }

    function skipBraces(s, ch, ix) {
      var match,
          recch = FINDBRACES[ch];

      recch.lastIndex = ix;
      ix = 1;
      while (match = recch.exec(s)) {
        if (match[1] && !(match[1] === ch ? ++ix : --ix)) break;
      }
      return ix ? s.length : recch.lastIndex;
    }
  };

  _brackets.hasExpr = function hasExpr(str) {
    return _cache[4].test(str);
  };

  _brackets.loopKeys = function loopKeys(expr) {
    var m = expr.match(_cache[9]);

    return m ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] } : { val: expr.trim() };
  };

  _brackets.array = function array(pair) {
    return pair ? _create(pair) : _cache;
  };

  function _reset(pair) {
    if ((pair || (pair = DEFAULT)) !== _cache[8]) {
      _cache = _create(pair);
      _regex = pair === DEFAULT ? _loopback : _rewrite;
      _cache[9] = _regex(_pairs[9]);
    }
    cachedBrackets = pair;
  }

  function _setSettings(o) {
    var b;

    o = o || {};
    b = o.brackets;
    Object.defineProperty(o, 'brackets', {
      set: _reset,
      get: function () {
        return cachedBrackets;
      },
      enumerable: true
    });
    _settings = o;
    _reset(b);
  }

  Object.defineProperty(_brackets, 'settings', {
    set: _setSettings,
    get: function () {
      return _settings;
    }
  });

  /* istanbul ignore next: in the browser riot is always in the scope */
  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};
  _brackets.set = _reset;

  _brackets.R_STRINGS = R_STRINGS;
  _brackets.R_MLCOMMS = R_MLCOMMS;
  _brackets.S_QBLOCKS = S_QBLOCKS;

  return _brackets;
}();

/**
 * @module tmpl
 *
 * tmpl          - Root function, returns the template value, render with data
 * tmpl.hasExpr  - Test the existence of a expression inside a string
 * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)
 */

var tmpl = function () {

  var _cache = {};

  function _tmpl(str, data) {
    if (!str) return str;

    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr);
  }

  _tmpl.hasExpr = brackets.hasExpr;

  _tmpl.loopKeys = brackets.loopKeys;

  // istanbul ignore next
  _tmpl.clearCache = function () {
    _cache = {};
  };

  _tmpl.errorHandler = null;

  function _logErr(err, ctx) {

    err.riotData = {
      tagName: ctx && ctx.__ && ctx.__.tagName,
      _riot_id: ctx && ctx._riot_id //eslint-disable-line camelcase
    };

    if (_tmpl.errorHandler) _tmpl.errorHandler(err);else if (typeof console !== 'undefined' && typeof console.error === 'function') {
      if (err.riotData.tagName) {
        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);
      }
      console.error(err);
    }
  }

  function _create(str) {
    var expr = _getTmpl(str);

    if (expr.slice(0, 11) !== 'try{return ') expr = 'return ' + expr;

    return new Function('E', expr + ';'); // eslint-disable-line no-new-func
  }

  var CH_IDEXPR = String.fromCharCode(0x2057),
      RE_CSNAME = /^(?:(-?[_A-Za-z\xA0-\xFF][-\w\xA0-\xFF]*)|\u2057(\d+)~):/,
      RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),
      RE_DQUOTE = /\u2057/g,
      RE_QBMARK = /\u2057(\d+)~/g;

  function _getTmpl(str) {
    var qstr = [],
        expr,
        parts = brackets.split(str.replace(RE_DQUOTE, '"'), 1);

    if (parts.length > 2 || parts[0]) {
      var i,
          j,
          list = [];

      for (i = j = 0; i < parts.length; ++i) {

        expr = parts[i];

        if (expr && (expr = i & 1 ? _parseExpr(expr, 1, qstr) : '"' + expr.replace(/\\/g, '\\\\').replace(/\r\n?|\n/g, '\\n').replace(/"/g, '\\"') + '"')) list[j++] = expr;
      }

      expr = j < 2 ? list[0] : '[' + list.join(',') + '].join("")';
    } else {

      expr = _parseExpr(parts[1], 0, qstr);
    }

    if (qstr[0]) {
      expr = expr.replace(RE_QBMARK, function (_, pos) {
        return qstr[pos].replace(/\r/g, '\\r').replace(/\n/g, '\\n');
      });
    }
    return expr;
  }

  var RE_BREND = {
    '(': /[()]/g,
    '[': /[[\]]/g,
    '{': /[{}]/g
  };

  function _parseExpr(expr, asText, qstr) {

    expr = expr.replace(RE_QBLOCK, function (s, div) {
      return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s;
    }).replace(/\s+/g, ' ').trim().replace(/\ ?([[\({},?\.:])\ ?/g, '$1');

    if (expr) {
      var list = [],
          cnt = 0,
          match;

      while (expr && (match = expr.match(RE_CSNAME)) && !match.index) {
        var key,
            jsb,
            re = /,|([[{(])|$/g;

        expr = RegExp.rightContext;
        key = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\s+/g, ' ') : match[1];

        while (jsb = (match = re.exec(expr))[1]) skipBraces(jsb, re);

        jsb = expr.slice(0, match.index);
        expr = RegExp.rightContext;

        list[cnt++] = _wrapExpr(jsb, 1, key);
      }

      expr = !cnt ? _wrapExpr(expr, asText) : cnt > 1 ? '[' + list.join(',') + '].join(" ").trim()' : list[0];
    }
    return expr;

    function skipBraces(ch, re) {
      var mm,
          lv = 1,
          ir = RE_BREND[ch];

      ir.lastIndex = re.lastIndex;
      while (mm = ir.exec(expr)) {
        if (mm[0] === ch) ++lv;else if (! --lv) break;
      }
      re.lastIndex = lv ? expr.length : ir.lastIndex;
    }
  }

  // istanbul ignore next: not both
  var // eslint-disable-next-line max-len
  JS_CONTEXT = '"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',
      JS_VARNAME = /[,{][\$\w]+(?=:)|(^ *|[^$\w\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\w]))([$_A-Za-z][$\w]*)/g,
      JS_NOPROPS = /^(?=(\.[$\w]+))\1(?:[^.[(]|$)/;

  function _wrapExpr(expr, asText, key) {
    var tb;

    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {
      if (mvar) {
        pos = tb ? 0 : pos + match.length;

        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {
          match = p + '("' + mvar + JS_CONTEXT + mvar;
          if (pos) tb = (s = s[pos]) === '.' || s === '(' || s === '[';
        } else if (pos) {
          tb = !JS_NOPROPS.test(s.slice(pos));
        }
      }
      return match;
    });

    if (tb) {
      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';
    }

    if (key) {

      expr = (tb ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')') + '?"' + key + '":""';
    } else if (asText) {

      expr = 'function(v){' + (tb ? expr.replace('return ', 'v=') : 'v=(' + expr + ')') + ';return v||v===0?v:""}.call(this)';
    }

    return expr;
  }

  _tmpl.version = brackets.version = 'v3.0.3';

  return _tmpl;
}();

/**
 * Compiler for riot custom tags
 * @version v3.2.1
 */

// istanbul ignore next
function safeRegex(re) {
  var src = re.source;
  var opt = re.global ? 'g' : '';

  if (re.ignoreCase) opt += 'i';
  if (re.multiline) opt += 'm';

  for (var i = 1; i < arguments.length; i++) {
    src = src.replace('@', '\\' + arguments[i]);
  }

  return new RegExp(src, opt);
}

var RE_HASEXPR = safeRegex(/@#\d/, 'x01');
var RE_REPEXPR = safeRegex(/@#(\d+)/g, 'x01');
var CH_IDEXPR = '\x01#';
var CH_DQCODE = '\u2057';
var DQ = '"';
var SQ = "'";

// import hljs from "highlight.js";
riot_compiler.mount('*');

// compiler.compile(function() {
//   // here tags are compiled and riot.mount works synchronously
//   var tags = riot.mount('*')
//   console.log("tags", tags);
// })

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy9yaW90L3Jpb3QrY29tcGlsZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmlvdC10bXBsL2Rpc3QvZXM2LnRtcGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvcmlvdC1jb21waWxlci9kaXN0L2VzNi5jb21waWxlci5qcyIsIi4uLy4uL2NsaWVudC9tYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFJpb3QgdjMuNC4yLCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5yaW90ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgX19UQUdTX0NBQ0hFID0gW107XG52YXIgX19UQUdfSU1QTCA9IHt9O1xudmFyIEdMT0JBTF9NSVhJTiA9ICdfX2dsb2JhbF9taXhpbic7XG52YXIgQVRUUlNfUFJFRklYID0gJ3Jpb3QtJztcbnZhciBSRUZfRElSRUNUSVZFUyA9IFsncmVmJywgJ2RhdGEtcmVmJ107XG52YXIgSVNfRElSRUNUSVZFID0gJ2RhdGEtaXMnO1xudmFyIENPTkRJVElPTkFMX0RJUkVDVElWRSA9ICdpZic7XG52YXIgTE9PUF9ESVJFQ1RJVkUgPSAnZWFjaCc7XG52YXIgTE9PUF9OT19SRU9SREVSX0RJUkVDVElWRSA9ICduby1yZW9yZGVyJztcbnZhciBTSE9XX0RJUkVDVElWRSA9ICdzaG93JztcbnZhciBISURFX0RJUkVDVElWRSA9ICdoaWRlJztcbnZhciBSSU9UX0VWRU5UU19LRVkgPSAnX19yaW90LWV2ZW50c19fJztcbnZhciBUX1NUUklORyA9ICdzdHJpbmcnO1xudmFyIFRfT0JKRUNUID0gJ29iamVjdCc7XG52YXIgVF9VTkRFRiAgPSAndW5kZWZpbmVkJztcbnZhciBUX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbnZhciBYTElOS19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbnZhciBYTElOS19SRUdFWCA9IC9eeGxpbms6KFxcdyspLztcbnZhciBXSU4gPSB0eXBlb2Ygd2luZG93ID09PSBUX1VOREVGID8gdW5kZWZpbmVkIDogd2luZG93O1xudmFyIFJFX1NQRUNJQUxfVEFHUyA9IC9eKD86dCg/OmJvZHl8aGVhZHxmb290fFtyaGRdKXxjYXB0aW9ufGNvbCg/Omdyb3VwKT98b3B0KD86aW9ufGdyb3VwKSkkLztcbnZhciBSRV9TUEVDSUFMX1RBR1NfTk9fT1BUSU9OID0gL14oPzp0KD86Ym9keXxoZWFkfGZvb3R8W3JoZF0pfGNhcHRpb258Y29sKD86Z3JvdXApPykkLztcbnZhciBSRV9FVkVOVFNfUFJFRklYID0gL15vbi87XG52YXIgUkVfUkVTRVJWRURfTkFNRVMgPSAvXig/Ol8oPzppdGVtfGlkfHBhcmVudCl8dXBkYXRlfHJvb3R8KD86dW4pP21vdW50fG1peGlufGlzKD86TW91bnRlZHxMb29wKXx0YWdzfHJlZnN8cGFyZW50fG9wdHN8dHJpZ2dlcnxvKD86bnxmZnxuZSkpJC87XG52YXIgUkVfSFRNTF9BVFRSUyA9IC8oWy1cXHddKykgPz0gPyg/OlwiKFteXCJdKil8JyhbXiddKil8KHtbXn1dKn0pKS9nO1xudmFyIENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVMgPSB7ICd2aWV3Ym94JzogJ3ZpZXdCb3gnIH07XG52YXIgUkVfQk9PTF9BVFRSUyA9IC9eKD86ZGlzYWJsZWR8Y2hlY2tlZHxyZWFkb25seXxyZXF1aXJlZHxhbGxvd2Z1bGxzY3JlZW58YXV0byg/OmZvY3VzfHBsYXkpfGNvbXBhY3R8Y29udHJvbHN8ZGVmYXVsdHxmb3Jtbm92YWxpZGF0ZXxoaWRkZW58aXNtYXB8aXRlbXNjb3BlfGxvb3B8bXVsdGlwbGV8bXV0ZWR8bm8oPzpyZXNpemV8c2hhZGV8dmFsaWRhdGV8d3JhcCk/fG9wZW58cmV2ZXJzZWR8c2VhbWxlc3N8c2VsZWN0ZWR8c29ydGFibGV8dHJ1ZXNwZWVkfHR5cGVtdXN0bWF0Y2gpJC87XG52YXIgSUVfVkVSU0lPTiA9IChXSU4gJiYgV0lOLmRvY3VtZW50IHx8IHt9KS5kb2N1bWVudE1vZGUgfCAwO1xuXG4vKipcbiAqIENoZWNrIENoZWNrIGlmIHRoZSBwYXNzZWQgYXJndW1lbnQgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNCb29sQXR0cih2YWx1ZSkge1xuICByZXR1cm4gUkVfQk9PTF9BVFRSUy50ZXN0KHZhbHVlKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtXG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVF9GVU5DVElPTlxufVxuXG4vKipcbiAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhbiBvYmplY3QsIGV4Y2x1ZGUgbnVsbFxuICogTk9URTogdXNlIGlzT2JqZWN0KHgpICYmICFpc0FycmF5KHgpIHRvIGV4Y2x1ZGVzIGFycmF5cy5cbiAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gVF9PQkpFQ1QgLy8gdHlwZW9mIG51bGwgaXMgJ29iamVjdCdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtXG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFRfVU5ERUZcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYSBzdHJpbmdcbiAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gVF9TVFJJTkdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgZW1wdHkuIERpZmZlcmVudCBmcm9tIGZhbHN5LCBiZWNhdXNlIHdlIGRvbnQgY29uc2lkZXIgMCBvciBmYWxzZSB0byBiZSBibGFua1xuICogQHBhcmFtIHsgKiB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHBhc3NlZCBhcmd1bWVudCBpcyBhIGtpbmQgb2YgYXJyYXlcbiAqIEBwYXJhbSAgIHsgKiB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBBcnJheVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgb2JqZWN0J3MgcHJvcGVydHkgY291bGQgYmUgb3ZlcnJpZGRlblxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgb2JqIC0gc291cmNlIG9iamVjdFxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAga2V5IC0gb2JqZWN0IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gKi9cbmZ1bmN0aW9uIGlzV3JpdGFibGUob2JqLCBrZXkpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgcmV0dXJuIGlzVW5kZWZpbmVkKG9ialtrZXldKSB8fCBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3Iud3JpdGFibGVcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYSByZXNlcnZlZCBuYW1lXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHZhbHVlIC1cbiAqIEByZXR1cm5zIHsgQm9vbGVhbiB9IC1cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUodmFsdWUpIHtcbiAgcmV0dXJuIFJFX1JFU0VSVkVEX05BTUVTLnRlc3QodmFsdWUpXG59XG5cbnZhciBjaGVjayA9IE9iamVjdC5mcmVlemUoe1xuXHRpc0Jvb2xBdHRyOiBpc0Jvb2xBdHRyLFxuXHRpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcblx0aXNTdHJpbmc6IGlzU3RyaW5nLFxuXHRpc0JsYW5rOiBpc0JsYW5rLFxuXHRpc0FycmF5OiBpc0FycmF5LFxuXHRpc1dyaXRhYmxlOiBpc1dyaXRhYmxlLFxuXHRpc1Jlc2VydmVkTmFtZTogaXNSZXNlcnZlZE5hbWVcbn0pO1xuXG4vKipcbiAqIFNob3J0ZXIgYW5kIGZhc3Qgd2F5IHRvIHNlbGVjdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgRE9NXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHNlbGVjdG9yIC0gRE9NIHNlbGVjdG9yXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIERPTSBub2RlIHdoZXJlIHRoZSB0YXJnZXRzIG9mIG91ciBzZWFyY2ggd2lsbCBpcyBsb2NhdGVkXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvbSBub2RlcyBmb3VuZFxuICovXG5mdW5jdGlvbiAkJChzZWxlY3RvciwgY3R4KSB7XG4gIHJldHVybiAoY3R4IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKVxufVxuXG4vKipcbiAqIFNob3J0ZXIgYW5kIGZhc3Qgd2F5IHRvIHNlbGVjdCBhIHNpbmdsZSBub2RlIGluIHRoZSBET01cbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gc2VsZWN0b3IgLSB1bmlxdWUgZG9tIHNlbGVjdG9yXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIERPTSBub2RlIHdoZXJlIHRoZSB0YXJnZXQgb2Ygb3VyIHNlYXJjaCB3aWxsIGlzIGxvY2F0ZWRcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZG9tIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJChzZWxlY3RvciwgY3R4KSB7XG4gIHJldHVybiAoY3R4IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRvY3VtZW50IGZyYWdtZW50XG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IGRvY3VtZW50IGZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZyYWcoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkb2N1bWVudCB0ZXh0IG5vZGVcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gY3JlYXRlIGEgdGV4dCBub2RlIHRvIHVzZSBhcyBwbGFjZWhvbGRlclxuICovXG5mdW5jdGlvbiBjcmVhdGVET01QbGFjZWhvbGRlcigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGdlbmVyaWMgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gbmFtZSAtIG5hbWUgb2YgdGhlIERPTSBub2RlIHdlIHdhbnQgdG8gY3JlYXRlXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IERPTSBub2RlIGp1c3QgY3JlYXRlZFxuICovXG5mdW5jdGlvbiBta0VsKG5hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGlubmVyIGh0bWwgb2YgYW55IERPTSBub2RlIFNWR3MgaW5jbHVkZWRcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGNvbnRhaW5lciAtIERPTSBub2RlIHdoZXJlIHdlJ2xsIGluamVjdCBuZXcgaHRtbFxuICogQHBhcmFtIHsgU3RyaW5nIH0gaHRtbCAtIGh0bWwgdG8gaW5qZWN0XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBodG1sKSB7XG4gIGlmICghaXNVbmRlZmluZWQoY29udGFpbmVyLmlubmVySFRNTCkpXG4gICAgeyBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDsgfVxuICAgIC8vIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgaW5uZXJIVE1MIG9uIHRoZSBTVkdzIHRhZ3NcbiAgZWxzZSB7XG4gICAgdmFyIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIHZhciBub2RlID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQuaW1wb3J0Tm9kZShkb2MuZG9jdW1lbnRFbGVtZW50LCB0cnVlKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2YgYW55IERPTSBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9ICBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIGhpZGVcbiAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IHNob3cgLSBkbyB3ZSB3YW50IHRvIHNob3cgaXQ/XG4gKi9cblxuZnVuY3Rpb24gdG9nZ2xlVmlzaWJpbGl0eShkb20sIHNob3cpIHtcbiAgZG9tLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gJycgOiAnbm9uZSc7XG4gIGRvbVsnaGlkZGVuJ10gPSBzaG93ID8gZmFsc2UgOiB0cnVlO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbnkgRE9NIGF0dHJpYnV0ZSBmcm9tIGEgbm9kZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHVwZGF0ZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBuYW1lIC0gbmFtZSBvZiB0aGUgcHJvcGVydHkgd2Ugd2FudCB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtQXR0cihkb20sIG5hbWUpIHtcbiAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3R5bGUgb2JqZWN0IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHN0eWxlIC0gc3R5bGUgb2JqZWN0IHdlIG5lZWQgdG8gcGFyc2VcbiAqIEByZXR1cm5zIHsgU3RyaW5nIH0gcmVzdWx0aW5nIGNzcyBzdHJpbmdcbiAqIEBleGFtcGxlXG4gKiBzdHlsZU9iamVjdFRvU3RyaW5nKHsgY29sb3I6ICdyZWQnLCBoZWlnaHQ6ICcxMHB4J30pIC8vID0+ICdjb2xvcjogcmVkOyBoZWlnaHQ6IDEwcHgnXG4gKi9cbmZ1bmN0aW9uIHN0eWxlT2JqZWN0VG9TdHJpbmcoc3R5bGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcCkge1xuICAgIHJldHVybiAoYWNjICsgXCIgXCIgKyBwcm9wICsgXCI6IFwiICsgKHN0eWxlW3Byb3BdKSArIFwiO1wiKVxuICB9LCAnJylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGFueSBET00gYXR0cmlidXRlIG9uIGEgbm9kZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IG5hbWUgLSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgd2Ugd2FudCB0byBnZXRcbiAqIEByZXR1cm5zIHsgU3RyaW5nIHwgdW5kZWZpbmVkIH0gbmFtZSBvZiB0aGUgbm9kZSBhdHRyaWJ1dGUgd2hldGhlciBpdCBleGlzdHNcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cihkb20sIG5hbWUpIHtcbiAgcmV0dXJuIGRvbS5nZXRBdHRyaWJ1dGUobmFtZSlcbn1cblxuLyoqXG4gKiBTZXQgYW55IERPTSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGRvbSAtIERPTSBub2RlIHdlIHdhbnQgdG8gdXBkYXRlXG4gKiBAcGFyYW0geyBTdHJpbmcgfSBuYW1lIC0gbmFtZSBvZiB0aGUgcHJvcGVydHkgd2Ugd2FudCB0byBzZXRcbiAqIEBwYXJhbSB7IFN0cmluZyB9IHZhbCAtIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNldFxuICovXG5mdW5jdGlvbiBzZXRBdHRyKGRvbSwgbmFtZSwgdmFsKSB7XG4gIHZhciB4bGluayA9IFhMSU5LX1JFR0VYLmV4ZWMobmFtZSk7XG4gIGlmICh4bGluayAmJiB4bGlua1sxXSlcbiAgICB7IGRvbS5zZXRBdHRyaWJ1dGVOUyhYTElOS19OUywgeGxpbmtbMV0sIHZhbCk7IH1cbiAgZWxzZVxuICAgIHsgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB2YWwpOyB9XG59XG5cbi8qKlxuICogSW5zZXJ0IHNhZmVseSBhIHRhZyB0byBmaXggIzE5NjIgIzE2NDlcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSByb290IC0gY2hpbGRyZW4gY29udGFpbmVyXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gY3VyciAtIG5vZGUgdG8gaW5zZXJ0XG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gbmV4dCAtIG5vZGUgdGhhdCBzaG91bGQgcHJlY2VlZCB0aGUgY3VycmVudCBub2RlIGluc2VydGVkXG4gKi9cbmZ1bmN0aW9uIHNhZmVJbnNlcnQocm9vdCwgY3VyciwgbmV4dCkge1xuICByb290Lmluc2VydEJlZm9yZShjdXJyLCBuZXh0LnBhcmVudE5vZGUgJiYgbmV4dCk7XG59XG5cbi8qKlxuICogTWluaW1pemUgcmlzazogb25seSB6ZXJvIG9yIG9uZSBfc3BhY2VfIGJldHdlZW4gYXR0ciAmIHZhbHVlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgaHRtbCAtIGh0bWwgc3RyaW5nIHdlIHdhbnQgdG8gcGFyc2VcbiAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFwcGx5IG9uIGFueSBhdHRyaWJ1dGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gd2Fsa0F0dHJzKGh0bWwsIGZuKSB7XG4gIGlmICghaHRtbClcbiAgICB7IHJldHVybiB9XG4gIHZhciBtO1xuICB3aGlsZSAobSA9IFJFX0hUTUxfQVRUUlMuZXhlYyhodG1sKSlcbiAgICB7IGZuKG1bMV0udG9Mb3dlckNhc2UoKSwgbVsyXSB8fCBtWzNdIHx8IG1bNF0pOyB9XG59XG5cbi8qKlxuICogV2FsayBkb3duIHJlY3Vyc2l2ZWx5IGFsbCB0aGUgY2hpbGRyZW4gdGFncyBzdGFydGluZyBkb20gbm9kZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgIGRvbSAtIHN0YXJ0aW5nIG5vZGUgd2hlcmUgd2Ugd2lsbCBzdGFydCB0aGUgcmVjdXJzaW9uXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayB0byB0cmFuc2Zvcm0gdGhlIGNoaWxkIG5vZGUganVzdCBmb3VuZFxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgIGNvbnRleHQgLSBmbiBjYW4gb3B0aW9uYWxseSByZXR1cm4gYW4gb2JqZWN0LCB3aGljaCBpcyBwYXNzZWQgdG8gY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gd2Fsa05vZGVzKGRvbSwgZm4sIGNvbnRleHQpIHtcbiAgaWYgKGRvbSkge1xuICAgIHZhciByZXMgPSBmbihkb20sIGNvbnRleHQpO1xuICAgIHZhciBuZXh0O1xuICAgIC8vIHN0b3AgdGhlIHJlY3Vyc2lvblxuICAgIGlmIChyZXMgPT09IGZhbHNlKSB7IHJldHVybiB9XG5cbiAgICBkb20gPSBkb20uZmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgIG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgICB3YWxrTm9kZXMoZG9tLCBmbiwgcmVzKTtcbiAgICAgIGRvbSA9IG5leHQ7XG4gICAgfVxuICB9XG59XG5cbnZhciBkb20gPSBPYmplY3QuZnJlZXplKHtcblx0JCQ6ICQkLFxuXHQkOiAkLFxuXHRjcmVhdGVGcmFnOiBjcmVhdGVGcmFnLFxuXHRjcmVhdGVET01QbGFjZWhvbGRlcjogY3JlYXRlRE9NUGxhY2Vob2xkZXIsXG5cdG1rRWw6IG1rRWwsXG5cdHNldElubmVySFRNTDogc2V0SW5uZXJIVE1MLFxuXHR0b2dnbGVWaXNpYmlsaXR5OiB0b2dnbGVWaXNpYmlsaXR5LFxuXHRyZW1BdHRyOiByZW1BdHRyLFxuXHRzdHlsZU9iamVjdFRvU3RyaW5nOiBzdHlsZU9iamVjdFRvU3RyaW5nLFxuXHRnZXRBdHRyOiBnZXRBdHRyLFxuXHRzZXRBdHRyOiBzZXRBdHRyLFxuXHRzYWZlSW5zZXJ0OiBzYWZlSW5zZXJ0LFxuXHR3YWxrQXR0cnM6IHdhbGtBdHRycyxcblx0d2Fsa05vZGVzOiB3YWxrTm9kZXNcbn0pO1xuXG52YXIgc3R5bGVOb2RlO1xudmFyIGNzc1RleHRQcm9wO1xudmFyIGJ5TmFtZSA9IHt9O1xudmFyIHJlbWFpbmRlciA9IFtdO1xudmFyIG5lZWRzSW5qZWN0ID0gZmFsc2U7XG5cbi8vIHNraXAgdGhlIGZvbGxvd2luZyBjb2RlIG9uIHRoZSBzZXJ2ZXJcbmlmIChXSU4pIHtcbiAgc3R5bGVOb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgc3R5bGUgZWxlbWVudCB3aXRoIHRoZSBjb3JyZWN0IHR5cGVcbiAgICB2YXIgbmV3Tm9kZSA9IG1rRWwoJ3N0eWxlJyk7XG4gICAgc2V0QXR0cihuZXdOb2RlLCAndHlwZScsICd0ZXh0L2NzcycpO1xuXG4gICAgLy8gcmVwbGFjZSBhbnkgdXNlciBub2RlIG9yIGluc2VydCB0aGUgbmV3IG9uZSBpbnRvIHRoZSBoZWFkXG4gICAgdmFyIHVzZXJOb2RlID0gJCgnc3R5bGVbdHlwZT1yaW90XScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHVzZXJOb2RlKSB7XG4gICAgICBpZiAodXNlck5vZGUuaWQpIHsgbmV3Tm9kZS5pZCA9IHVzZXJOb2RlLmlkOyB9XG4gICAgICB1c2VyTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdOb2RlLCB1c2VyTm9kZSk7XG4gICAgfVxuICAgIGVsc2UgeyBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKG5ld05vZGUpOyB9XG5cbiAgICByZXR1cm4gbmV3Tm9kZVxuICB9KSgpO1xuICBjc3NUZXh0UHJvcCA9IHN0eWxlTm9kZS5zdHlsZVNoZWV0O1xufVxuXG4vKipcbiAqIE9iamVjdCB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbmplY3QgYW5kIG1hbmFnZSB0aGUgY3NzIG9mIGV2ZXJ5IHRhZyBpbnN0YW5jZVxuICovXG52YXIgc3R5bGVNYW5hZ2VyID0ge1xuICBzdHlsZU5vZGU6IHN0eWxlTm9kZSxcbiAgLyoqXG4gICAqIFNhdmUgYSB0YWcgc3R5bGUgdG8gYmUgbGF0ZXIgaW5qZWN0ZWQgaW50byBET01cbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gY3NzIC0gY3NzIHN0cmluZ1xuICAgKiBAcGFyYW0geyBTdHJpbmcgfSBuYW1lIC0gaWYgaXQncyBwYXNzZWQgd2Ugd2lsbCBtYXAgdGhlIGNzcyB0byBhIHRhZ25hbWVcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gYWRkKGNzcywgbmFtZSkge1xuICAgIGlmIChuYW1lKSB7IGJ5TmFtZVtuYW1lXSA9IGNzczsgfVxuICAgIGVsc2UgeyByZW1haW5kZXIucHVzaChjc3MpOyB9XG4gICAgbmVlZHNJbmplY3QgPSB0cnVlO1xuICB9LFxuICAvKipcbiAgICogSW5qZWN0IGFsbCBwcmV2aW91c2x5IHNhdmVkIHRhZyBzdHlsZXMgaW50byBET01cbiAgICogaW5uZXJIVE1MIHNlZW1zIHNsb3c6IGh0dHA6Ly9qc3BlcmYuY29tL3Jpb3QtaW5zZXJ0LXN0eWxlXG4gICAqL1xuICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICBpZiAoIVdJTiB8fCAhbmVlZHNJbmplY3QpIHsgcmV0dXJuIH1cbiAgICBuZWVkc0luamVjdCA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IE9iamVjdC5rZXlzKGJ5TmFtZSlcbiAgICAgIC5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gYnlOYW1lW2tdIH0pXG4gICAgICAuY29uY2F0KHJlbWFpbmRlcikuam9pbignXFxuJyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoY3NzVGV4dFByb3ApIHsgY3NzVGV4dFByb3AuY3NzVGV4dCA9IHN0eWxlOyB9XG4gICAgZWxzZSB7IHN0eWxlTm9kZS5pbm5lckhUTUwgPSBzdHlsZTsgfVxuICB9XG59O1xuXG4vKipcbiAqIFRoZSByaW90IHRlbXBsYXRlIGVuZ2luZVxuICogQHZlcnNpb24gdjMuMC4zXG4gKi9cbi8qKlxuICogcmlvdC51dGlsLmJyYWNrZXRzXG4gKlxuICogLSBgYnJhY2tldHMgICAgYCAtIFJldHVybnMgYSBzdHJpbmcgb3IgcmVnZXggYmFzZWQgb24gaXRzIHBhcmFtZXRlclxuICogLSBgYnJhY2tldHMuc2V0YCAtIENoYW5nZSB0aGUgY3VycmVudCByaW90IGJyYWNrZXRzXG4gKlxuICogQG1vZHVsZVxuICovXG5cbi8qIGdsb2JhbCByaW90ICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgYnJhY2tldHMgPSAoZnVuY3Rpb24gKFVOREVGKSB7XG5cbiAgdmFyXG4gICAgUkVHTE9CID0gJ2cnLFxuXG4gICAgUl9NTENPTU1TID0gL1xcL1xcKlteKl0qXFwqKyg/OlteKlxcL11bXipdKlxcKispKlxcLy9nLFxuXG4gICAgUl9TVFJJTkdTID0gL1wiW15cIlxcXFxdKig/OlxcXFxbXFxTXFxzXVteXCJcXFxcXSopKlwifCdbXidcXFxcXSooPzpcXFxcW1xcU1xcc11bXidcXFxcXSopKid8YFteYFxcXFxdKig/OlxcXFxbXFxTXFxzXVteYFxcXFxdKikqYC9nLFxuXG4gICAgU19RQkxPQ0tTID0gUl9TVFJJTkdTLnNvdXJjZSArICd8JyArXG4gICAgICAvKD86XFxicmV0dXJuXFxzK3woPzpbJFxcd1xcKVxcXV18XFwrXFwrfC0tKVxccyooXFwvKSg/IVsqXFwvXSkpLy5zb3VyY2UgKyAnfCcgK1xuICAgICAgL1xcLyg/PVteKlxcL10pW15bXFwvXFxcXF0qKD86KD86XFxbKD86XFxcXC58W15cXF1cXFxcXSopKlxcXXxcXFxcLilbXltcXC9cXFxcXSopKj8oXFwvKVtnaW1dKi8uc291cmNlLFxuXG4gICAgVU5TVVBQT1JURUQgPSBSZWdFeHAoJ1tcXFxcJyArICd4MDAtXFxcXHgxRjw+YS16QS1aMC05XFwnXCIsO1xcXFxcXFxcXScpLFxuXG4gICAgTkVFRF9FU0NBUEUgPSAvKD89W1tcXF0oKSorPy5eJHxdKS9nLFxuXG4gICAgRklOREJSQUNFUyA9IHtcbiAgICAgICcoJzogUmVnRXhwKCcoWygpXSl8JyAgICsgU19RQkxPQ0tTLCBSRUdMT0IpLFxuICAgICAgJ1snOiBSZWdFeHAoJyhbW1xcXFxdXSl8JyArIFNfUUJMT0NLUywgUkVHTE9CKSxcbiAgICAgICd7JzogUmVnRXhwKCcoW3t9XSl8JyAgICsgU19RQkxPQ0tTLCBSRUdMT0IpXG4gICAgfSxcblxuICAgIERFRkFVTFQgPSAneyB9JztcblxuICB2YXIgX3BhaXJzID0gW1xuICAgICd7JywgJ30nLFxuICAgICd7JywgJ30nLFxuICAgIC97W159XSp9LyxcbiAgICAvXFxcXChbe31dKS9nLFxuICAgIC9cXFxcKHspfHsvZyxcbiAgICBSZWdFeHAoJ1xcXFxcXFxcKH0pfChbWyh7XSl8KH0pfCcgKyBTX1FCTE9DS1MsIFJFR0xPQiksXG4gICAgREVGQVVMVCxcbiAgICAvXlxccyp7XFxeP1xccyooWyRcXHddKykoPzpcXHMqLFxccyooXFxTKykpP1xccytpblxccysoXFxTLiopXFxzKn0vLFxuICAgIC8oXnxbXlxcXFxdKXs9W1xcU1xcc10qP30vXG4gIF07XG5cbiAgdmFyXG4gICAgY2FjaGVkQnJhY2tldHMgPSBVTkRFRixcbiAgICBfcmVnZXgsXG4gICAgX2NhY2hlID0gW10sXG4gICAgX3NldHRpbmdzO1xuXG4gIGZ1bmN0aW9uIF9sb29wYmFjayAocmUpIHsgcmV0dXJuIHJlIH1cblxuICBmdW5jdGlvbiBfcmV3cml0ZSAocmUsIGJwKSB7XG4gICAgaWYgKCFicCkgeyBicCA9IF9jYWNoZTsgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKFxuICAgICAgcmUuc291cmNlLnJlcGxhY2UoL3svZywgYnBbMl0pLnJlcGxhY2UoL30vZywgYnBbM10pLCByZS5nbG9iYWwgPyBSRUdMT0IgOiAnJ1xuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGUgKHBhaXIpIHtcbiAgICBpZiAocGFpciA9PT0gREVGQVVMVCkgeyByZXR1cm4gX3BhaXJzIH1cblxuICAgIHZhciBhcnIgPSBwYWlyLnNwbGl0KCcgJyk7XG5cbiAgICBpZiAoYXJyLmxlbmd0aCAhPT0gMiB8fCBVTlNVUFBPUlRFRC50ZXN0KHBhaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGJyYWNrZXRzIFwiJyArIHBhaXIgKyAnXCInKVxuICAgIH1cbiAgICBhcnIgPSBhcnIuY29uY2F0KHBhaXIucmVwbGFjZShORUVEX0VTQ0FQRSwgJ1xcXFwnKS5zcGxpdCgnICcpKTtcblxuICAgIGFycls0XSA9IF9yZXdyaXRlKGFyclsxXS5sZW5ndGggPiAxID8gL3tbXFxTXFxzXSo/fS8gOiBfcGFpcnNbNF0sIGFycik7XG4gICAgYXJyWzVdID0gX3Jld3JpdGUocGFpci5sZW5ndGggPiAzID8gL1xcXFwoe3x9KS9nIDogX3BhaXJzWzVdLCBhcnIpO1xuICAgIGFycls2XSA9IF9yZXdyaXRlKF9wYWlyc1s2XSwgYXJyKTtcbiAgICBhcnJbN10gPSBSZWdFeHAoJ1xcXFxcXFxcKCcgKyBhcnJbM10gKyAnKXwoW1soe10pfCgnICsgYXJyWzNdICsgJyl8JyArIFNfUUJMT0NLUywgUkVHTE9CKTtcbiAgICBhcnJbOF0gPSBwYWlyO1xuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGZ1bmN0aW9uIF9icmFja2V0cyAocmVPcklkeCkge1xuICAgIHJldHVybiByZU9ySWR4IGluc3RhbmNlb2YgUmVnRXhwID8gX3JlZ2V4KHJlT3JJZHgpIDogX2NhY2hlW3JlT3JJZHhdXG4gIH1cblxuICBfYnJhY2tldHMuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoc3RyLCB0bXBsLCBfYnApIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogX2JwIGlzIGZvciB0aGUgY29tcGlsZXJcbiAgICBpZiAoIV9icCkgeyBfYnAgPSBfY2FjaGU7IH1cblxuICAgIHZhclxuICAgICAgcGFydHMgPSBbXSxcbiAgICAgIG1hdGNoLFxuICAgICAgaXNleHByLFxuICAgICAgc3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZSA9IF9icFs2XTtcblxuICAgIGlzZXhwciA9IHN0YXJ0ID0gcmUubGFzdEluZGV4ID0gMDtcblxuICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKHN0cikpKSB7XG5cbiAgICAgIHBvcyA9IG1hdGNoLmluZGV4O1xuXG4gICAgICBpZiAoaXNleHByKSB7XG5cbiAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgcmUubGFzdEluZGV4ID0gc2tpcEJyYWNlcyhzdHIsIG1hdGNoWzJdLCByZS5sYXN0SW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaFszXSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgICB1bmVzY2FwZVN0cihzdHIuc2xpY2Uoc3RhcnQsIHBvcykpO1xuICAgICAgICBzdGFydCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUgPSBfYnBbNiArIChpc2V4cHIgXj0gMSldO1xuICAgICAgICByZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyICYmIHN0YXJ0IDwgc3RyLmxlbmd0aCkge1xuICAgICAgdW5lc2NhcGVTdHIoc3RyLnNsaWNlKHN0YXJ0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzXG5cbiAgICBmdW5jdGlvbiB1bmVzY2FwZVN0ciAocykge1xuICAgICAgaWYgKHRtcGwgfHwgaXNleHByKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocyAmJiBzLnJlcGxhY2UoX2JwWzVdLCAnJDEnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBCcmFjZXMgKHMsIGNoLCBpeCkge1xuICAgICAgdmFyXG4gICAgICAgIG1hdGNoLFxuICAgICAgICByZWNjaCA9IEZJTkRCUkFDRVNbY2hdO1xuXG4gICAgICByZWNjaC5sYXN0SW5kZXggPSBpeDtcbiAgICAgIGl4ID0gMTtcbiAgICAgIHdoaWxlICgobWF0Y2ggPSByZWNjaC5leGVjKHMpKSkge1xuICAgICAgICBpZiAobWF0Y2hbMV0gJiZcbiAgICAgICAgICAhKG1hdGNoWzFdID09PSBjaCA/ICsraXggOiAtLWl4KSkgeyBicmVhayB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXggPyBzLmxlbmd0aCA6IHJlY2NoLmxhc3RJbmRleFxuICAgIH1cbiAgfTtcblxuICBfYnJhY2tldHMuaGFzRXhwciA9IGZ1bmN0aW9uIGhhc0V4cHIgKHN0cikge1xuICAgIHJldHVybiBfY2FjaGVbNF0udGVzdChzdHIpXG4gIH07XG5cbiAgX2JyYWNrZXRzLmxvb3BLZXlzID0gZnVuY3Rpb24gbG9vcEtleXMgKGV4cHIpIHtcbiAgICB2YXIgbSA9IGV4cHIubWF0Y2goX2NhY2hlWzldKTtcblxuICAgIHJldHVybiBtXG4gICAgICA/IHsga2V5OiBtWzFdLCBwb3M6IG1bMl0sIHZhbDogX2NhY2hlWzBdICsgbVszXS50cmltKCkgKyBfY2FjaGVbMV0gfVxuICAgICAgOiB7IHZhbDogZXhwci50cmltKCkgfVxuICB9O1xuXG4gIF9icmFja2V0cy5hcnJheSA9IGZ1bmN0aW9uIGFycmF5IChwYWlyKSB7XG4gICAgcmV0dXJuIHBhaXIgPyBfY3JlYXRlKHBhaXIpIDogX2NhY2hlXG4gIH07XG5cbiAgZnVuY3Rpb24gX3Jlc2V0IChwYWlyKSB7XG4gICAgaWYgKChwYWlyIHx8IChwYWlyID0gREVGQVVMVCkpICE9PSBfY2FjaGVbOF0pIHtcbiAgICAgIF9jYWNoZSA9IF9jcmVhdGUocGFpcik7XG4gICAgICBfcmVnZXggPSBwYWlyID09PSBERUZBVUxUID8gX2xvb3BiYWNrIDogX3Jld3JpdGU7XG4gICAgICBfY2FjaGVbOV0gPSBfcmVnZXgoX3BhaXJzWzldKTtcbiAgICB9XG4gICAgY2FjaGVkQnJhY2tldHMgPSBwYWlyO1xuICB9XG5cbiAgZnVuY3Rpb24gX3NldFNldHRpbmdzIChvKSB7XG4gICAgdmFyIGI7XG5cbiAgICBvID0gbyB8fCB7fTtcbiAgICBiID0gby5icmFja2V0cztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ2JyYWNrZXRzJywge1xuICAgICAgc2V0OiBfcmVzZXQsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlZEJyYWNrZXRzIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX3NldHRpbmdzID0gbztcbiAgICBfcmVzZXQoYik7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2JyYWNrZXRzLCAnc2V0dGluZ3MnLCB7XG4gICAgc2V0OiBfc2V0U2V0dGluZ3MsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfc2V0dGluZ3MgfVxuICB9KTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaW4gdGhlIGJyb3dzZXIgcmlvdCBpcyBhbHdheXMgaW4gdGhlIHNjb3BlICovXG4gIF9icmFja2V0cy5zZXR0aW5ncyA9IHR5cGVvZiByaW90ICE9PSAndW5kZWZpbmVkJyAmJiByaW90LnNldHRpbmdzIHx8IHt9O1xuICBfYnJhY2tldHMuc2V0ID0gX3Jlc2V0O1xuXG4gIF9icmFja2V0cy5SX1NUUklOR1MgPSBSX1NUUklOR1M7XG4gIF9icmFja2V0cy5SX01MQ09NTVMgPSBSX01MQ09NTVM7XG4gIF9icmFja2V0cy5TX1FCTE9DS1MgPSBTX1FCTE9DS1M7XG5cbiAgcmV0dXJuIF9icmFja2V0c1xuXG59KSgpO1xuXG4vKipcbiAqIEBtb2R1bGUgdG1wbFxuICpcbiAqIHRtcGwgICAgICAgICAgLSBSb290IGZ1bmN0aW9uLCByZXR1cm5zIHRoZSB0ZW1wbGF0ZSB2YWx1ZSwgcmVuZGVyIHdpdGggZGF0YVxuICogdG1wbC5oYXNFeHByICAtIFRlc3QgdGhlIGV4aXN0ZW5jZSBvZiBhIGV4cHJlc3Npb24gaW5zaWRlIGEgc3RyaW5nXG4gKiB0bXBsLmxvb3BLZXlzIC0gR2V0IHRoZSBrZXlzIGZvciBhbiAnZWFjaCcgbG9vcCAodXNlZCBieSBgX2VhY2hgKVxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgdG1wbCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIF9jYWNoZSA9IHt9O1xuXG4gIGZ1bmN0aW9uIF90bXBsIChzdHIsIGRhdGEpIHtcbiAgICBpZiAoIXN0cikgeyByZXR1cm4gc3RyIH1cblxuICAgIHJldHVybiAoX2NhY2hlW3N0cl0gfHwgKF9jYWNoZVtzdHJdID0gX2NyZWF0ZShzdHIpKSkuY2FsbChkYXRhLCBfbG9nRXJyKVxuICB9XG5cbiAgX3RtcGwuaGFzRXhwciA9IGJyYWNrZXRzLmhhc0V4cHI7XG5cbiAgX3RtcGwubG9vcEtleXMgPSBicmFja2V0cy5sb29wS2V5cztcblxuICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICBfdG1wbC5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyBfY2FjaGUgPSB7fTsgfTtcblxuICBfdG1wbC5lcnJvckhhbmRsZXIgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIF9sb2dFcnIgKGVyciwgY3R4KSB7XG5cbiAgICBlcnIucmlvdERhdGEgPSB7XG4gICAgICB0YWdOYW1lOiBjdHggJiYgY3R4Ll9fICYmIGN0eC5fXy50YWdOYW1lLFxuICAgICAgX3Jpb3RfaWQ6IGN0eCAmJiBjdHguX3Jpb3RfaWQgIC8vZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICB9O1xuXG4gICAgaWYgKF90bXBsLmVycm9ySGFuZGxlcikgeyBfdG1wbC5lcnJvckhhbmRsZXIoZXJyKTsgfVxuICAgIGVsc2UgaWYgKFxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgaWYgKGVyci5yaW90RGF0YS50YWdOYW1lKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Jpb3QgdGVtcGxhdGUgZXJyb3IgdGhyb3duIGluIHRoZSA8JXM+IHRhZycsIGVyci5yaW90RGF0YS50YWdOYW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlIChzdHIpIHtcbiAgICB2YXIgZXhwciA9IF9nZXRUbXBsKHN0cik7XG5cbiAgICBpZiAoZXhwci5zbGljZSgwLCAxMSkgIT09ICd0cnl7cmV0dXJuICcpIHsgZXhwciA9ICdyZXR1cm4gJyArIGV4cHI7IH1cblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ0UnLCBleHByICsgJzsnKSAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXG4gIH1cblxuICB2YXJcbiAgICBDSF9JREVYUFIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MjA1NyksXG4gICAgUkVfQ1NOQU1FID0gL14oPzooLT9bX0EtWmEtelxceEEwLVxceEZGXVstXFx3XFx4QTAtXFx4RkZdKil8XFx1MjA1NyhcXGQrKX4pOi8sXG4gICAgUkVfUUJMT0NLID0gUmVnRXhwKGJyYWNrZXRzLlNfUUJMT0NLUywgJ2cnKSxcbiAgICBSRV9EUVVPVEUgPSAvXFx1MjA1Ny9nLFxuICAgIFJFX1FCTUFSSyA9IC9cXHUyMDU3KFxcZCspfi9nO1xuXG4gIGZ1bmN0aW9uIF9nZXRUbXBsIChzdHIpIHtcbiAgICB2YXJcbiAgICAgIHFzdHIgPSBbXSxcbiAgICAgIGV4cHIsXG4gICAgICBwYXJ0cyA9IGJyYWNrZXRzLnNwbGl0KHN0ci5yZXBsYWNlKFJFX0RRVU9URSwgJ1wiJyksIDEpO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDIgfHwgcGFydHNbMF0pIHtcbiAgICAgIHZhciBpLCBqLCBsaXN0ID0gW107XG5cbiAgICAgIGZvciAoaSA9IGogPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICBleHByID0gcGFydHNbaV07XG5cbiAgICAgICAgaWYgKGV4cHIgJiYgKGV4cHIgPSBpICYgMVxuXG4gICAgICAgICAgICA/IF9wYXJzZUV4cHIoZXhwciwgMSwgcXN0cilcblxuICAgICAgICAgICAgOiAnXCInICsgZXhwclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbj98XFxuL2csICdcXFxcbicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArXG4gICAgICAgICAgICAgICdcIidcblxuICAgICAgICAgICkpIHsgbGlzdFtqKytdID0gZXhwcjsgfVxuXG4gICAgICB9XG5cbiAgICAgIGV4cHIgPSBqIDwgMiA/IGxpc3RbMF1cbiAgICAgICAgICAgOiAnWycgKyBsaXN0LmpvaW4oJywnKSArICddLmpvaW4oXCJcIiknO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZXhwciA9IF9wYXJzZUV4cHIocGFydHNbMV0sIDAsIHFzdHIpO1xuICAgIH1cblxuICAgIGlmIChxc3RyWzBdKSB7XG4gICAgICBleHByID0gZXhwci5yZXBsYWNlKFJFX1FCTUFSSywgZnVuY3Rpb24gKF8sIHBvcykge1xuICAgICAgICByZXR1cm4gcXN0cltwb3NdXG4gICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9XG5cbiAgdmFyXG4gICAgUkVfQlJFTkQgPSB7XG4gICAgICAnKCc6IC9bKCldL2csXG4gICAgICAnWyc6IC9bW1xcXV0vZyxcbiAgICAgICd7JzogL1t7fV0vZ1xuICAgIH07XG5cbiAgZnVuY3Rpb24gX3BhcnNlRXhwciAoZXhwciwgYXNUZXh0LCBxc3RyKSB7XG5cbiAgICBleHByID0gZXhwclxuICAgICAgICAgIC5yZXBsYWNlKFJFX1FCTE9DSywgZnVuY3Rpb24gKHMsIGRpdikge1xuICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoID4gMiAmJiAhZGl2ID8gQ0hfSURFWFBSICsgKHFzdHIucHVzaChzKSAtIDEpICsgJ34nIDogc1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKClcbiAgICAgICAgICAucmVwbGFjZSgvXFwgPyhbW1xcKHt9LD9cXC46XSlcXCA/L2csICckMScpO1xuXG4gICAgaWYgKGV4cHIpIHtcbiAgICAgIHZhclxuICAgICAgICBsaXN0ID0gW10sXG4gICAgICAgIGNudCA9IDAsXG4gICAgICAgIG1hdGNoO1xuXG4gICAgICB3aGlsZSAoZXhwciAmJlxuICAgICAgICAgICAgKG1hdGNoID0gZXhwci5tYXRjaChSRV9DU05BTUUpKSAmJlxuICAgICAgICAgICAgIW1hdGNoLmluZGV4XG4gICAgICAgICkge1xuICAgICAgICB2YXJcbiAgICAgICAgICBrZXksXG4gICAgICAgICAganNiLFxuICAgICAgICAgIHJlID0gLyx8KFtbeyhdKXwkL2c7XG5cbiAgICAgICAgZXhwciA9IFJlZ0V4cC5yaWdodENvbnRleHQ7XG4gICAgICAgIGtleSAgPSBtYXRjaFsyXSA/IHFzdHJbbWF0Y2hbMl1dLnNsaWNlKDEsIC0xKS50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpIDogbWF0Y2hbMV07XG5cbiAgICAgICAgd2hpbGUgKGpzYiA9IChtYXRjaCA9IHJlLmV4ZWMoZXhwcikpWzFdKSB7IHNraXBCcmFjZXMoanNiLCByZSk7IH1cblxuICAgICAgICBqc2IgID0gZXhwci5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGV4cHIgPSBSZWdFeHAucmlnaHRDb250ZXh0O1xuXG4gICAgICAgIGxpc3RbY250KytdID0gX3dyYXBFeHByKGpzYiwgMSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgZXhwciA9ICFjbnQgPyBfd3JhcEV4cHIoZXhwciwgYXNUZXh0KVxuICAgICAgICAgICA6IGNudCA+IDEgPyAnWycgKyBsaXN0LmpvaW4oJywnKSArICddLmpvaW4oXCIgXCIpLnRyaW0oKScgOiBsaXN0WzBdO1xuICAgIH1cbiAgICByZXR1cm4gZXhwclxuXG4gICAgZnVuY3Rpb24gc2tpcEJyYWNlcyAoY2gsIHJlKSB7XG4gICAgICB2YXJcbiAgICAgICAgbW0sXG4gICAgICAgIGx2ID0gMSxcbiAgICAgICAgaXIgPSBSRV9CUkVORFtjaF07XG5cbiAgICAgIGlyLmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIHdoaWxlIChtbSA9IGlyLmV4ZWMoZXhwcikpIHtcbiAgICAgICAgaWYgKG1tWzBdID09PSBjaCkgeyArK2x2OyB9XG4gICAgICAgIGVsc2UgaWYgKCEtLWx2KSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICAgIHJlLmxhc3RJbmRleCA9IGx2ID8gZXhwci5sZW5ndGggOiBpci5sYXN0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBib3RoXG4gIHZhciAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIEpTX0NPTlRFWFQgPSAnXCJpbiB0aGlzP3RoaXM6JyArICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyA/ICdnbG9iYWwnIDogJ3dpbmRvdycpICsgJykuJyxcbiAgICBKU19WQVJOQU1FID0gL1sse11bXFwkXFx3XSsoPz06KXwoXiAqfFteJFxcd1xcLntdKSg/ISg/OnR5cGVvZnx0cnVlfGZhbHNlfG51bGx8dW5kZWZpbmVkfGlufGluc3RhbmNlb2Z8aXMoPzpGaW5pdGV8TmFOKXx2b2lkfE5hTnxuZXd8RGF0ZXxSZWdFeHB8TWF0aCkoPyFbJFxcd10pKShbJF9BLVphLXpdWyRcXHddKikvZyxcbiAgICBKU19OT1BST1BTID0gL14oPz0oXFwuWyRcXHddKykpXFwxKD86W14uWyhdfCQpLztcblxuICBmdW5jdGlvbiBfd3JhcEV4cHIgKGV4cHIsIGFzVGV4dCwga2V5KSB7XG4gICAgdmFyIHRiO1xuXG4gICAgZXhwciA9IGV4cHIucmVwbGFjZShKU19WQVJOQU1FLCBmdW5jdGlvbiAobWF0Y2gsIHAsIG12YXIsIHBvcywgcykge1xuICAgICAgaWYgKG12YXIpIHtcbiAgICAgICAgcG9zID0gdGIgPyAwIDogcG9zICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIGlmIChtdmFyICE9PSAndGhpcycgJiYgbXZhciAhPT0gJ2dsb2JhbCcgJiYgbXZhciAhPT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICBtYXRjaCA9IHAgKyAnKFwiJyArIG12YXIgKyBKU19DT05URVhUICsgbXZhcjtcbiAgICAgICAgICBpZiAocG9zKSB7IHRiID0gKHMgPSBzW3Bvc10pID09PSAnLicgfHwgcyA9PT0gJygnIHx8IHMgPT09ICdbJzsgfVxuICAgICAgICB9IGVsc2UgaWYgKHBvcykge1xuICAgICAgICAgIHRiID0gIUpTX05PUFJPUFMudGVzdChzLnNsaWNlKHBvcykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9KTtcblxuICAgIGlmICh0Yikge1xuICAgICAgZXhwciA9ICd0cnl7cmV0dXJuICcgKyBleHByICsgJ31jYXRjaChlKXtFKGUsdGhpcyl9JztcbiAgICB9XG5cbiAgICBpZiAoa2V5KSB7XG5cbiAgICAgIGV4cHIgPSAodGJcbiAgICAgICAgICA/ICdmdW5jdGlvbigpeycgKyBleHByICsgJ30uY2FsbCh0aGlzKScgOiAnKCcgKyBleHByICsgJyknXG4gICAgICAgICkgKyAnP1wiJyArIGtleSArICdcIjpcIlwiJztcblxuICAgIH0gZWxzZSBpZiAoYXNUZXh0KSB7XG5cbiAgICAgIGV4cHIgPSAnZnVuY3Rpb24odil7JyArICh0YlxuICAgICAgICAgID8gZXhwci5yZXBsYWNlKCdyZXR1cm4gJywgJ3Y9JykgOiAndj0oJyArIGV4cHIgKyAnKSdcbiAgICAgICAgKSArICc7cmV0dXJuIHZ8fHY9PT0wP3Y6XCJcIn0uY2FsbCh0aGlzKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHJcbiAgfVxuXG4gIF90bXBsLnZlcnNpb24gPSBicmFja2V0cy52ZXJzaW9uID0gJ3YzLjAuMyc7XG5cbiAgcmV0dXJuIF90bXBsXG5cbn0pKCk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgb2JzZXJ2YWJsZSQxID0gZnVuY3Rpb24oZWwpIHtcblxuICAvKipcbiAgICogRXh0ZW5kIHRoZSBvcmlnaW5hbCBvYmplY3Qgb3IgY3JlYXRlIGEgbmV3IGVtcHR5IG9uZVxuICAgKiBAdHlwZSB7IE9iamVjdCB9XG4gICAqL1xuXG4gIGVsID0gZWwgfHwge307XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgdmFyaWFibGVzXG4gICAqL1xuICB2YXIgY2FsbGJhY2tzID0ge30sXG4gICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBBcGlcbiAgICovXG5cbiAgLy8gZXh0ZW5kIHRoZSBlbCBvYmplY3QgYWRkaW5nIHRoZSBvYnNlcnZhYmxlIG1ldGhvZHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZWwsIHtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gdG8gdGhlIGdpdmVuIGBldmVudGAgYW5kc1xuICAgICAqIGV4ZWN1dGUgdGhlIGBjYWxsYmFja2AgZWFjaCB0aW1lIGFuIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgKiBAcGFyYW0gIHsgU3RyaW5nIH0gZXZlbnQgLSBldmVudCBpZFxuICAgICAqIEBwYXJhbSAgeyBGdW5jdGlvbiB9IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7IE9iamVjdCB9IGVsXG4gICAgICovXG4gICAgb246IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIHsgKGNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3NbZXZlbnRdIHx8IFtdKS5wdXNoKGZuKTsgfVxuICAgICAgICByZXR1cm4gZWxcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYGV2ZW50YCBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0gICB7IFN0cmluZyB9IGV2ZW50IC0gZXZlbnQgaWRcbiAgICAgKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgKi9cbiAgICBvZmY6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihldmVudCwgZm4pIHtcbiAgICAgICAgaWYgKGV2ZW50ID09ICcqJyAmJiAhZm4pIHsgY2FsbGJhY2tzID0ge307IH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjYjsgY2IgPSBhcnIgJiYgYXJyW2ldOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKGNiID09IGZuKSB7IGFyci5zcGxpY2UoaS0tLCAxKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7IGRlbGV0ZSBjYWxsYmFja3NbZXZlbnRdOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsXG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExpc3RlbiB0byB0aGUgZ2l2ZW4gYGV2ZW50YCBhbmRcbiAgICAgKiBleGVjdXRlIHRoZSBgY2FsbGJhY2tgIGF0IG1vc3Qgb25jZVxuICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXZlbnQgLSBldmVudCBpZFxuICAgICAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgeyBPYmplY3QgfSBlbFxuICAgICAqL1xuICAgIG9uZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICAgICAgICBmdW5jdGlvbiBvbigpIHtcbiAgICAgICAgICBlbC5vZmYoZXZlbnQsIG9uKTtcbiAgICAgICAgICBmbi5hcHBseShlbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWwub24oZXZlbnQsIG9uKVxuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGFsbCBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBsaXN0ZW4gdG9cbiAgICAgKiB0aGUgZ2l2ZW4gYGV2ZW50YFxuICAgICAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gZXZlbnQgLSBldmVudCBpZFxuICAgICAqIEByZXR1cm5zIHsgT2JqZWN0IH0gZWxcbiAgICAgKi9cbiAgICB0cmlnZ2VyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG5cbiAgICAgICAgLy8gZ2V0dGluZyB0aGUgYXJndW1lbnRzXG4gICAgICAgIHZhciBhcmdsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGFyZ2xlbiksXG4gICAgICAgICAgZm5zLFxuICAgICAgICAgIGZuLFxuICAgICAgICAgIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2xlbjsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2kgKyAxXTsgLy8gc2tpcCBmaXJzdCBhcmd1bWVudFxuICAgICAgICB9XG5cbiAgICAgICAgZm5zID0gc2xpY2UuY2FsbChjYWxsYmFja3NbZXZlbnRdIHx8IFtdLCAwKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBmbiA9IGZuc1tpXTsgKytpKSB7XG4gICAgICAgICAgZm4uYXBwbHkoZWwsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrc1snKiddICYmIGV2ZW50ICE9ICcqJylcbiAgICAgICAgICB7IGVsLnRyaWdnZXIuYXBwbHkoZWwsIFsnKicsIGV2ZW50XS5jb25jYXQoYXJncykpOyB9XG5cbiAgICAgICAgcmV0dXJuIGVsXG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWxcblxufTtcblxuLyoqXG4gKiBTcGVjaWFsaXplZCBmdW5jdGlvbiBmb3IgbG9vcGluZyBhbiBhcnJheS1saWtlIGNvbGxlY3Rpb24gd2l0aCBgZWFjaD17fWBcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBsaXN0IC0gY29sbGVjdGlvbiBvZiBpdGVtc1xuICogQHBhcmFtICAge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7IEFycmF5IH0gdGhlIGFycmF5IGxvb3BlZFxuICovXG5mdW5jdGlvbiBlYWNoKGxpc3QsIGZuKSB7XG4gIHZhciBsZW4gPSBsaXN0ID8gbGlzdC5sZW5ndGggOiAwO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBmbihsaXN0W2ldLCBpKTtcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYW4gYXJyYXkgY29udGFpbnMgYW4gaXRlbVxuICogQHBhcmFtICAgeyBBcnJheSB9IGFycmF5IC0gdGFyZ2V0IGFycmF5XG4gKiBAcGFyYW0gICB7ICogfSBpdGVtIC0gaXRlbSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7IEJvb2xlYW4gfSAtXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCBpdGVtKSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgY29udGFpbmluZyBkYXNoZXMgdG8gY2FtZWwgY2FzZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBzdHIgLSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHsgU3RyaW5nIH0gbXktc3RyaW5nIC0+IG15U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHRvQ2FtZWwoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvLShcXHcpL2csIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG59XG5cbi8qKlxuICogRmFzdGVyIFN0cmluZyBzdGFydHNXaXRoIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9IHN0ciAtIHNvdXJjZSBzdHJpbmdcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdmFsdWUgLSB0ZXN0IHN0cmluZ1xuICogQHJldHVybnMgeyBCb29sZWFuIH0gLVxuICovXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgwLCB2YWx1ZS5sZW5ndGgpID09PSB2YWx1ZVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZXQgYW4gaW1tdXRhYmxlIHByb3BlcnR5XG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGVsIC0gb2JqZWN0IHdoZXJlIHRoZSBuZXcgcHJvcGVydHkgd2lsbCBiZSBzZXRcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0ga2V5IC0gb2JqZWN0IGtleSB3aGVyZSB0aGUgbmV3IHByb3BlcnR5IHdpbGwgYmUgc3RvcmVkXG4gKiBAcGFyYW0gICB7ICogfSB2YWx1ZSAtIHZhbHVlIG9mIHRoZSBuZXcgcHJvcGVydHlcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0aW9ucyAtIHNldCB0aGUgcHJvcGVyeSBvdmVycmlkaW5nIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gLSB0aGUgaW5pdGlhbCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoZWwsIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBrZXksIGV4dGVuZCh7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSwgb3B0aW9ucykpO1xuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBFeHRlbmQgYW55IG9iamVjdCB3aXRoIG90aGVyIHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gc3JjIC0gc291cmNlIG9iamVjdFxuICogQHJldHVybnMgeyBPYmplY3QgfSB0aGUgcmVzdWx0aW5nIGV4dGVuZGVkIG9iamVjdFxuICpcbiAqIHZhciBvYmogPSB7IGZvbzogJ2JheicgfVxuICogZXh0ZW5kKG9iaiwge2JhcjogJ2JhcicsIGZvbzogJ2Jhcid9KVxuICogY29uc29sZS5sb2cob2JqKSA9PiB7YmFyOiAnYmFyJywgZm9vOiAnYmFyJ31cbiAqXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChzcmMpIHtcbiAgdmFyIG9iaiwgYXJncyA9IGFyZ3VtZW50cztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG9iaiA9IGFyZ3NbaV0pIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBvZiB0aGUgc291cmNlIG9iamVjdCBjb3VsZCBiZSBvdmVycmlkZGVuXG4gICAgICAgIGlmIChpc1dyaXRhYmxlKHNyYywga2V5KSlcbiAgICAgICAgICB7IHNyY1trZXldID0gb2JqW2tleV07IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNyY1xufVxuXG52YXIgbWlzYyA9IE9iamVjdC5mcmVlemUoe1xuXHRlYWNoOiBlYWNoLFxuXHRjb250YWluczogY29udGFpbnMsXG5cdHRvQ2FtZWw6IHRvQ2FtZWwsXG5cdHN0YXJ0c1dpdGg6IHN0YXJ0c1dpdGgsXG5cdGRlZmluZVByb3BlcnR5OiBkZWZpbmVQcm9wZXJ0eSxcblx0ZXh0ZW5kOiBleHRlbmRcbn0pO1xuXG52YXIgc2V0dGluZ3MkMSA9IGV4dGVuZChPYmplY3QuY3JlYXRlKGJyYWNrZXRzLnNldHRpbmdzKSwge1xuICBza2lwQW5vbnltb3VzVGFnczogdHJ1ZVxufSk7XG5cbi8qKlxuICogVHJpZ2dlciBET00gZXZlbnRzXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gZG9tIC0gZG9tIGVsZW1lbnQgdGFyZ2V0IG9mIHRoZSBldmVudFxuICogQHBhcmFtICAgeyBGdW5jdGlvbiB9IGhhbmRsZXIgLSB1c2VyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGUgLSBldmVudCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQoZG9tLCBoYW5kbGVyLCBlKSB7XG4gIHZhciBwdGFnID0gdGhpcy5fXy5wYXJlbnQsXG4gICAgaXRlbSA9IHRoaXMuX18uaXRlbTtcblxuICBpZiAoIWl0ZW0pXG4gICAgeyB3aGlsZSAocHRhZyAmJiAhaXRlbSkge1xuICAgICAgaXRlbSA9IHB0YWcuX18uaXRlbTtcbiAgICAgIHB0YWcgPSBwdGFnLl9fLnBhcmVudDtcbiAgICB9IH1cblxuICAvLyBvdmVycmlkZSB0aGUgZXZlbnQgcHJvcGVydGllc1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaXNXcml0YWJsZShlLCAnY3VycmVudFRhcmdldCcpKSB7IGUuY3VycmVudFRhcmdldCA9IGRvbTsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaXNXcml0YWJsZShlLCAndGFyZ2V0JykpIHsgZS50YXJnZXQgPSBlLnNyY0VsZW1lbnQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKGlzV3JpdGFibGUoZSwgJ3doaWNoJykpIHsgZS53aGljaCA9IGUuY2hhckNvZGUgfHwgZS5rZXlDb2RlOyB9XG5cbiAgZS5pdGVtID0gaXRlbTtcblxuICBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG5cbiAgaWYgKCFlLnByZXZlbnRVcGRhdGUpIHtcbiAgICB2YXIgcCA9IGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudFRhZyh0aGlzKTtcbiAgICAvLyBmaXhlcyAjMjA4M1xuICAgIGlmIChwLmlzTW91bnRlZCkgeyBwLnVwZGF0ZSgpOyB9XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gZXZlbnQgdG8gYSBET00gbm9kZVxuICogQHBhcmFtIHsgU3RyaW5nIH0gbmFtZSAtIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7IEZ1bmN0aW9uIH0gaGFuZGxlciAtIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0geyBPYmplY3QgfSBkb20gLSBkb20gbm9kZVxuICogQHBhcmFtIHsgVGFnIH0gdGFnIC0gdGFnIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHNldEV2ZW50SGFuZGxlcihuYW1lLCBoYW5kbGVyLCBkb20sIHRhZykge1xuICB2YXIgZXZlbnROYW1lLFxuICAgIGNiID0gaGFuZGxlRXZlbnQuYmluZCh0YWcsIGRvbSwgaGFuZGxlcik7XG5cbiAgLy8gbm9ybWFsaXplIGV2ZW50IG5hbWVcbiAgZXZlbnROYW1lID0gbmFtZS5yZXBsYWNlKFJFX0VWRU5UU19QUkVGSVgsICcnKTtcblxuICAvLyBjYWNoZSB0aGUgbGlzdGVuZXIgaW50byB0aGUgbGlzdGVuZXJzIGFycmF5XG4gIGlmICghY29udGFpbnModGFnLl9fLmxpc3RlbmVycywgZG9tKSkgeyB0YWcuX18ubGlzdGVuZXJzLnB1c2goZG9tKTsgfVxuICBpZiAoIWRvbVtSSU9UX0VWRU5UU19LRVldKSB7IGRvbVtSSU9UX0VWRU5UU19LRVldID0ge307IH1cbiAgaWYgKGRvbVtSSU9UX0VWRU5UU19LRVldW25hbWVdKSB7IGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZG9tW1JJT1RfRVZFTlRTX0tFWV1bbmFtZV0pOyB9XG5cbiAgZG9tW1JJT1RfRVZFTlRTX0tFWV1bbmFtZV0gPSBjYjtcbiAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYiwgZmFsc2UpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBkeW5hbWljYWxseSBjcmVhdGVkIGRhdGEtaXMgdGFncyB3aXRoIGNoYW5naW5nIGV4cHJlc3Npb25zXG4gKiBAcGFyYW0geyBPYmplY3QgfSBleHByIC0gZXhwcmVzc2lvbiB0YWcgYW5kIGV4cHJlc3Npb24gaW5mb1xuICogQHBhcmFtIHsgVGFnIH0gICAgcGFyZW50IC0gcGFyZW50IGZvciB0YWcgY3JlYXRpb25cbiAqIEBwYXJhbSB7IFN0cmluZyB9IHRhZ05hbWUgLSB0YWcgaW1wbGVtZW50YXRpb24gd2Ugd2FudCB0byB1c2VcbiAqL1xuZnVuY3Rpb24gdXBkYXRlRGF0YUlzKGV4cHIsIHBhcmVudCwgdGFnTmFtZSkge1xuICB2YXIgY29uZiwgaXNWaXJ0dWFsLCBoZWFkLCByZWY7XG5cbiAgaWYgKGV4cHIudGFnICYmIGV4cHIudGFnTmFtZSA9PT0gdGFnTmFtZSkge1xuICAgIGV4cHIudGFnLnVwZGF0ZSgpO1xuICAgIHJldHVyblxuICB9XG5cbiAgaXNWaXJ0dWFsID0gZXhwci5kb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuICAvLyBzeW5jIF9wYXJlbnQgdG8gYWNjb21tb2RhdGUgY2hhbmdpbmcgdGFnbmFtZXNcbiAgaWYgKGV4cHIudGFnKSB7XG5cbiAgICAvLyBuZWVkIHBsYWNlaG9sZGVyIGJlZm9yZSB1bm1vdW50XG4gICAgaWYoaXNWaXJ0dWFsKSB7XG4gICAgICBoZWFkID0gZXhwci50YWcuX18uaGVhZDtcbiAgICAgIHJlZiA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCk7XG4gICAgICBoZWFkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHJlZiwgaGVhZCk7XG4gICAgfVxuXG4gICAgZXhwci50YWcudW5tb3VudCh0cnVlKTtcbiAgfVxuXG4gIGV4cHIuaW1wbCA9IF9fVEFHX0lNUExbdGFnTmFtZV07XG4gIGNvbmYgPSB7cm9vdDogZXhwci5kb20sIHBhcmVudDogcGFyZW50LCBoYXNJbXBsOiB0cnVlLCB0YWdOYW1lOiB0YWdOYW1lfTtcbiAgZXhwci50YWcgPSBpbml0Q2hpbGRUYWcoZXhwci5pbXBsLCBjb25mLCBleHByLmRvbS5pbm5lckhUTUwsIHBhcmVudCk7XG4gIGVhY2goZXhwci5hdHRycywgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHNldEF0dHIoZXhwci50YWcucm9vdCwgYS5uYW1lLCBhLnZhbHVlKTsgfSk7XG4gIGV4cHIudGFnTmFtZSA9IHRhZ05hbWU7XG4gIGV4cHIudGFnLm1vdW50KCk7XG4gIGlmIChpc1ZpcnR1YWwpXG4gICAgeyBtYWtlUmVwbGFjZVZpcnR1YWwoZXhwci50YWcsIHJlZiB8fCBleHByLnRhZy5yb290KTsgfSAvLyByb290IGV4aXN0IGZpcnN0IHRpbWUsIGFmdGVyIHVzZSBwbGFjZWhvbGRlclxuXG4gIC8vIHBhcmVudCBpcyB0aGUgcGxhY2Vob2xkZXIgdGFnLCBub3QgdGhlIGR5bmFtaWMgdGFnIHNvIGNsZWFuIHVwXG4gIHBhcmVudC5fXy5vblVubW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVsTmFtZSA9IGV4cHIudGFnLm9wdHMuZGF0YUlzLFxuICAgICAgdGFncyA9IGV4cHIudGFnLnBhcmVudC50YWdzLFxuICAgICAgX3RhZ3MgPSBleHByLnRhZy5fXy5wYXJlbnQudGFncztcbiAgICBhcnJheWlzaFJlbW92ZSh0YWdzLCBkZWxOYW1lLCBleHByLnRhZyk7XG4gICAgYXJyYXlpc2hSZW1vdmUoX3RhZ3MsIGRlbE5hbWUsIGV4cHIudGFnKTtcbiAgICBleHByLnRhZy51bm1vdW50KCk7XG4gIH07XG59XG5cbi8qKlxuICogTm9tYWxpemUgYW55IGF0dHJpYnV0ZSByZW1vdmluZyB0aGUgXCJyaW90LVwiIHByZWZpeFxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBhdHRyTmFtZSAtIG9yaWdpbmFsIGF0dHJpYnV0ZSBuYW1lXG4gKiBAcmV0dXJucyB7IFN0cmluZyB9IHZhbGlkIGh0bWwgYXR0cmlidXRlIG5hbWVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQXR0ck5hbWUoYXR0ck5hbWUpIHtcbiAgaWYgKCFhdHRyTmFtZSkgeyByZXR1cm4gbnVsbCB9XG4gIGF0dHJOYW1lID0gYXR0ck5hbWUucmVwbGFjZShBVFRSU19QUkVGSVgsICcnKTtcbiAgaWYgKENBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVNbYXR0ck5hbWVdKSB7IGF0dHJOYW1lID0gQ0FTRV9TRU5TSVRJVkVfQVRUUklCVVRFU1thdHRyTmFtZV07IH1cbiAgcmV0dXJuIGF0dHJOYW1lXG59XG5cbi8qKlxuICogVXBkYXRlIG9uIHNpbmdsZSB0YWcgZXhwcmVzc2lvblxuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0geyBPYmplY3QgfSBleHByIC0gZXhwcmVzc2lvbiBsb2dpY1xuICogQHJldHVybnMgeyB1bmRlZmluZWQgfVxuICovXG5mdW5jdGlvbiB1cGRhdGVFeHByZXNzaW9uKGV4cHIpIHtcbiAgaWYgKHRoaXMucm9vdCAmJiBnZXRBdHRyKHRoaXMucm9vdCwndmlydHVhbGl6ZWQnKSkgeyByZXR1cm4gfVxuXG4gIHZhciBkb20gPSBleHByLmRvbSxcbiAgICAvLyByZW1vdmUgdGhlIHJpb3QtIHByZWZpeFxuICAgIGF0dHJOYW1lID0gbm9ybWFsaXplQXR0ck5hbWUoZXhwci5hdHRyKSxcbiAgICBpc1RvZ2dsZSA9IGNvbnRhaW5zKFtTSE9XX0RJUkVDVElWRSwgSElERV9ESVJFQ1RJVkVdLCBhdHRyTmFtZSksXG4gICAgaXNWaXJ0dWFsID0gZXhwci5yb290ICYmIGV4cHIucm9vdC50YWdOYW1lID09PSAnVklSVFVBTCcsXG4gICAgcGFyZW50ID0gZG9tICYmIChleHByLnBhcmVudCB8fCBkb20ucGFyZW50Tm9kZSksXG4gICAgLy8gZGV0ZWN0IHRoZSBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgaXNTdHlsZUF0dHIgPSBhdHRyTmFtZSA9PT0gJ3N0eWxlJyxcbiAgICBpc0NsYXNzQXR0ciA9IGF0dHJOYW1lID09PSAnY2xhc3MnLFxuICAgIGlzT2JqLFxuICAgIHZhbHVlO1xuXG4gIC8vIGlmIGl0J3MgYSB0YWcgd2UgY291bGQgdG90YWxseSBza2lwIHRoZSByZXN0XG4gIGlmIChleHByLl9yaW90X2lkKSB7XG4gICAgaWYgKGV4cHIuaXNNb3VudGVkKSB7XG4gICAgICBleHByLnVwZGF0ZSgpO1xuICAgIC8vIGlmIGl0IGhhc24ndCBiZWVuIG1vdW50ZWQgeWV0LCBkbyB0aGF0IG5vdy5cbiAgICB9IGVsc2Uge1xuICAgICAgZXhwci5tb3VudCgpO1xuICAgICAgaWYgKGlzVmlydHVhbCkge1xuICAgICAgICBtYWtlUmVwbGFjZVZpcnR1YWwoZXhwciwgZXhwci5yb290KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gaWYgdGhpcyBleHByZXNzaW9uIGhhcyB0aGUgdXBkYXRlIG1ldGhvZCBpdCBtZWFucyBpdCBjYW4gaGFuZGxlIHRoZSBET00gY2hhbmdlcyBieSBpdHNlbGZcbiAgaWYgKGV4cHIudXBkYXRlKSB7IHJldHVybiBleHByLnVwZGF0ZSgpIH1cblxuICAvLyAuLi5pdCBzZWVtcyB0byBiZSBhIHNpbXBsZSBleHByZXNzaW9uIHNvIHdlIHRyeSB0byBjYWxjdWxhdCBpdHMgdmFsdWVcbiAgdmFsdWUgPSB0bXBsKGV4cHIuZXhwciwgdGhpcyk7XG4gIGlzT2JqID0gaXNPYmplY3QodmFsdWUpO1xuXG4gIC8vIGNvbnZlcnQgdGhlIHN0eWxlL2NsYXNzIG9iamVjdHMgdG8gc3RyaW5nc1xuICBpZiAoaXNPYmopIHtcbiAgICBpc09iaiA9ICFpc0NsYXNzQXR0ciAmJiAhaXNTdHlsZUF0dHI7XG4gICAgaWYgKGlzQ2xhc3NBdHRyKSB7XG4gICAgICB2YWx1ZSA9IHRtcGwoSlNPTi5zdHJpbmdpZnkodmFsdWUpLCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGlzU3R5bGVBdHRyKSB7XG4gICAgICB2YWx1ZSA9IHN0eWxlT2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBvcmlnaW5hbCBhdHRyaWJ1dGVcbiAgaWYgKGV4cHIuYXR0ciAmJiAoIWV4cHIuaXNBdHRyUmVtb3ZlZCB8fCAhdmFsdWUpKSB7XG4gICAgcmVtQXR0cihkb20sIGV4cHIuYXR0cik7XG4gICAgZXhwci5pc0F0dHJSZW1vdmVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGZvciB0aGUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdlIGRvbid0IG5lZWQgdGhlIHZhbHVlXG4gIC8vIHdlIGNhbiBjb252ZXJ0IGl0IHRvIGNoZWNrZWQ9dHJ1ZSB0byBjaGVja2VkPWNoZWNrZWRcbiAgaWYgKGV4cHIuYm9vbCkgeyB2YWx1ZSA9IHZhbHVlID8gYXR0ck5hbWUgOiBmYWxzZTsgfVxuICBpZiAoZXhwci5pc1J0YWcpIHsgcmV0dXJuIHVwZGF0ZURhdGFJcyhleHByLCB0aGlzLCB2YWx1ZSkgfVxuICBpZiAoZXhwci53YXNQYXJzZWRPbmNlICYmIGV4cHIudmFsdWUgPT09IHZhbHVlKSB7IHJldHVybiB9XG5cbiAgLy8gdXBkYXRlIHRoZSBleHByZXNzaW9uIHZhbHVlXG4gIGV4cHIudmFsdWUgPSB2YWx1ZTtcbiAgZXhwci53YXNQYXJzZWRPbmNlID0gdHJ1ZTtcblxuICAvLyBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IHdlIGNhbiBub3QgZG8gbXVjaCBtb3JlIHdpdGggaXRcbiAgaWYgKGlzT2JqICYmICFpc1RvZ2dsZSkgeyByZXR1cm4gfVxuICAvLyBhdm9pZCB0byByZW5kZXIgdW5kZWZpbmVkL251bGwgdmFsdWVzXG4gIGlmIChpc0JsYW5rKHZhbHVlKSkgeyB2YWx1ZSA9ICcnOyB9XG5cbiAgLy8gdGV4dGFyZWEgYW5kIHRleHQgbm9kZXMgaGF2ZSBubyBhdHRyaWJ1dGUgbmFtZVxuICBpZiAoIWF0dHJOYW1lKSB7XG4gICAgLy8gYWJvdXQgIzgxNSB3L28gcmVwbGFjZTogdGhlIGJyb3dzZXIgY29udmVydHMgdGhlIHZhbHVlIHRvIGEgc3RyaW5nLFxuICAgIC8vIHRoZSBjb21wYXJpc29uIGJ5IFwiPT1cIiBkb2VzIHRvbywgYnV0IG5vdCBpbiB0aGUgc2VydmVyXG4gICAgdmFsdWUgKz0gJyc7XG4gICAgLy8gdGVzdCBmb3IgcGFyZW50IGF2b2lkcyBlcnJvciB3aXRoIGludmFsaWQgYXNzaWdubWVudCB0byBub2RlVmFsdWVcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAvLyBjYWNoZSB0aGUgcGFyZW50IG5vZGUgYmVjYXVzZSBzb21laG93IGl0IHdpbGwgYmVjb21lIG51bGwgb24gSUVcbiAgICAgIC8vIG9uIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgZXhwci5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgcGFyZW50LnZhbHVlID0gdmFsdWU7ICAgICAgICAgICAgICAgICAgICAvLyAjMTExM1xuICAgICAgICBpZiAoIUlFX1ZFUlNJT04pIHsgZG9tLm5vZGVWYWx1ZSA9IHZhbHVlOyB9ICAvLyAjMTYyNSBJRSB0aHJvd3MgaGVyZSwgbm9kZVZhbHVlXG4gICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGF2YWlsYWJsZSBvbiAndXBkYXRlZCdcbiAgICAgIGVsc2UgeyBkb20ubm9kZVZhbHVlID0gdmFsdWU7IH1cbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuXG4gIC8vIGV2ZW50IGhhbmRsZXJcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgc2V0RXZlbnRIYW5kbGVyKGF0dHJOYW1lLCB2YWx1ZSwgZG9tLCB0aGlzKTtcbiAgLy8gc2hvdyAvIGhpZGVcbiAgfSBlbHNlIGlmIChpc1RvZ2dsZSkge1xuICAgIHRvZ2dsZVZpc2liaWxpdHkoZG9tLCBhdHRyTmFtZSA9PT0gSElERV9ESVJFQ1RJVkUgPyAhdmFsdWUgOiB2YWx1ZSk7XG4gIC8vIGhhbmRsZSBhdHRyaWJ1dGVzXG4gIH0gZWxzZSB7XG4gICAgaWYgKGV4cHIuYm9vbCkge1xuICAgICAgZG9tW2F0dHJOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChhdHRyTmFtZSA9PT0gJ3ZhbHVlJyAmJiBkb20udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICBkb20udmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQmxhbmsodmFsdWUpICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgc2V0QXR0cihkb20sIGF0dHJOYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgaW4gY2FzZSBvZiBzdHlsZSBjaGFuZ2VzXG4gICAgLy8gdGhlIGVsZW1lbnQgc3RheXMgaGlkZGVuXG4gICAgaWYgKGlzU3R5bGVBdHRyICYmIGRvbS5oaWRkZW4pIHsgdG9nZ2xlVmlzaWJpbGl0eShkb20sIGZhbHNlKTsgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIGFsbCB0aGUgZXhwcmVzc2lvbnMgaW4gYSBUYWcgaW5zdGFuY2VcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtIHsgQXJyYXkgfSBleHByZXNzaW9ucyAtIGV4cHJlc3Npb24gdGhhdCBtdXN0IGJlIHJlIGV2YWx1YXRlZFxuICovXG5mdW5jdGlvbiB1cGRhdGVBbGxFeHByZXNzaW9ucyhleHByZXNzaW9ucykge1xuICBlYWNoKGV4cHJlc3Npb25zLCB1cGRhdGVFeHByZXNzaW9uLmJpbmQodGhpcykpO1xufVxuXG52YXIgSWZFeHByID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbSwgdGFnLCBleHByKSB7XG4gICAgcmVtQXR0cihkb20sIENPTkRJVElPTkFMX0RJUkVDVElWRSk7XG4gICAgdGhpcy50YWcgPSB0YWc7XG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgICB0aGlzLnN0dWIgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgdGhpcy5wcmlzdGluZSA9IGRvbTtcblxuICAgIHZhciBwID0gZG9tLnBhcmVudE5vZGU7XG4gICAgcC5pbnNlcnRCZWZvcmUodGhpcy5zdHViLCBkb20pO1xuICAgIHAucmVtb3ZlQ2hpbGQoZG9tKTtcblxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHRoaXMudmFsdWUgPSB0bXBsKHRoaXMuZXhwciwgdGhpcy50YWcpO1xuXG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIXRoaXMuY3VycmVudCkgeyAvLyBpbnNlcnRcbiAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMucHJpc3RpbmUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdGhpcy5zdHViLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY3VycmVudCwgdGhpcy5zdHViKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgIHBhcnNlRXhwcmVzc2lvbnMuYXBwbHkodGhpcy50YWcsIFt0aGlzLmN1cnJlbnQsIHRoaXMuZXhwcmVzc2lvbnMsIHRydWVdKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnZhbHVlICYmIHRoaXMuY3VycmVudCkgeyAvLyByZW1vdmVcbiAgICAgIHVubW91bnRBbGwodGhpcy5leHByZXNzaW9ucyk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Ll90YWcpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Ll90YWcudW5tb3VudCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZSkgeyB1cGRhdGVBbGxFeHByZXNzaW9ucy5jYWxsKHRoaXMudGFnLCB0aGlzLmV4cHJlc3Npb25zKTsgfVxuICB9LFxuICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIHVubW91bnRBbGwodGhpcy5leHByZXNzaW9ucyB8fCBbXSk7XG4gICAgZGVsZXRlIHRoaXMucHJpc3RpbmU7XG4gICAgZGVsZXRlIHRoaXMucGFyZW50Tm9kZTtcbiAgICBkZWxldGUgdGhpcy5zdHViO1xuICB9XG59O1xuXG52YXIgUmVmRXhwciA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChkb20sIHBhcmVudCwgYXR0ck5hbWUsIGF0dHJWYWx1ZSkge1xuICAgIHRoaXMuZG9tID0gZG9tO1xuICAgIHRoaXMuYXR0ciA9IGF0dHJOYW1lO1xuICAgIHRoaXMucmF3VmFsdWUgPSBhdHRyVmFsdWU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5oYXNFeHAgPSB0bXBsLmhhc0V4cHIoYXR0clZhbHVlKTtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgb2xkID0gdGhpcy52YWx1ZTtcbiAgICB2YXIgY3VzdG9tUGFyZW50ID0gdGhpcy5wYXJlbnQgJiYgZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnKHRoaXMucGFyZW50KTtcbiAgICAvLyBpZiB0aGUgcmVmZXJlbmNlZCBlbGVtZW50IGlzIGEgY3VzdG9tIHRhZywgdGhlbiB3ZSBzZXQgdGhlIHRhZyBpdHNlbGYsIHJhdGhlciB0aGFuIERPTVxuICAgIHZhciB0YWdPckRvbSA9IHRoaXMudGFnIHx8IHRoaXMuZG9tO1xuXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuaGFzRXhwID8gdG1wbCh0aGlzLnJhd1ZhbHVlLCB0aGlzLnBhcmVudCkgOiB0aGlzLnJhd1ZhbHVlO1xuXG4gICAgLy8gdGhlIG5hbWUgY2hhbmdlZCwgc28gd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgb2xkIGtleSAoaWYgcHJlc2VudClcbiAgICBpZiAoIWlzQmxhbmsob2xkKSAmJiBjdXN0b21QYXJlbnQpIHsgYXJyYXlpc2hSZW1vdmUoY3VzdG9tUGFyZW50LnJlZnMsIG9sZCwgdGFnT3JEb20pOyB9XG5cbiAgICBpZiAoaXNCbGFuayh0aGlzLnZhbHVlKSkge1xuICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGJsYW5rLCB3ZSByZW1vdmUgaXRcbiAgICAgIHJlbUF0dHIodGhpcy5kb20sIHRoaXMuYXR0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgcmVmcyBvZiBwYXJlbnQgdGFnICh0aGlzIGJlaGF2aW9yIHdhcyBjaGFuZ2VkID49My4wKVxuICAgICAgaWYgKGN1c3RvbVBhcmVudCkgeyBhcnJheWlzaEFkZChcbiAgICAgICAgY3VzdG9tUGFyZW50LnJlZnMsXG4gICAgICAgIHRoaXMudmFsdWUsXG4gICAgICAgIHRhZ09yRG9tLFxuICAgICAgICAvLyB1c2UgYW4gYXJyYXkgaWYgaXQncyBhIGxvb3BlZCBub2RlIGFuZCB0aGUgcmVmIGlzIG5vdCBhbiBleHByZXNzaW9uXG4gICAgICAgIG51bGwsXG4gICAgICAgIHRoaXMucGFyZW50Ll9fLmluZGV4XG4gICAgICApOyB9XG4gICAgICAvLyBzZXQgdGhlIGFjdHVhbCBET00gYXR0clxuICAgICAgc2V0QXR0cih0aGlzLmRvbSwgdGhpcy5hdHRyLCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG4gIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgdmFyIHRhZ09yRG9tID0gdGhpcy50YWcgfHwgdGhpcy5kb207XG4gICAgdmFyIGN1c3RvbVBhcmVudCA9IHRoaXMucGFyZW50ICYmIGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudFRhZyh0aGlzLnBhcmVudCk7XG4gICAgaWYgKCFpc0JsYW5rKHRoaXMudmFsdWUpICYmIGN1c3RvbVBhcmVudClcbiAgICAgIHsgYXJyYXlpc2hSZW1vdmUoY3VzdG9tUGFyZW50LnJlZnMsIHRoaXMudmFsdWUsIHRhZ09yRG9tKTsgfVxuICAgIGRlbGV0ZSB0aGlzLmRvbTtcbiAgICBkZWxldGUgdGhpcy5wYXJlbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgaXRlbSBsb29wZWQgaW50byBhbiBvYmplY3QgdXNlZCB0byBleHRlbmQgdGhlIGNoaWxkIHRhZyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGV4cHIgLSBvYmplY3QgY29udGFpbmluZyB0aGUga2V5cyB1c2VkIHRvIGV4dGVuZCB0aGUgY2hpbGRyZW4gdGFnc1xuICogQHBhcmFtICAgeyAqIH0ga2V5IC0gdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBuZXcgb2JqZWN0IHJldHVybmVkXG4gKiBAcGFyYW0gICB7ICogfSB2YWwgLSB2YWx1ZSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gYmFzZSAtIHByb3RvdHlwZSBvYmplY3QgZm9yIHRoZSBuZXcgaXRlbVxuICogQHJldHVybnMgeyBPYmplY3QgfSAtIG5ldyBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCBpdGVtXG4gKlxuICogVGhlIHZhcmlhYmxlcyAna2V5JyBhbmQgJ3ZhbCcgYXJlIGFyYml0cmFyeS5cbiAqIFRoZXkgZGVwZW5kIG9uIHRoZSBjb2xsZWN0aW9uIHR5cGUgbG9vcGVkIChBcnJheSwgT2JqZWN0KVxuICogYW5kIG9uIHRoZSBleHByZXNzaW9uIHVzZWQgb24gdGhlIGVhY2ggdGFnXG4gKlxuICovXG5mdW5jdGlvbiBta2l0ZW0oZXhwciwga2V5LCB2YWwsIGJhc2UpIHtcbiAgdmFyIGl0ZW0gPSBiYXNlID8gT2JqZWN0LmNyZWF0ZShiYXNlKSA6IHt9O1xuICBpdGVtW2V4cHIua2V5XSA9IGtleTtcbiAgaWYgKGV4cHIucG9zKSB7IGl0ZW1bZXhwci5wb3NdID0gdmFsOyB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qKlxuICogVW5tb3VudCB0aGUgcmVkdW5kYW50IHRhZ3NcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBpdGVtcyAtIGFycmF5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgaXRlbXMgdG8gbG9vcFxuICogQHBhcmFtICAgeyBBcnJheSB9IHRhZ3MgLSBhcnJheSBjb250YWluaW5nIGFsbCB0aGUgY2hpbGRyZW4gdGFnc1xuICovXG5mdW5jdGlvbiB1bm1vdW50UmVkdW5kYW50KGl0ZW1zLCB0YWdzKSB7XG4gIHZhciBpID0gdGFncy5sZW5ndGgsXG4gICAgaiA9IGl0ZW1zLmxlbmd0aDtcblxuICB3aGlsZSAoaSA+IGopIHtcbiAgICBpLS07XG4gICAgcmVtb3ZlLmFwcGx5KHRhZ3NbaV0sIFt0YWdzLCBpXSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIHRhZ1xuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gdGFncyAtIHRhZ3MgY29sbGVjdGlvblxuICogQHBhcmFtICAgeyBOdW1iZXIgfSBpIC0gaW5kZXggb2YgdGhlIHRhZyB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKHRhZ3MsIGkpIHtcbiAgdGFncy5zcGxpY2UoaSwgMSk7XG4gIHRoaXMudW5tb3VudCgpO1xuICBhcnJheWlzaFJlbW92ZSh0aGlzLnBhcmVudCwgdGhpcywgdGhpcy5fXy50YWdOYW1lLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBNb3ZlIHRoZSBuZXN0ZWQgY3VzdG9tIHRhZ3MgaW4gbm9uIGN1c3RvbSBsb29wIHRhZ3NcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtICAgeyBOdW1iZXIgfSBpIC0gY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgbG9vcCB0YWdcbiAqL1xuZnVuY3Rpb24gbW92ZU5lc3RlZFRhZ3MoaSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBlYWNoKE9iamVjdC5rZXlzKHRoaXMudGFncyksIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgbW92ZUNoaWxkVGFnLmFwcGx5KHRoaXMkMS50YWdzW3RhZ05hbWVdLCBbdGFnTmFtZSwgaV0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBNb3ZlIGEgY2hpbGQgdGFnXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSAgIHsgSFRNTEVsZW1lbnQgfSByb290IC0gZG9tIG5vZGUgY29udGFpbmluZyBhbGwgdGhlIGxvb3AgY2hpbGRyZW5cbiAqIEBwYXJhbSAgIHsgVGFnIH0gbmV4dFRhZyAtIGluc3RhbmNlIG9mIHRoZSBuZXh0IHRhZyBwcmVjZWRpbmcgdGhlIG9uZSB3ZSB3YW50IHRvIG1vdmVcbiAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzVmlydHVhbCAtIGlzIGl0IGEgdmlydHVhbCB0YWc/XG4gKi9cbmZ1bmN0aW9uIG1vdmUocm9vdCwgbmV4dFRhZywgaXNWaXJ0dWFsKSB7XG4gIGlmIChpc1ZpcnR1YWwpXG4gICAgeyBtb3ZlVmlydHVhbC5hcHBseSh0aGlzLCBbcm9vdCwgbmV4dFRhZ10pOyB9XG4gIGVsc2VcbiAgICB7IHNhZmVJbnNlcnQocm9vdCwgdGhpcy5yb290LCBuZXh0VGFnLnJvb3QpOyB9XG59XG5cbi8qKlxuICogSW5zZXJ0IGFuZCBtb3VudCBhIGNoaWxkIHRhZ1xuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gcm9vdCAtIGRvbSBub2RlIGNvbnRhaW5pbmcgYWxsIHRoZSBsb29wIGNoaWxkcmVuXG4gKiBAcGFyYW0gICB7IFRhZyB9IG5leHRUYWcgLSBpbnN0YW5jZSBvZiB0aGUgbmV4dCB0YWcgcHJlY2VkaW5nIHRoZSBvbmUgd2Ugd2FudCB0byBpbnNlcnRcbiAqIEBwYXJhbSAgIHsgQm9vbGVhbiB9IGlzVmlydHVhbCAtIGlzIGl0IGEgdmlydHVhbCB0YWc/XG4gKi9cbmZ1bmN0aW9uIGluc2VydChyb290LCBuZXh0VGFnLCBpc1ZpcnR1YWwpIHtcbiAgaWYgKGlzVmlydHVhbClcbiAgICB7IG1ha2VWaXJ0dWFsLmFwcGx5KHRoaXMsIFtyb290LCBuZXh0VGFnXSk7IH1cbiAgZWxzZVxuICAgIHsgc2FmZUluc2VydChyb290LCB0aGlzLnJvb3QsIG5leHRUYWcucm9vdCk7IH1cbn1cblxuLyoqXG4gKiBBcHBlbmQgYSBuZXcgdGFnIGludG8gdGhlIERPTVxuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gcm9vdCAtIGRvbSBub2RlIGNvbnRhaW5pbmcgYWxsIHRoZSBsb29wIGNoaWxkcmVuXG4gKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBpc1ZpcnR1YWwgLSBpcyBpdCBhIHZpcnR1YWwgdGFnP1xuICovXG5mdW5jdGlvbiBhcHBlbmQocm9vdCwgaXNWaXJ0dWFsKSB7XG4gIGlmIChpc1ZpcnR1YWwpXG4gICAgeyBtYWtlVmlydHVhbC5jYWxsKHRoaXMsIHJvb3QpOyB9XG4gIGVsc2VcbiAgICB7IHJvb3QuYXBwZW5kQ2hpbGQodGhpcy5yb290KTsgfVxufVxuXG4vKipcbiAqIE1hbmFnZSB0YWdzIGhhdmluZyB0aGUgJ2VhY2gnXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gZG9tIC0gRE9NIG5vZGUgd2UgbmVlZCB0byBsb29wXG4gKiBAcGFyYW0gICB7IFRhZyB9IHBhcmVudCAtIHBhcmVudCB0YWcgaW5zdGFuY2Ugd2hlcmUgdGhlIGRvbSBub2RlIGlzIGNvbnRhaW5lZFxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBleHByIC0gc3RyaW5nIGNvbnRhaW5lZCBpbiB0aGUgJ2VhY2gnIGF0dHJpYnV0ZVxuICogQHJldHVybnMgeyBPYmplY3QgfSBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBlYWNoIGxvb3BcbiAqL1xuZnVuY3Rpb24gX2VhY2goZG9tLCBwYXJlbnQsIGV4cHIpIHtcblxuICAvLyByZW1vdmUgdGhlIGVhY2ggcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgdGFnXG4gIHJlbUF0dHIoZG9tLCBMT09QX0RJUkVDVElWRSk7XG5cbiAgdmFyIG11c3RSZW9yZGVyID0gdHlwZW9mIGdldEF0dHIoZG9tLCBMT09QX05PX1JFT1JERVJfRElSRUNUSVZFKSAhPT0gVF9TVFJJTkcgfHwgcmVtQXR0cihkb20sIExPT1BfTk9fUkVPUkRFUl9ESVJFQ1RJVkUpLFxuICAgIHRhZ05hbWUgPSBnZXRUYWdOYW1lKGRvbSksXG4gICAgaW1wbCA9IF9fVEFHX0lNUExbdGFnTmFtZV0sXG4gICAgcGFyZW50Tm9kZSA9IGRvbS5wYXJlbnROb2RlLFxuICAgIHBsYWNlaG9sZGVyID0gY3JlYXRlRE9NUGxhY2Vob2xkZXIoKSxcbiAgICBjaGlsZCA9IGdldFRhZyhkb20pLFxuICAgIGlmRXhwciA9IGdldEF0dHIoZG9tLCBDT05ESVRJT05BTF9ESVJFQ1RJVkUpLFxuICAgIHRhZ3MgPSBbXSxcbiAgICBvbGRJdGVtcyA9IFtdLFxuICAgIGhhc0tleXMsXG4gICAgaXNMb29wID0gdHJ1ZSxcbiAgICBpc0Fub255bW91cyA9ICFfX1RBR19JTVBMW3RhZ05hbWVdLFxuICAgIGlzVmlydHVhbCA9IGRvbS50YWdOYW1lID09PSAnVklSVFVBTCc7XG5cbiAgLy8gcGFyc2UgdGhlIGVhY2ggZXhwcmVzc2lvblxuICBleHByID0gdG1wbC5sb29wS2V5cyhleHByKTtcbiAgZXhwci5pc0xvb3AgPSB0cnVlO1xuXG4gIGlmIChpZkV4cHIpIHsgcmVtQXR0cihkb20sIENPTkRJVElPTkFMX0RJUkVDVElWRSk7IH1cblxuICAvLyBpbnNlcnQgYSBtYXJrZWQgd2hlcmUgdGhlIGxvb3AgdGFncyB3aWxsIGJlIGluamVjdGVkXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyLCBkb20pO1xuICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG5cbiAgZXhwci51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGVFYWNoKCkge1xuICAgIC8vIGdldCB0aGUgbmV3IGl0ZW1zIGNvbGxlY3Rpb25cbiAgICBleHByLnZhbHVlID0gdG1wbChleHByLnZhbCwgcGFyZW50KTtcblxuICAgIHZhciBmcmFnID0gY3JlYXRlRnJhZygpLFxuICAgICAgaXRlbXMgPSBleHByLnZhbHVlLFxuICAgICAgaXNPYmplY3QkJDEgPSAhaXNBcnJheShpdGVtcykgJiYgIWlzU3RyaW5nKGl0ZW1zKSxcbiAgICAgIHJvb3QgPSBwbGFjZWhvbGRlci5wYXJlbnROb2RlO1xuXG4gICAgLy8gb2JqZWN0IGxvb3AuIGFueSBjaGFuZ2VzIGNhdXNlIGZ1bGwgcmVkcmF3XG4gICAgaWYgKGlzT2JqZWN0JCQxKSB7XG4gICAgICBoYXNLZXlzID0gaXRlbXMgfHwgZmFsc2U7XG4gICAgICBpdGVtcyA9IGhhc0tleXMgP1xuICAgICAgICBPYmplY3Qua2V5cyhpdGVtcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbWtpdGVtKGV4cHIsIGl0ZW1zW2tleV0sIGtleSlcbiAgICAgICAgfSkgOiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzS2V5cyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpZkV4cHIpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICAgICAgaWYgKGV4cHIua2V5ICYmICFpc09iamVjdCQkMSlcbiAgICAgICAgICB7IHJldHVybiAhIXRtcGwoaWZFeHByLCBta2l0ZW0oZXhwciwgaXRlbSwgaSwgcGFyZW50KSkgfVxuXG4gICAgICAgIHJldHVybiAhIXRtcGwoaWZFeHByLCBleHRlbmQoT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCBpdGVtKSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGxvb3AgYWxsIHRoZSBuZXcgaXRlbXNcbiAgICBlYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgICAvLyByZW9yZGVyIG9ubHkgaWYgdGhlIGl0ZW1zIGFyZSBvYmplY3RzXG4gICAgICB2YXJcbiAgICAgICAgZG9SZW9yZGVyID0gbXVzdFJlb3JkZXIgJiYgdHlwZW9mIGl0ZW0gPT09IFRfT0JKRUNUICYmICFoYXNLZXlzLFxuICAgICAgICBvbGRQb3MgPSBvbGRJdGVtcy5pbmRleE9mKGl0ZW0pLFxuICAgICAgICBpc05ldyA9IG9sZFBvcyA9PT0gLTEsXG4gICAgICAgIHBvcyA9ICFpc05ldyAmJiBkb1Jlb3JkZXIgPyBvbGRQb3MgOiBpLFxuICAgICAgICAvLyBkb2VzIGEgdGFnIGV4aXN0IGluIHRoaXMgcG9zaXRpb24/XG4gICAgICAgIHRhZyA9IHRhZ3NbcG9zXSxcbiAgICAgICAgbXVzdEFwcGVuZCA9IGkgPj0gb2xkSXRlbXMubGVuZ3RoLFxuICAgICAgICBtdXN0Q3JlYXRlID0gIGRvUmVvcmRlciAmJiBpc05ldyB8fCAhZG9SZW9yZGVyICYmICF0YWc7XG5cbiAgICAgIGl0ZW0gPSAhaGFzS2V5cyAmJiBleHByLmtleSA/IG1raXRlbShleHByLCBpdGVtLCBpKSA6IGl0ZW07XG5cbiAgICAgIC8vIG5ldyB0YWdcbiAgICAgIGlmIChtdXN0Q3JlYXRlKSB7XG4gICAgICAgIHRhZyA9IG5ldyBUYWckMShpbXBsLCB7XG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgaXNMb29wOiBpc0xvb3AsXG4gICAgICAgICAgaXNBbm9ueW1vdXM6IGlzQW5vbnltb3VzLFxuICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgcm9vdDogZG9tLmNsb25lTm9kZShpc0Fub255bW91cyksXG4gICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgfSwgZG9tLmlubmVySFRNTCk7XG5cbiAgICAgICAgLy8gbW91bnQgdGhlIHRhZ1xuICAgICAgICB0YWcubW91bnQoKTtcblxuICAgICAgICBpZiAobXVzdEFwcGVuZClcbiAgICAgICAgICB7IGFwcGVuZC5hcHBseSh0YWcsIFtmcmFnIHx8IHJvb3QsIGlzVmlydHVhbF0pOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IGluc2VydC5hcHBseSh0YWcsIFtyb290LCB0YWdzW2ldLCBpc1ZpcnR1YWxdKTsgfVxuXG4gICAgICAgIGlmICghbXVzdEFwcGVuZCkgeyBvbGRJdGVtcy5zcGxpY2UoaSwgMCwgaXRlbSk7IH1cbiAgICAgICAgdGFncy5zcGxpY2UoaSwgMCwgdGFnKTtcbiAgICAgICAgaWYgKGNoaWxkKSB7IGFycmF5aXNoQWRkKHBhcmVudC50YWdzLCB0YWdOYW1lLCB0YWcsIHRydWUpOyB9XG4gICAgICB9IGVsc2UgaWYgKHBvcyAhPT0gaSAmJiBkb1Jlb3JkZXIpIHtcbiAgICAgICAgLy8gbW92ZVxuICAgICAgICBpZiAoY29udGFpbnMoaXRlbXMsIG9sZEl0ZW1zW3Bvc10pKSB7XG4gICAgICAgICAgbW92ZS5hcHBseSh0YWcsIFtyb290LCB0YWdzW2ldLCBpc1ZpcnR1YWxdKTtcbiAgICAgICAgICAvLyBtb3ZlIHRoZSBvbGQgdGFnIGluc3RhbmNlXG4gICAgICAgICAgdGFncy5zcGxpY2UoaSwgMCwgdGFncy5zcGxpY2UocG9zLCAxKVswXSk7XG4gICAgICAgICAgLy8gbW92ZSB0aGUgb2xkIGl0ZW1cbiAgICAgICAgICBvbGRJdGVtcy5zcGxpY2UoaSwgMCwgb2xkSXRlbXMuc3BsaWNlKHBvcywgMSlbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb3NpdGlvbiBhdHRyaWJ1dGUgaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmIChleHByLnBvcykgeyB0YWdbZXhwci5wb3NdID0gaTsgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBsb29wIHRhZ3MgYXJlIG5vdCBjdXN0b21cbiAgICAgICAgLy8gd2UgbmVlZCB0byBtb3ZlIGFsbCB0aGVpciBjdXN0b20gdGFncyBpbnRvIHRoZSByaWdodCBwb3NpdGlvblxuICAgICAgICBpZiAoIWNoaWxkICYmIHRhZy50YWdzKSB7IG1vdmVOZXN0ZWRUYWdzLmNhbGwodGFnLCBpKTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBjYWNoZSB0aGUgb3JpZ2luYWwgaXRlbSB0byB1c2UgaXQgaW4gdGhlIGV2ZW50cyBib3VuZCB0byB0aGlzIG5vZGVcbiAgICAgIC8vIGFuZCBpdHMgY2hpbGRyZW5cbiAgICAgIHRhZy5fXy5pdGVtID0gaXRlbTtcbiAgICAgIHRhZy5fXy5pbmRleCA9IGk7XG4gICAgICB0YWcuX18ucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICBpZiAoIW11c3RDcmVhdGUpIHsgdGFnLnVwZGF0ZShpdGVtKTsgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIHRoZSByZWR1bmRhbnQgdGFnc1xuICAgIHVubW91bnRSZWR1bmRhbnQoaXRlbXMsIHRhZ3MpO1xuXG4gICAgLy8gY2xvbmUgdGhlIGl0ZW1zIGFycmF5XG4gICAgb2xkSXRlbXMgPSBpdGVtcy5zbGljZSgpO1xuXG4gICAgcm9vdC5pbnNlcnRCZWZvcmUoZnJhZywgcGxhY2Vob2xkZXIpO1xuICB9O1xuXG4gIGV4cHIudW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgIGVhY2godGFncywgZnVuY3Rpb24odCkgeyB0LnVubW91bnQoKTsgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGV4cHJcbn1cblxuLyoqXG4gKiBXYWxrIHRoZSB0YWcgRE9NIHRvIGRldGVjdCB0aGUgZXhwcmVzc2lvbnMgdG8gZXZhbHVhdGVcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtICAgeyBIVE1MRWxlbWVudCB9IHJvb3QgLSByb290IHRhZyB3aGVyZSB3ZSB3aWxsIHN0YXJ0IGRpZ2dpbmcgdGhlIGV4cHJlc3Npb25zXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gZXhwcmVzc2lvbnMgLSBlbXB0eSBhcnJheSB3aGVyZSB0aGUgZXhwcmVzc2lvbnMgd2lsbCBiZSBhZGRlZFxuICogQHBhcmFtICAgeyBCb29sZWFuIH0gbXVzdEluY2x1ZGVSb290IC0gZmxhZyB0byBkZWNpZGUgd2hldGhlciB0aGUgcm9vdCBtdXN0IGJlIHBhcnNlZCBhcyB3ZWxsXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByb290IG5vb2RlIGFuZCB0aGUgZG9tIHRyZWVcbiAqL1xuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9ucyhyb290LCBleHByZXNzaW9ucywgbXVzdEluY2x1ZGVSb290KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0cmVlID0ge3BhcmVudDoge2NoaWxkcmVuOiBleHByZXNzaW9uc319O1xuXG4gIHdhbGtOb2Rlcyhyb290LCBmdW5jdGlvbiAoZG9tLCBjdHgpIHtcbiAgICB2YXIgdHlwZSA9IGRvbS5ub2RlVHlwZSwgcGFyZW50ID0gY3R4LnBhcmVudCwgYXR0ciwgZXhwciwgdGFnSW1wbDtcbiAgICBpZiAoIW11c3RJbmNsdWRlUm9vdCAmJiBkb20gPT09IHJvb3QpIHsgcmV0dXJuIHtwYXJlbnQ6IHBhcmVudH0gfVxuXG4gICAgLy8gdGV4dCBub2RlXG4gICAgaWYgKHR5cGUgPT09IDMgJiYgZG9tLnBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ1NUWUxFJyAmJiB0bXBsLmhhc0V4cHIoZG9tLm5vZGVWYWx1ZSkpXG4gICAgICB7IHBhcmVudC5jaGlsZHJlbi5wdXNoKHtkb206IGRvbSwgZXhwcjogZG9tLm5vZGVWYWx1ZX0pOyB9XG5cbiAgICBpZiAodHlwZSAhPT0gMSkgeyByZXR1cm4gY3R4IH0gLy8gbm90IGFuIGVsZW1lbnRcblxuICAgIHZhciBpc1ZpcnR1YWwgPSBkb20udGFnTmFtZSA9PT0gJ1ZJUlRVQUwnO1xuXG4gICAgLy8gbG9vcC4gZWFjaCBkb2VzIGl0J3Mgb3duIHRoaW5nIChmb3Igbm93KVxuICAgIGlmIChhdHRyID0gZ2V0QXR0cihkb20sIExPT1BfRElSRUNUSVZFKSkge1xuICAgICAgaWYoaXNWaXJ0dWFsKSB7IHNldEF0dHIoZG9tLCAnbG9vcFZpcnR1YWwnLCB0cnVlKTsgfSAvLyBpZ25vcmUgaGVyZSwgaGFuZGxlZCBpbiBfZWFjaFxuICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goX2VhY2goZG9tLCB0aGlzJDEsIGF0dHIpKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIGlmLWF0dHJzIGJlY29tZSB0aGUgbmV3IHBhcmVudC4gQW55IGZvbGxvd2luZyBleHByZXNzaW9ucyAoZWl0aGVyIG9uIHRoZSBjdXJyZW50XG4gICAgLy8gZWxlbWVudCwgb3IgYmVsb3cgaXQpIGJlY29tZSBjaGlsZHJlbiBvZiB0aGlzIGV4cHJlc3Npb24uXG4gICAgaWYgKGF0dHIgPSBnZXRBdHRyKGRvbSwgQ09ORElUSU9OQUxfRElSRUNUSVZFKSkge1xuICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goT2JqZWN0LmNyZWF0ZShJZkV4cHIpLmluaXQoZG9tLCB0aGlzJDEsIGF0dHIpKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChleHByID0gZ2V0QXR0cihkb20sIElTX0RJUkVDVElWRSkpIHtcbiAgICAgIGlmICh0bXBsLmhhc0V4cHIoZXhwcikpIHtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goe2lzUnRhZzogdHJ1ZSwgZXhwcjogZXhwciwgZG9tOiBkb20sIGF0dHJzOiBbXS5zbGljZS5jYWxsKGRvbS5hdHRyaWJ1dGVzKX0pO1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgdGFnLCBzdG9wIHRyYXZlcnNpbmcgaGVyZS5cbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHJvb3QsIHNpbmNlIHBhcnNlRXhwcmVzc2lvbnMgaXMgY2FsbGVkIHdoaWxlIHdlJ3JlIG1vdW50aW5nIHRoYXQgcm9vdFxuICAgIHRhZ0ltcGwgPSBnZXRUYWcoZG9tKTtcbiAgICBpZihpc1ZpcnR1YWwpIHtcbiAgICAgIGlmKGdldEF0dHIoZG9tLCAndmlydHVhbGl6ZWQnKSkge2RvbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGRvbSk7IH0gLy8gdGFnIGNyZWF0ZWQsIHJlbW92ZSBmcm9tIGRvbVxuICAgICAgaWYoIXRhZ0ltcGwgJiYgIWdldEF0dHIoZG9tLCAndmlydHVhbGl6ZWQnKSAmJiAhZ2V0QXR0cihkb20sICdsb29wVmlydHVhbCcpKSAgLy8gb2sgdG8gY3JlYXRlIHZpcnR1YWwgdGFnXG4gICAgICAgIHsgdGFnSW1wbCA9IHsgdG1wbDogZG9tLm91dGVySFRNTCB9OyB9XG4gICAgfVxuXG4gICAgaWYgKHRhZ0ltcGwgJiYgKGRvbSAhPT0gcm9vdCB8fCBtdXN0SW5jbHVkZVJvb3QpKSB7XG4gICAgICBpZihpc1ZpcnR1YWwgJiYgIWdldEF0dHIoZG9tLCBJU19ESVJFQ1RJVkUpKSB7IC8vIGhhbmRsZWQgaW4gdXBkYXRlXG4gICAgICAgIC8vIGNhbiBub3QgcmVtb3ZlIGF0dHJpYnV0ZSBsaWtlIGRpcmVjdGl2ZXNcbiAgICAgICAgLy8gc28gZmxhZyBmb3IgcmVtb3ZhbCBhZnRlciBjcmVhdGlvbiB0byBwcmV2ZW50IG1heGltdW0gc3RhY2sgZXJyb3JcbiAgICAgICAgc2V0QXR0cihkb20sICd2aXJ0dWFsaXplZCcsIHRydWUpO1xuXG4gICAgICAgIHZhciB0YWcgPSBuZXcgVGFnJDEoeyB0bXBsOiBkb20ub3V0ZXJIVE1MIH0sXG4gICAgICAgICAge3Jvb3Q6IGRvbSwgcGFyZW50OiB0aGlzJDF9LFxuICAgICAgICAgIGRvbS5pbm5lckhUTUwpO1xuICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaCh0YWcpOyAvLyBubyByZXR1cm4sIGFub255bW91cyB0YWcsIGtlZXAgcGFyc2luZ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbmYgPSB7cm9vdDogZG9tLCBwYXJlbnQ6IHRoaXMkMSwgaGFzSW1wbDogdHJ1ZX07XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKGluaXRDaGlsZFRhZyh0YWdJbXBsLCBjb25mLCBkb20uaW5uZXJIVE1MLCB0aGlzJDEpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXR0cmlidXRlIGV4cHJlc3Npb25zXG4gICAgcGFyc2VBdHRyaWJ1dGVzLmFwcGx5KHRoaXMkMSwgW2RvbSwgZG9tLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGF0dHIsIGV4cHIpIHtcbiAgICAgIGlmICghZXhwcikgeyByZXR1cm4gfVxuICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goZXhwcik7XG4gICAgfV0pO1xuXG4gICAgLy8gd2hhdGV2ZXIgdGhlIHBhcmVudCBpcywgYWxsIGNoaWxkIGVsZW1lbnRzIGdldCB0aGUgc2FtZSBwYXJlbnQuXG4gICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhZCBhbiBpZi1hdHRyLCB0aGF0J3MgdGhlIHBhcmVudCBmb3IgYWxsIGNoaWxkIGVsZW1lbnRzXG4gICAgcmV0dXJuIHtwYXJlbnQ6IHBhcmVudH1cbiAgfSwgdHJlZSk7XG59XG5cbi8qKlxuICogQ2FsbHMgYGZuYCBmb3IgZXZlcnkgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQuIElmIHRoYXQgYXR0ciBoYXMgYW4gZXhwcmVzc2lvbixcbiAqIGl0IGlzIGFsc28gcGFzc2VkIHRvIGZuLlxuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0gICB7IEhUTUxFbGVtZW50IH0gZG9tIC0gZG9tIG5vZGUgdG8gcGFyc2VcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBhdHRycyAtIGFycmF5IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSAgIHsgRnVuY3Rpb24gfSBmbiAtIGNhbGxiYWNrIHRvIGV4ZWMgb24gYW55IGl0ZXJhdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoZG9tLCBhdHRycywgZm4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZWFjaChhdHRycywgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICB2YXIgbmFtZSA9IGF0dHIubmFtZSwgYm9vbCA9IGlzQm9vbEF0dHIobmFtZSksIGV4cHI7XG5cbiAgICBpZiAoY29udGFpbnMoUkVGX0RJUkVDVElWRVMsIG5hbWUpKSB7XG4gICAgICBleHByID0gIE9iamVjdC5jcmVhdGUoUmVmRXhwcikuaW5pdChkb20sIHRoaXMkMSwgbmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0bXBsLmhhc0V4cHIoYXR0ci52YWx1ZSkpIHtcbiAgICAgIGV4cHIgPSB7ZG9tOiBkb20sIGV4cHI6IGF0dHIudmFsdWUsIGF0dHI6IG5hbWUsIGJvb2w6IGJvb2x9O1xuICAgIH1cblxuICAgIGZuKGF0dHIsIGV4cHIpO1xuICB9KTtcbn1cblxuLypcbiAgSW5jbHVkZXMgaGFja3MgbmVlZGVkIGZvciB0aGUgSW50ZXJuZXQgRXhwbG9yZXIgdmVyc2lvbiA5IGFuZCBiZWxvd1xuICBTZWU6IGh0dHA6Ly9rYW5nYXguZ2l0aHViLmlvL2NvbXBhdC10YWJsZS9lczUvI2llOFxuICAgICAgIGh0dHA6Ly9jb2RlcGxhbmV0LmlvL2Ryb3BwaW5nLWllOC9cbiovXG5cbnZhciByZUhhc1lpZWxkICA9IC88eWllbGRcXGIvaTtcbnZhciByZVlpZWxkQWxsICA9IC88eWllbGRcXHMqKD86XFwvPnw+KFtcXFNcXHNdKj8pPFxcL3lpZWxkXFxzKj58PikvaWc7XG52YXIgcmVZaWVsZFNyYyAgPSAvPHlpZWxkXFxzK3RvPVsnXCJdKFteJ1wiPl0qKVsnXCJdXFxzKj4oW1xcU1xcc10qPyk8XFwveWllbGRcXHMqPi9pZztcbnZhciByZVlpZWxkRGVzdCA9IC88eWllbGRcXHMrZnJvbT1bJ1wiXT8oWy1cXHddKylbJ1wiXT9cXHMqKD86XFwvPnw+KFtcXFNcXHNdKj8pPFxcL3lpZWxkXFxzKj4pL2lnO1xudmFyIHJvb3RFbHMgPSB7IHRyOiAndGJvZHknLCB0aDogJ3RyJywgdGQ6ICd0cicsIGNvbDogJ2NvbGdyb3VwJyB9O1xudmFyIHRibFRhZ3MgPSBJRV9WRVJTSU9OICYmIElFX1ZFUlNJT04gPCAxMCA/IFJFX1NQRUNJQUxfVEFHUyA6IFJFX1NQRUNJQUxfVEFHU19OT19PUFRJT047XG52YXIgR0VORVJJQyA9ICdkaXYnO1xuXG5cbi8qXG4gIENyZWF0ZXMgdGhlIHJvb3QgZWxlbWVudCBmb3IgdGFibGUgb3Igc2VsZWN0IGNoaWxkIGVsZW1lbnRzOlxuICB0ci90aC90ZC90aGVhZC90Zm9vdC90Ym9keS9jYXB0aW9uL2NvbC9jb2xncm91cC9vcHRpb24vb3B0Z3JvdXBcbiovXG5mdW5jdGlvbiBzcGVjaWFsVGFncyhlbCwgdG1wbCwgdGFnTmFtZSkge1xuXG4gIHZhclxuICAgIHNlbGVjdCA9IHRhZ05hbWVbMF0gPT09ICdvJyxcbiAgICBwYXJlbnQgPSBzZWxlY3QgPyAnc2VsZWN0PicgOiAndGFibGU+JztcblxuICAvLyB0cmltKCkgaXMgaW1wb3J0YW50IGhlcmUsIHRoaXMgZW5zdXJlcyB3ZSBkb24ndCBoYXZlIGFydGlmYWN0cyxcbiAgLy8gc28gd2UgY2FuIGNoZWNrIGlmIHdlIGhhdmUgb25seSBvbmUgZWxlbWVudCBpbnNpZGUgdGhlIHBhcmVudFxuICBlbC5pbm5lckhUTUwgPSAnPCcgKyBwYXJlbnQgKyB0bXBsLnRyaW0oKSArICc8LycgKyBwYXJlbnQ7XG4gIHBhcmVudCA9IGVsLmZpcnN0Q2hpbGQ7XG5cbiAgLy8gcmV0dXJucyB0aGUgaW1tZWRpYXRlIHBhcmVudCBpZiB0ci90aC90ZC9jb2wgaXMgdGhlIG9ubHkgZWxlbWVudCwgaWYgbm90XG4gIC8vIHJldHVybnMgdGhlIHdob2xlIHRyZWUsIGFzIHRoaXMgY2FuIGluY2x1ZGUgYWRkaXRpb25hbCBlbGVtZW50c1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoc2VsZWN0KSB7XG4gICAgcGFyZW50LnNlbGVjdGVkSW5kZXggPSAtMTsgIC8vIGZvciBJRTksIGNvbXBhdGlibGUgdy9jdXJyZW50IHJpb3QgYmVoYXZpb3JcbiAgfSBlbHNlIHtcbiAgICAvLyBhdm9pZHMgaW5zZXJ0aW9uIG9mIGNvaW50YWluZXIgaW5zaWRlIGNvbnRhaW5lciAoZXg6IHRib2R5IGluc2lkZSB0Ym9keSlcbiAgICB2YXIgdG5hbWUgPSByb290RWxzW3RhZ05hbWVdO1xuICAgIGlmICh0bmFtZSAmJiBwYXJlbnQuY2hpbGRFbGVtZW50Q291bnQgPT09IDEpIHsgcGFyZW50ID0gJCh0bmFtZSwgcGFyZW50KTsgfVxuICB9XG4gIHJldHVybiBwYXJlbnRcbn1cblxuLypcbiAgUmVwbGFjZSB0aGUgeWllbGQgdGFnIGZyb20gYW55IHRhZyB0ZW1wbGF0ZSB3aXRoIHRoZSBpbm5lckhUTUwgb2YgdGhlXG4gIG9yaWdpbmFsIHRhZyBpbiB0aGUgcGFnZVxuKi9cbmZ1bmN0aW9uIHJlcGxhY2VZaWVsZCh0bXBsLCBodG1sKSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgbm8geWllbGRcbiAgaWYgKCFyZUhhc1lpZWxkLnRlc3QodG1wbCkpIHsgcmV0dXJuIHRtcGwgfVxuXG4gIC8vIGJlIGNhcmVmdWwgd2l0aCAjMTM0MyAtIHN0cmluZyBvbiB0aGUgc291cmNlIGhhdmluZyBgJDFgXG4gIHZhciBzcmMgPSB7fTtcblxuICBodG1sID0gaHRtbCAmJiBodG1sLnJlcGxhY2UocmVZaWVsZFNyYywgZnVuY3Rpb24gKF8sIHJlZiwgdGV4dCkge1xuICAgIHNyY1tyZWZdID0gc3JjW3JlZl0gfHwgdGV4dDsgICAvLyBwcmVzZXJ2ZSBmaXJzdCBkZWZpbml0aW9uXG4gICAgcmV0dXJuICcnXG4gIH0pLnRyaW0oKTtcblxuICByZXR1cm4gdG1wbFxuICAgIC5yZXBsYWNlKHJlWWllbGREZXN0LCBmdW5jdGlvbiAoXywgcmVmLCBkZWYpIHsgIC8vIHlpZWxkIHdpdGggZnJvbSAtIHRvIGF0dHJzXG4gICAgICByZXR1cm4gc3JjW3JlZl0gfHwgZGVmIHx8ICcnXG4gICAgfSlcbiAgICAucmVwbGFjZShyZVlpZWxkQWxsLCBmdW5jdGlvbiAoXywgZGVmKSB7ICAgICAgICAvLyB5aWVsZCB3aXRob3V0IGFueSBcImZyb21cIlxuICAgICAgcmV0dXJuIGh0bWwgfHwgZGVmIHx8ICcnXG4gICAgfSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgdG8gd3JhcCB0aGUgZ2l2ZW4gY29udGVudC4gTm9ybWFsbHkgYW4gYERJVmAsIGJ1dCBjYW4gYmVcbiAqIGFsc28gYSBgVEFCTEVgLCBgU0VMRUNUYCwgYFRCT0RZYCwgYFRSYCwgb3IgYENPTEdST1VQYCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdG1wbCAgLSBUaGUgdGVtcGxhdGUgY29taW5nIGZyb20gdGhlIGN1c3RvbSB0YWcgZGVmaW5pdGlvblxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBodG1sIC0gSFRNTCBjb250ZW50IHRoYXQgY29tZXMgZnJvbSB0aGUgRE9NIGVsZW1lbnQgd2hlcmUgeW91XG4gKiAgICAgICAgICAgd2lsbCBtb3VudCB0aGUgdGFnLCBtb3N0bHkgdGhlIG9yaWdpbmFsIHRhZyBpbiB0aGUgcGFnZVxuICogQHJldHVybnMgeyBIVE1MRWxlbWVudCB9IERPTSBlbGVtZW50IHdpdGggX3RtcGxfIG1lcmdlZCB0aHJvdWdoIGBZSUVMRGAgd2l0aCB0aGUgX2h0bWxfLlxuICovXG5mdW5jdGlvbiBta2RvbSh0bXBsLCBodG1sKSB7XG4gIHZhciBtYXRjaCAgID0gdG1wbCAmJiB0bXBsLm1hdGNoKC9eXFxzKjwoWy1cXHddKykvKSxcbiAgICB0YWdOYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSxcbiAgICBlbCA9IG1rRWwoR0VORVJJQyk7XG5cbiAgLy8gcmVwbGFjZSBhbGwgdGhlIHlpZWxkIHRhZ3Mgd2l0aCB0aGUgdGFnIGlubmVyIGh0bWxcbiAgdG1wbCA9IHJlcGxhY2VZaWVsZCh0bXBsLCBodG1sKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAodGJsVGFncy50ZXN0KHRhZ05hbWUpKVxuICAgIHsgZWwgPSBzcGVjaWFsVGFncyhlbCwgdG1wbCwgdGFnTmFtZSk7IH1cbiAgZWxzZVxuICAgIHsgc2V0SW5uZXJIVE1MKGVsLCB0bXBsKTsgfVxuXG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIEFub3RoZXIgd2F5IHRvIGNyZWF0ZSBhIHJpb3QgdGFnIGEgYml0IG1vcmUgZXM2IGZyaWVuZGx5XG4gKiBAcGFyYW0geyBIVE1MRWxlbWVudCB9IGVsIC0gdGFnIERPTSBzZWxlY3RvciBvciBET00gbm9kZS9zXG4gKiBAcGFyYW0geyBPYmplY3QgfSBvcHRzIC0gdGFnIGxvZ2ljXG4gKiBAcmV0dXJucyB7IFRhZyB9IG5ldyByaW90IHRhZyBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBUYWckMihlbCwgb3B0cykge1xuICAvLyBnZXQgdGhlIHRhZyBwcm9wZXJ0aWVzIGZyb20gdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gIHZhciByZWYgPSB0aGlzO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICB2YXIgdG1wbCA9IHJlZi50bXBsO1xuICB2YXIgY3NzID0gcmVmLmNzcztcbiAgdmFyIGF0dHJzID0gcmVmLmF0dHJzO1xuICB2YXIgb25DcmVhdGUgPSByZWYub25DcmVhdGU7XG4gIC8vIHJlZ2lzdGVyIGEgbmV3IHRhZyBhbmQgY2FjaGUgdGhlIGNsYXNzIHByb3RvdHlwZVxuICBpZiAoIV9fVEFHX0lNUExbbmFtZV0pIHtcbiAgICB0YWckMShuYW1lLCB0bXBsLCBjc3MsIGF0dHJzLCBvbkNyZWF0ZSk7XG4gICAgLy8gY2FjaGUgdGhlIGNsYXNzIGNvbnN0cnVjdG9yXG4gICAgX19UQUdfSU1QTFtuYW1lXS5jbGFzcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gIH1cblxuICAvLyBtb3VudCB0aGUgdGFnIHVzaW5nIHRoZSBjbGFzcyBpbnN0YW5jZVxuICBtb3VudFRvKGVsLCBuYW1lLCBvcHRzLCB0aGlzKTtcbiAgLy8gaW5qZWN0IHRoZSBjb21wb25lbnQgY3NzXG4gIGlmIChjc3MpIHsgc3R5bGVNYW5hZ2VyLmluamVjdCgpOyB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcmlvdCB0YWcgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBuYW1lIC0gbmFtZS9pZCBvZiB0aGUgbmV3IHJpb3QgdGFnXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgdG1wbCAtIHRhZyB0ZW1wbGF0ZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGNzcyAtIGN1c3RvbSB0YWcgY3NzXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgYXR0cnMgLSByb290IHRhZyBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSB1c2VyIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7IFN0cmluZyB9IG5hbWUvaWQgb2YgdGhlIHRhZyBqdXN0IGNyZWF0ZWRcbiAqL1xuZnVuY3Rpb24gdGFnJDEobmFtZSwgdG1wbCwgY3NzLCBhdHRycywgZm4pIHtcbiAgaWYgKGlzRnVuY3Rpb24oYXR0cnMpKSB7XG4gICAgZm4gPSBhdHRycztcblxuICAgIGlmICgvXltcXHdcXC1dK1xccz89Ly50ZXN0KGNzcykpIHtcbiAgICAgIGF0dHJzID0gY3NzO1xuICAgICAgY3NzID0gJyc7XG4gICAgfSBlbHNlXG4gICAgICB7IGF0dHJzID0gJyc7IH1cbiAgfVxuXG4gIGlmIChjc3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjc3MpKVxuICAgICAgeyBmbiA9IGNzczsgfVxuICAgIGVsc2VcbiAgICAgIHsgc3R5bGVNYW5hZ2VyLmFkZChjc3MpOyB9XG4gIH1cblxuICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBfX1RBR19JTVBMW25hbWVdID0geyBuYW1lOiBuYW1lLCB0bXBsOiB0bXBsLCBhdHRyczogYXR0cnMsIGZuOiBmbiB9O1xuXG4gIHJldHVybiBuYW1lXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHJpb3QgdGFnIGltcGxlbWVudGF0aW9uIChmb3IgdXNlIGJ5IHRoZSBjb21waWxlcilcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gICBuYW1lIC0gbmFtZS9pZCBvZiB0aGUgbmV3IHJpb3QgdGFnXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgdG1wbCAtIHRhZyB0ZW1wbGF0ZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgIGNzcyAtIGN1c3RvbSB0YWcgY3NzXG4gKiBAcGFyYW0gICB7IFN0cmluZyB9ICAgYXR0cnMgLSByb290IHRhZyBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gICB7IEZ1bmN0aW9uIH0gZm4gLSB1c2VyIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7IFN0cmluZyB9IG5hbWUvaWQgb2YgdGhlIHRhZyBqdXN0IGNyZWF0ZWRcbiAqL1xuZnVuY3Rpb24gdGFnMiQxKG5hbWUsIHRtcGwsIGNzcywgYXR0cnMsIGZuKSB7XG4gIGlmIChjc3MpIHsgc3R5bGVNYW5hZ2VyLmFkZChjc3MsIG5hbWUpOyB9XG5cbiAgX19UQUdfSU1QTFtuYW1lXSA9IHsgbmFtZTogbmFtZSwgdG1wbDogdG1wbCwgYXR0cnM6IGF0dHJzLCBmbjogZm4gfTtcblxuICByZXR1cm4gbmFtZVxufVxuXG4vKipcbiAqIE1vdW50IGEgdGFnIHVzaW5nIGEgc3BlY2lmaWMgdGFnIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gICB7ICogfSBzZWxlY3RvciAtIHRhZyBET00gc2VsZWN0b3Igb3IgRE9NIG5vZGUvc1xuICogQHBhcmFtICAgeyBTdHJpbmcgfSB0YWdOYW1lIC0gdGFnIGltcGxlbWVudGF0aW9uIG5hbWVcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIHRhZyBsb2dpY1xuICogQHJldHVybnMgeyBBcnJheSB9IG5ldyB0YWdzIGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiBtb3VudCQyKHNlbGVjdG9yLCB0YWdOYW1lLCBvcHRzKSB7XG4gIHZhciB0YWdzID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFRhZ3NUbyhyb290KSB7XG4gICAgaWYgKHJvb3QudGFnTmFtZSkge1xuICAgICAgdmFyIHJpb3RUYWcgPSBnZXRBdHRyKHJvb3QsIElTX0RJUkVDVElWRSk7XG5cbiAgICAgIC8vIGhhdmUgdGFnTmFtZT8gZm9yY2UgcmlvdC10YWcgdG8gYmUgdGhlIHNhbWVcbiAgICAgIGlmICh0YWdOYW1lICYmIHJpb3RUYWcgIT09IHRhZ05hbWUpIHtcbiAgICAgICAgcmlvdFRhZyA9IHRhZ05hbWU7XG4gICAgICAgIHNldEF0dHIocm9vdCwgSVNfRElSRUNUSVZFLCB0YWdOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhZyA9IG1vdW50VG8ocm9vdCwgcmlvdFRhZyB8fCByb290LnRhZ05hbWUudG9Mb3dlckNhc2UoKSwgb3B0cyk7XG5cbiAgICAgIGlmICh0YWcpXG4gICAgICAgIHsgdGFncy5wdXNoKHRhZyk7IH1cbiAgICB9IGVsc2UgaWYgKHJvb3QubGVuZ3RoKVxuICAgICAgeyBlYWNoKHJvb3QsIHB1c2hUYWdzVG8pOyB9IC8vIGFzc3VtZSBub2RlTGlzdFxuICB9XG5cbiAgLy8gaW5qZWN0IHN0eWxlcyBpbnRvIERPTVxuICBzdHlsZU1hbmFnZXIuaW5qZWN0KCk7XG5cbiAgaWYgKGlzT2JqZWN0KHRhZ05hbWUpKSB7XG4gICAgb3B0cyA9IHRhZ05hbWU7XG4gICAgdGFnTmFtZSA9IDA7XG4gIH1cblxuICB2YXIgZWxlbTtcbiAgdmFyIGFsbFRhZ3M7XG5cbiAgLy8gY3Jhd2wgdGhlIERPTSB0byBmaW5kIHRoZSB0YWdcbiAgaWYgKGlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgPT09ICcqJyA/XG4gICAgICAvLyBzZWxlY3QgYWxsIHJlZ2lzdGVyZWQgdGFnc1xuICAgICAgLy8gJiB0YWdzIGZvdW5kIHdpdGggdGhlIHJpb3QtdGFnIGF0dHJpYnV0ZSBzZXRcbiAgICAgIGFsbFRhZ3MgPSBzZWxlY3RUYWdzKCkgOlxuICAgICAgLy8gb3IganVzdCB0aGUgb25lcyBuYW1lZCBsaWtlIHRoZSBzZWxlY3RvclxuICAgICAgc2VsZWN0b3IgKyBzZWxlY3RUYWdzKHNlbGVjdG9yLnNwbGl0KC8sICovKSk7XG5cbiAgICAvLyBtYWtlIHN1cmUgdG8gcGFzcyBhbHdheXMgYSBzZWxlY3RvclxuICAgIC8vIHRvIHRoZSBxdWVyeVNlbGVjdG9yQWxsIGZ1bmN0aW9uXG4gICAgZWxlbSA9IHNlbGVjdG9yID8gJCQoc2VsZWN0b3IpIDogW107XG4gIH1cbiAgZWxzZVxuICAgIC8vIHByb2JhYmx5IHlvdSBoYXZlIHBhc3NlZCBhbHJlYWR5IGEgdGFnIG9yIGEgTm9kZUxpc3RcbiAgICB7IGVsZW0gPSBzZWxlY3RvcjsgfVxuXG4gIC8vIHNlbGVjdCBhbGwgdGhlIHJlZ2lzdGVyZWQgYW5kIG1vdW50IHRoZW0gaW5zaWRlIHRoZWlyIHJvb3QgZWxlbWVudHNcbiAgaWYgKHRhZ05hbWUgPT09ICcqJykge1xuICAgIC8vIGdldCBhbGwgY3VzdG9tIHRhZ3NcbiAgICB0YWdOYW1lID0gYWxsVGFncyB8fCBzZWxlY3RUYWdzKCk7XG4gICAgLy8gaWYgdGhlIHJvb3QgZWxzIGl0J3MganVzdCBhIHNpbmdsZSB0YWdcbiAgICBpZiAoZWxlbS50YWdOYW1lKVxuICAgICAgeyBlbGVtID0gJCQodGFnTmFtZSwgZWxlbSk7IH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHNlbGVjdCBhbGwgdGhlIGNoaWxkcmVuIGZvciBhbGwgdGhlIGRpZmZlcmVudCByb290IGVsZW1lbnRzXG4gICAgICB2YXIgbm9kZUxpc3QgPSBbXTtcblxuICAgICAgZWFjaChlbGVtLCBmdW5jdGlvbiAoX2VsKSB7IHJldHVybiBub2RlTGlzdC5wdXNoKCQkKHRhZ05hbWUsIF9lbCkpOyB9KTtcblxuICAgICAgZWxlbSA9IG5vZGVMaXN0O1xuICAgIH1cbiAgICAvLyBnZXQgcmlkIG9mIHRoZSB0YWdOYW1lXG4gICAgdGFnTmFtZSA9IDA7XG4gIH1cblxuICBwdXNoVGFnc1RvKGVsZW0pO1xuXG4gIHJldHVybiB0YWdzXG59XG5cbi8vIENyZWF0ZSBhIG1peGluIHRoYXQgY291bGQgYmUgZ2xvYmFsbHkgc2hhcmVkIGFjcm9zcyBhbGwgdGhlIHRhZ3NcbnZhciBtaXhpbnMgPSB7fTtcbnZhciBnbG9iYWxzID0gbWl4aW5zW0dMT0JBTF9NSVhJTl0gPSB7fTtcbnZhciBtaXhpbnNfaWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZS9SZXR1cm4gYSBtaXhpbiBieSBpdHMgbmFtZVxuICogQHBhcmFtICAgeyBTdHJpbmcgfSAgbmFtZSAtIG1peGluIG5hbWUgKGdsb2JhbCBtaXhpbiBpZiBvYmplY3QpXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9ICBtaXggLSBtaXhpbiBsb2dpY1xuICogQHBhcmFtICAgeyBCb29sZWFuIH0gZyAtIGlzIGdsb2JhbD9cbiAqIEByZXR1cm5zIHsgT2JqZWN0IH0gIHRoZSBtaXhpbiBsb2dpY1xuICovXG5mdW5jdGlvbiBtaXhpbiQxKG5hbWUsIG1peCwgZykge1xuICAvLyBVbm5hbWVkIGdsb2JhbFxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBtaXhpbiQxKChcIl9fdW5uYW1lZF9cIiArIChtaXhpbnNfaWQrKykpLCBuYW1lLCB0cnVlKTtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdG9yZSA9IGcgPyBnbG9iYWxzIDogbWl4aW5zO1xuXG4gIC8vIEdldHRlclxuICBpZiAoIW1peCkge1xuICAgIGlmIChpc1VuZGVmaW5lZChzdG9yZVtuYW1lXSkpXG4gICAgICB7IHRocm93IG5ldyBFcnJvcignVW5yZWdpc3RlcmVkIG1peGluOiAnICsgbmFtZSkgfVxuXG4gICAgcmV0dXJuIHN0b3JlW25hbWVdXG4gIH1cblxuICAvLyBTZXR0ZXJcbiAgc3RvcmVbbmFtZV0gPSBpc0Z1bmN0aW9uKG1peCkgP1xuICAgIGV4dGVuZChtaXgucHJvdG90eXBlLCBzdG9yZVtuYW1lXSB8fCB7fSkgJiYgbWl4IDpcbiAgICBleHRlbmQoc3RvcmVbbmFtZV0gfHwge30sIG1peCk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFsbCB0aGUgdGFncyBpbnN0YW5jZXMgY3JlYXRlZFxuICogQHJldHVybnMgeyBBcnJheSB9IGFsbCB0aGUgdGFncyBpbnN0YW5jZXNcbiAqL1xuZnVuY3Rpb24gdXBkYXRlJDEoKSB7XG4gIHJldHVybiBlYWNoKF9fVEFHU19DQUNIRSwgZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnLnVwZGF0ZSgpOyB9KVxufVxuXG5mdW5jdGlvbiB1bnJlZ2lzdGVyJDEobmFtZSkge1xuICBkZWxldGUgX19UQUdfSU1QTFtuYW1lXTtcbn1cblxudmFyIHZlcnNpb24kMSA9ICd2My40LjInO1xuXG5cbnZhciBjb3JlID0gT2JqZWN0LmZyZWV6ZSh7XG5cdFRhZzogVGFnJDIsXG5cdHRhZzogdGFnJDEsXG5cdHRhZzI6IHRhZzIkMSxcblx0bW91bnQ6IG1vdW50JDIsXG5cdG1peGluOiBtaXhpbiQxLFxuXHR1cGRhdGU6IHVwZGF0ZSQxLFxuXHR1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyJDEsXG5cdHZlcnNpb246IHZlcnNpb24kMVxufSk7XG5cbi8vIGNvdW50ZXIgdG8gZ2l2ZSBhIHVuaXF1ZSBpZCB0byBhbGwgdGhlIFRhZyBpbnN0YW5jZXNcbnZhciBfX3VpZCA9IDA7XG5cbi8qKlxuICogV2UgbmVlZCB0byB1cGRhdGUgb3B0cyBmb3IgdGhpcyB0YWcuIFRoYXQgcmVxdWlyZXMgdXBkYXRpbmcgdGhlIGV4cHJlc3Npb25zXG4gKiBpbiBhbnkgYXR0cmlidXRlcyBvbiB0aGUgdGFnLCBhbmQgdGhlbiBjb3B5aW5nIHRoZSByZXN1bHQgb250byBvcHRzLlxuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gaXNMb29wIC0gaXMgaXQgYSBsb29wIHRhZz9cbiAqIEBwYXJhbSAgIHsgVGFnIH0gIHBhcmVudCAtIHBhcmVudCB0YWcgbm9kZVxuICogQHBhcmFtICAgeyBCb29sZWFuIH0gIGlzQW5vbnltb3VzIC0gaXMgaXQgYSB0YWcgd2l0aG91dCBhbnkgaW1wbD8gKGEgdGFnIG5vdCByZWdpc3RlcmVkKVxuICogQHBhcmFtICAgeyBPYmplY3QgfSAgb3B0cyAtIHRhZyBvcHRpb25zXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gIGluc3RBdHRycyAtIHRhZyBhdHRyaWJ1dGVzIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU9wdHMoaXNMb29wLCBwYXJlbnQsIGlzQW5vbnltb3VzLCBvcHRzLCBpbnN0QXR0cnMpIHtcbiAgLy8gaXNBbm9ueW1vdXMgYGVhY2hgIHRhZ3MgdHJlYXQgYGRvbWAgYW5kIGByb290YCBkaWZmZXJlbnRseS4gSW4gdGhpcyBjYXNlXG4gIC8vIChhbmQgb25seSB0aGlzIGNhc2UpIHdlIGRvbid0IG5lZWQgdG8gZG8gdXBkYXRlT3B0cywgYmVjYXVzZSB0aGUgcmVndWxhciBwYXJzZVxuICAvLyB3aWxsIHVwZGF0ZSB0aG9zZSBhdHRycy4gUGx1cywgaXNBbm9ueW1vdXMgdGFncyBkb24ndCBuZWVkIG9wdHMgYW55d2F5XG4gIGlmIChpc0xvb3AgJiYgaXNBbm9ueW1vdXMpIHsgcmV0dXJuIH1cblxuICB2YXIgY3R4ID0gIWlzQW5vbnltb3VzICYmIGlzTG9vcCA/IHRoaXMgOiBwYXJlbnQgfHwgdGhpcztcbiAgZWFjaChpbnN0QXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgaWYgKGF0dHIuZXhwcikgeyB1cGRhdGVBbGxFeHByZXNzaW9ucy5jYWxsKGN0eCwgW2F0dHIuZXhwcl0pOyB9XG4gICAgLy8gbm9ybWFsaXplIHRoZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICBvcHRzW3RvQ2FtZWwoYXR0ci5uYW1lKS5yZXBsYWNlKEFUVFJTX1BSRUZJWCwgJycpXSA9IGF0dHIuZXhwciA/IGF0dHIuZXhwci52YWx1ZSA6IGF0dHIudmFsdWU7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogVGFnIGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGltcGwgLSBpdCBjb250YWlucyB0aGUgdGFnIHRlbXBsYXRlLCBhbmQgbG9naWNcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGNvbmYgLSB0YWcgb3B0aW9uc1xuICogQHBhcmFtIHsgU3RyaW5nIH0gaW5uZXJIVE1MIC0gaHRtbCB0aGF0IGV2ZW50dWFsbHkgd2UgbmVlZCB0byBpbmplY3QgaW4gdGhlIHRhZ1xuICovXG5mdW5jdGlvbiBUYWckMShpbXBsLCBjb25mLCBpbm5lckhUTUwpIHtcbiAgaWYgKCBpbXBsID09PSB2b2lkIDAgKSBpbXBsID0ge307XG4gIGlmICggY29uZiA9PT0gdm9pZCAwICkgY29uZiA9IHt9O1xuXG4gIHZhciBvcHRzID0gZXh0ZW5kKHt9LCBjb25mLm9wdHMpLFxuICAgIHBhcmVudCA9IGNvbmYucGFyZW50LFxuICAgIGlzTG9vcCA9IGNvbmYuaXNMb29wLFxuICAgIGlzQW5vbnltb3VzID0gISFjb25mLmlzQW5vbnltb3VzLFxuICAgIHNraXBBbm9ueW1vdXMgPSBzZXR0aW5ncyQxLnNraXBBbm9ueW1vdXNUYWdzICYmIGlzQW5vbnltb3VzLFxuICAgIGl0ZW0gPSBjbGVhblVwRGF0YShjb25mLml0ZW0pLFxuICAgIGluZGV4ID0gY29uZi5pbmRleCwgLy8gYXZhaWxhYmxlIG9ubHkgZm9yIHRoZSBsb29wZWQgbm9kZXNcbiAgICBpbnN0QXR0cnMgPSBbXSwgLy8gQWxsIGF0dHJpYnV0ZXMgb24gdGhlIFRhZyB3aGVuIGl0J3MgZmlyc3QgcGFyc2VkXG4gICAgaW1wbEF0dHJzID0gW10sIC8vIGV4cHJlc3Npb25zIG9uIHRoaXMgdHlwZSBvZiBUYWdcbiAgICBleHByZXNzaW9ucyA9IFtdLFxuICAgIHJvb3QgPSBjb25mLnJvb3QsXG4gICAgdGFnTmFtZSA9IGNvbmYudGFnTmFtZSB8fCBnZXRUYWdOYW1lKHJvb3QpLFxuICAgIGlzVmlydHVhbCA9IHRhZ05hbWUgPT09ICd2aXJ0dWFsJyxcbiAgICBwcm9wc0luU3luY1dpdGhQYXJlbnQgPSBbXSxcbiAgICBkb207XG5cbiAgLy8gbWFrZSB0aGlzIHRhZyBvYnNlcnZhYmxlXG4gIGlmICghc2tpcEFub255bW91cykgeyBvYnNlcnZhYmxlJDEodGhpcyk7IH1cbiAgLy8gb25seSBjYWxsIHVubW91bnQgaWYgd2UgaGF2ZSBhIHZhbGlkIF9fVEFHX0lNUEwgKGhhcyBuYW1lIHByb3BlcnR5KVxuICBpZiAoaW1wbC5uYW1lICYmIHJvb3QuX3RhZykgeyByb290Ll90YWcudW5tb3VudCh0cnVlKTsgfVxuXG4gIC8vIG5vdCB5ZXQgbW91bnRlZFxuICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlO1xuXG4gIGRlZmluZVByb3BlcnR5KHRoaXMsICdfXycsIHtcbiAgICBpc0Fub255bW91czogaXNBbm9ueW1vdXMsXG4gICAgaW5zdEF0dHJzOiBpbnN0QXR0cnMsXG4gICAgaW5uZXJIVE1MOiBpbm5lckhUTUwsXG4gICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgaXNMb29wOiBpc0xvb3AsXG4gICAgLy8gdGFncyBoYXZpbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gaXQgd291bGQgYmUgYmV0dGVyIHRvIHVzZSB3ZWFrIG1hcHMgaGVyZSBidXQgd2UgY2FuIG5vdCBpbnRyb2R1Y2UgYnJlYWtpbmcgY2hhbmdlcyBub3dcbiAgICBsaXN0ZW5lcnM6IFtdLFxuICAgIC8vIHRoZXNlIHZhcnMgd2lsbCBiZSBuZWVkZWQgb25seSBmb3IgdGhlIHZpcnR1YWwgdGFnc1xuICAgIHZpcnRzOiBbXSxcbiAgICB0YWlsOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcGFyZW50OiBudWxsLFxuICAgIGl0ZW06IG51bGxcbiAgfSk7XG5cbiAgLy8gY3JlYXRlIGEgdW5pcXVlIGlkIHRvIHRoaXMgdGFnXG4gIC8vIGl0IGNvdWxkIGJlIGhhbmR5IHRvIHVzZSBpdCBhbHNvIHRvIGltcHJvdmUgdGhlIHZpcnR1YWwgZG9tIHJlbmRlcmluZyBzcGVlZFxuICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3Jpb3RfaWQnLCArK19fdWlkKTsgLy8gYmFzZSAxIGFsbG93cyB0ZXN0ICF0Ll9yaW90X2lkXG4gIGRlZmluZVByb3BlcnR5KHRoaXMsICdyb290Jywgcm9vdCk7XG4gIGV4dGVuZCh0aGlzLCB7IG9wdHM6IG9wdHMgfSwgaXRlbSk7XG4gIC8vIHByb3RlY3QgdGhlIFwidGFnc1wiIGFuZCBcInJlZnNcIiBwcm9wZXJ0eSBmcm9tIGJlaW5nIG92ZXJyaWRkZW5cbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ3BhcmVudCcsIHBhcmVudCB8fCBudWxsKTtcbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZ3MnLCB7fSk7XG4gIGRlZmluZVByb3BlcnR5KHRoaXMsICdyZWZzJywge30pO1xuXG4gIGRvbSA9IGlzTG9vcCAmJiBpc0Fub255bW91cyA/IHJvb3QgOiBta2RvbShpbXBsLnRtcGwsIGlubmVySFRNTCwgaXNMb29wKTtcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0YWcgZXhwcmVzc2lvbnMgYW5kIG9wdGlvbnNcbiAgICogQHBhcmFtICAgeyAqIH0gIGRhdGEgLSBkYXRhIHdlIHdhbnQgdG8gdXNlIHRvIGV4dGVuZCB0aGUgdGFnIHByb3BlcnRpZXNcbiAgICogQHJldHVybnMgeyBUYWcgfSB0aGUgY3VycmVudCB0YWcgaW5zdGFuY2VcbiAgICovXG4gIGRlZmluZVByb3BlcnR5KHRoaXMsICd1cGRhdGUnLCBmdW5jdGlvbiB0YWdVcGRhdGUoZGF0YSkge1xuICAgIHZhciBuZXh0T3B0cyA9IHt9LFxuICAgICAgY2FuVHJpZ2dlciA9IHRoaXMuaXNNb3VudGVkICYmICFza2lwQW5vbnltb3VzO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkYXRhIHBhc3NlZCB3aWxsIG5vdCBvdmVycmlkZVxuICAgIC8vIHRoZSBjb21wb25lbnQgY29yZSBtZXRob2RzXG4gICAgZGF0YSA9IGNsZWFuVXBEYXRhKGRhdGEpO1xuICAgIGV4dGVuZCh0aGlzLCBkYXRhKTtcbiAgICB1cGRhdGVPcHRzLmFwcGx5KHRoaXMsIFtpc0xvb3AsIHBhcmVudCwgaXNBbm9ueW1vdXMsIG5leHRPcHRzLCBpbnN0QXR0cnNdKTtcblxuICAgIGlmIChjYW5UcmlnZ2VyICYmIHRoaXMuaXNNb3VudGVkICYmIGlzRnVuY3Rpb24odGhpcy5zaG91bGRVcGRhdGUpICYmICF0aGlzLnNob3VsZFVwZGF0ZShkYXRhLCBuZXh0T3B0cykpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gaW5oZXJpdCBwcm9wZXJ0aWVzIGZyb20gdGhlIHBhcmVudCwgYnV0IG9ubHkgZm9yIGlzQW5vbnltb3VzIHRhZ3NcbiAgICBpZiAoaXNMb29wICYmIGlzQW5vbnltb3VzKSB7IGluaGVyaXRGcm9tLmFwcGx5KHRoaXMsIFt0aGlzLnBhcmVudCwgcHJvcHNJblN5bmNXaXRoUGFyZW50XSk7IH1cbiAgICBleHRlbmQob3B0cywgbmV4dE9wdHMpO1xuICAgIGlmIChjYW5UcmlnZ2VyKSB7IHRoaXMudHJpZ2dlcigndXBkYXRlJywgZGF0YSk7IH1cbiAgICB1cGRhdGVBbGxFeHByZXNzaW9ucy5jYWxsKHRoaXMsIGV4cHJlc3Npb25zKTtcbiAgICBpZiAoY2FuVHJpZ2dlcikgeyB0aGlzLnRyaWdnZXIoJ3VwZGF0ZWQnKTsgfVxuXG4gICAgcmV0dXJuIHRoaXNcblxuICB9LmJpbmQodGhpcykpO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBtaXhpbiB0byB0aGlzIHRhZ1xuICAgKiBAcmV0dXJucyB7IFRhZyB9IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICAgKi9cbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ21peGluJywgZnVuY3Rpb24gdGFnTWl4aW4oKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBlYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKG1peCkge1xuICAgICAgdmFyIGluc3RhbmNlLCBvYmo7XG4gICAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgICAgLy8gcHJvcGVydGllcyBibGFja2xpc3RlZCBhbmQgd2lsbCBub3QgYmUgYm91bmQgdG8gdGhlIHRhZyBpbnN0YW5jZVxuICAgICAgdmFyIHByb3BzQmxhY2tsaXN0ID0gWydpbml0JywgJ19fcHJvdG9fXyddO1xuXG4gICAgICBtaXggPSBpc1N0cmluZyhtaXgpID8gbWl4aW4kMShtaXgpIDogbWl4O1xuXG4gICAgICAvLyBjaGVjayBpZiB0aGUgbWl4aW4gaXMgYSBmdW5jdGlvblxuICAgICAgaWYgKGlzRnVuY3Rpb24obWl4KSkge1xuICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBtaXhpbiBpbnN0YW5jZVxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBtaXgoKTtcbiAgICAgIH0gZWxzZSB7IGluc3RhbmNlID0gbWl4OyB9XG5cbiAgICAgIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0YW5jZSk7XG5cbiAgICAgIC8vIGJ1aWxkIG11bHRpbGV2ZWwgcHJvdG90eXBlIGluaGVyaXRhbmNlIGNoYWluIHByb3BlcnR5IGxpc3RcbiAgICAgIGRvIHsgcHJvcHMgPSBwcm9wcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqIHx8IGluc3RhbmNlKSk7IH1cbiAgICAgIHdoaWxlIChvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqIHx8IGluc3RhbmNlKSlcblxuICAgICAgLy8gbG9vcCB0aGUga2V5cyBpbiB0aGUgZnVuY3Rpb24gcHJvdG90eXBlIG9yIHRoZSBhbGwgb2JqZWN0IGtleXNcbiAgICAgIGVhY2gocHJvcHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gYmluZCBtZXRob2RzIHRvIHRoaXNcbiAgICAgICAgLy8gYWxsb3cgbWl4aW5zIHRvIG92ZXJyaWRlIG90aGVyIHByb3BlcnRpZXMvcGFyZW50IG1peGluc1xuICAgICAgICBpZiAoIWNvbnRhaW5zKHByb3BzQmxhY2tsaXN0LCBrZXkpKSB7XG4gICAgICAgICAgLy8gY2hlY2sgZm9yIGdldHRlcnMvc2V0dGVyc1xuICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbnN0YW5jZSwga2V5KSB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBrZXkpO1xuICAgICAgICAgIHZhciBoYXNHZXR0ZXJTZXR0ZXIgPSBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCk7XG5cbiAgICAgICAgICAvLyBhcHBseSBtZXRob2Qgb25seSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBpbnN0YW5jZVxuICAgICAgICAgIGlmICghdGhpcyQxLmhhc093blByb3BlcnR5KGtleSkgJiYgaGFzR2V0dGVyU2V0dGVyKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyQxLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzJDFba2V5XSA9IGlzRnVuY3Rpb24oaW5zdGFuY2Vba2V5XSkgP1xuICAgICAgICAgICAgICBpbnN0YW5jZVtrZXldLmJpbmQodGhpcyQxKSA6XG4gICAgICAgICAgICAgIGluc3RhbmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gaW5pdCBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseVxuICAgICAgaWYgKGluc3RhbmNlLmluaXQpXG4gICAgICAgIHsgaW5zdGFuY2UuaW5pdC5iaW5kKHRoaXMkMSkoKTsgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzXG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLyoqXG4gICAqIE1vdW50IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7IFRhZyB9IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICAgKi9cbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ21vdW50JywgZnVuY3Rpb24gdGFnTW91bnQoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByb290Ll90YWcgPSB0aGlzOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB0YWcganVzdCBjcmVhdGVkXG5cbiAgICAvLyBSZWFkIGFsbCB0aGUgYXR0cnMgb24gdGhpcyBpbnN0YW5jZS4gVGhpcyBnaXZlIHVzIHRoZSBpbmZvIHdlIG5lZWQgZm9yIHVwZGF0ZU9wdHNcbiAgICBwYXJzZUF0dHJpYnV0ZXMuYXBwbHkocGFyZW50LCBbcm9vdCwgcm9vdC5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0ciwgZXhwcikge1xuICAgICAgaWYgKCFpc0Fub255bW91cyAmJiBSZWZFeHByLmlzUHJvdG90eXBlT2YoZXhwcikpIHsgZXhwci50YWcgPSB0aGlzJDE7IH1cbiAgICAgIGF0dHIuZXhwciA9IGV4cHI7XG4gICAgICBpbnN0QXR0cnMucHVzaChhdHRyKTtcbiAgICB9XSk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHJvb3QgYWRkaW5nIGN1c3RvbSBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIHRoZSBjb21waWxlclxuICAgIGltcGxBdHRycyA9IFtdO1xuICAgIHdhbGtBdHRycyhpbXBsLmF0dHJzLCBmdW5jdGlvbiAoaywgdikgeyBpbXBsQXR0cnMucHVzaCh7bmFtZTogaywgdmFsdWU6IHZ9KTsgfSk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzLmFwcGx5KHRoaXMsIFtyb290LCBpbXBsQXR0cnMsIGZ1bmN0aW9uIChhdHRyLCBleHByKSB7XG4gICAgICBpZiAoZXhwcikgeyBleHByZXNzaW9ucy5wdXNoKGV4cHIpOyB9XG4gICAgICBlbHNlIHsgc2V0QXR0cihyb290LCBhdHRyLm5hbWUsIGF0dHIudmFsdWUpOyB9XG4gICAgfV0pO1xuXG4gICAgLy8gaW5pdGlhbGlhdGlvblxuICAgIHVwZGF0ZU9wdHMuYXBwbHkodGhpcywgW2lzTG9vcCwgcGFyZW50LCBpc0Fub255bW91cywgb3B0cywgaW5zdEF0dHJzXSk7XG5cbiAgICAvLyBhZGQgZ2xvYmFsIG1peGluc1xuICAgIHZhciBnbG9iYWxNaXhpbiA9IG1peGluJDEoR0xPQkFMX01JWElOKTtcblxuICAgIGlmIChnbG9iYWxNaXhpbiAmJiAhc2tpcEFub255bW91cykge1xuICAgICAgZm9yICh2YXIgaSBpbiBnbG9iYWxNaXhpbikge1xuICAgICAgICBpZiAoZ2xvYmFsTWl4aW4uaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB0aGlzJDEubWl4aW4oZ2xvYmFsTWl4aW5baV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGltcGwuZm4pIHsgaW1wbC5mbi5jYWxsKHRoaXMsIG9wdHMpOyB9XG5cbiAgICBpZiAoIXNraXBBbm9ueW1vdXMpIHsgdGhpcy50cmlnZ2VyKCdiZWZvcmUtbW91bnQnKTsgfVxuXG4gICAgLy8gcGFyc2UgbGF5b3V0IGFmdGVyIGluaXQuIGZuIG1heSBjYWxjdWxhdGUgYXJncyBmb3IgbmVzdGVkIGN1c3RvbSB0YWdzXG4gICAgcGFyc2VFeHByZXNzaW9ucy5hcHBseSh0aGlzLCBbZG9tLCBleHByZXNzaW9ucywgaXNBbm9ueW1vdXNdKTtcblxuICAgIHRoaXMudXBkYXRlKGl0ZW0pO1xuXG4gICAgaWYgKCFpc0Fub255bW91cykge1xuICAgICAgd2hpbGUgKGRvbS5maXJzdENoaWxkKSB7IHJvb3QuYXBwZW5kQ2hpbGQoZG9tLmZpcnN0Q2hpbGQpOyB9XG4gICAgfVxuXG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ3Jvb3QnLCByb290KTtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNNb3VudGVkJywgdHJ1ZSk7XG5cbiAgICBpZiAoc2tpcEFub255bW91cykgeyByZXR1cm4gfVxuXG4gICAgLy8gaWYgaXQncyBub3QgYSBjaGlsZCB0YWcgd2UgY2FuIHRyaWdnZXIgaXRzIG1vdW50IGV2ZW50XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdtb3VudCcpO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byB3YWl0IHRoYXQgdGhlIHBhcmVudCBcIm1vdW50XCIgb3IgXCJ1cGRhdGVkXCIgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICBlbHNlIHtcbiAgICAgIHZhciBwID0gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnKHRoaXMucGFyZW50KTtcbiAgICAgIHAub25lKCFwLmlzTW91bnRlZCA/ICdtb3VudCcgOiAndXBkYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcyQxLnRyaWdnZXIoJ21vdW50Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuXG4gIH0uYmluZCh0aGlzKSk7XG5cbiAgLyoqXG4gICAqIFVubW91bnQgdGhlIHRhZyBpbnN0YW5jZVxuICAgKiBAcGFyYW0geyBCb29sZWFuIH0gbXVzdEtlZXBSb290IC0gaWYgaXQncyB0cnVlIHRoZSByb290IG5vZGUgd2lsbCBub3QgYmUgcmVtb3ZlZFxuICAgKiBAcmV0dXJucyB7IFRhZyB9IHRoZSBjdXJyZW50IHRhZyBpbnN0YW5jZVxuICAgKi9cbiAgZGVmaW5lUHJvcGVydHkodGhpcywgJ3VubW91bnQnLCBmdW5jdGlvbiB0YWdVbm1vdW50KG11c3RLZWVwUm9vdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGVsID0gdGhpcy5yb290LFxuICAgICAgcCA9IGVsLnBhcmVudE5vZGUsXG4gICAgICBwdGFnLFxuICAgICAgdGFnSW5kZXggPSBfX1RBR1NfQ0FDSEUuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmICghc2tpcEFub255bW91cykgeyB0aGlzLnRyaWdnZXIoJ2JlZm9yZS11bm1vdW50Jyk7IH1cblxuICAgIC8vIGNsZWFyIGFsbCBhdHRyaWJ1dGVzIGNvbWluZyBmcm9tIHRoZSBtb3VudGVkIHRhZ1xuICAgIHdhbGtBdHRycyhpbXBsLmF0dHJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgobmFtZSwgQVRUUlNfUFJFRklYKSlcbiAgICAgICAgeyBuYW1lID0gbmFtZS5zbGljZShBVFRSU19QUkVGSVgubGVuZ3RoKTsgfVxuICAgICAgcmVtQXR0cihyb290LCBuYW1lKTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuX18ubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGRvbSkge1xuICAgICAgT2JqZWN0LmtleXMoZG9tW1JJT1RfRVZFTlRTX0tFWV0pLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGRvbVtSSU9UX0VWRU5UU19LRVldW2V2ZW50TmFtZV0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgdGhpcyB0YWcgaW5zdGFuY2UgZnJvbSB0aGUgZ2xvYmFsIHZpcnR1YWxEb20gdmFyaWFibGVcbiAgICBpZiAodGFnSW5kZXggIT09IC0xKVxuICAgICAgeyBfX1RBR1NfQ0FDSEUuc3BsaWNlKHRhZ0luZGV4LCAxKTsgfVxuXG4gICAgaWYgKHAgfHwgaXNWaXJ0dWFsKSB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHB0YWcgPSBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnRUYWcocGFyZW50KTtcblxuICAgICAgICBpZiAoaXNWaXJ0dWFsKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModGhpcy50YWdzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICBhcnJheWlzaFJlbW92ZShwdGFnLnRhZ3MsIHRhZ05hbWUsIHRoaXMkMS50YWdzW3RhZ05hbWVdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheWlzaFJlbW92ZShwdGFnLnRhZ3MsIHRhZ05hbWUsIHRoaXMpO1xuICAgICAgICAgIGlmKHBhcmVudCAhPT0gcHRhZykgLy8gcmVtb3ZlIGZyb20gX3BhcmVudCB0b29cbiAgICAgICAgICAgIHsgYXJyYXlpc2hSZW1vdmUocGFyZW50LnRhZ3MsIHRhZ05hbWUsIHRoaXMpOyB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdGFnIGNvbnRlbnRzXG4gICAgICAgIHNldElubmVySFRNTChlbCwgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAocCAmJiAhbXVzdEtlZXBSb290KSB7IHAucmVtb3ZlQ2hpbGQoZWwpOyB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX18udmlydHMpIHtcbiAgICAgIGVhY2godGhpcy5fXy52aXJ0cywgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHYucGFyZW50Tm9kZSkgeyB2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodik7IH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGV4cHJlc3Npb25zIHRvIHVubW91bnQgdGhlbXNlbHZlc1xuICAgIHVubW91bnRBbGwoZXhwcmVzc2lvbnMpO1xuICAgIGVhY2goaW5zdEF0dHJzLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS5leHByICYmIGEuZXhwci51bm1vdW50ICYmIGEuZXhwci51bm1vdW50KCk7IH0pO1xuXG4gICAgLy8gY3VzdG9tIGludGVybmFsIHVubW91bnQgZnVuY3Rpb24gdG8gYXZvaWQgcmVseWluZyBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgIGlmICh0aGlzLl9fLm9uVW5tb3VudCkgeyB0aGlzLl9fLm9uVW5tb3VudCgpOyB9XG5cbiAgICBpZiAoIXNraXBBbm9ueW1vdXMpIHtcbiAgICAgIHRoaXMudHJpZ2dlcigndW5tb3VudCcpO1xuICAgICAgdGhpcy5vZmYoJyonKTtcbiAgICB9XG5cbiAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNNb3VudGVkJywgZmFsc2UpO1xuXG4gICAgZGVsZXRlIHRoaXMucm9vdC5fdGFnO1xuXG4gICAgcmV0dXJuIHRoaXNcblxuICB9LmJpbmQodGhpcykpO1xufVxuXG4vKipcbiAqIERldGVjdCB0aGUgdGFnIGltcGxlbWVudGF0aW9uIGJ5IGEgRE9NIG5vZGVcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gZG9tIC0gRE9NIG5vZGUgd2UgbmVlZCB0byBwYXJzZSB0byBnZXQgaXRzIHRhZyBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybnMgeyBPYmplY3QgfSBpdCByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGN1c3RvbSB0YWcgKHRlbXBsYXRlIGFuZCBib290IGZ1bmN0aW9uKVxuICovXG5mdW5jdGlvbiBnZXRUYWcoZG9tKSB7XG4gIHJldHVybiBkb20udGFnTmFtZSAmJiBfX1RBR19JTVBMW2dldEF0dHIoZG9tLCBJU19ESVJFQ1RJVkUpIHx8XG4gICAgZ2V0QXR0cihkb20sIElTX0RJUkVDVElWRSkgfHwgZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKV1cbn1cblxuLyoqXG4gKiBJbmhlcml0IHByb3BlcnRpZXMgZnJvbSBhIHRhcmdldCB0YWcgaW5zdGFuY2VcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtICAgeyBUYWcgfSB0YXJnZXQgLSB0YWcgd2hlcmUgd2Ugd2lsbCBpbmhlcml0IHByb3BlcnRpZXNcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSBwcm9wc0luU3luY1dpdGhQYXJlbnQgLSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHN5bmMgd2l0aCB0aGUgdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXRGcm9tKHRhcmdldCwgcHJvcHNJblN5bmNXaXRoUGFyZW50KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGVhY2goT2JqZWN0LmtleXModGFyZ2V0KSwgZnVuY3Rpb24gKGspIHtcbiAgICAvLyBzb21lIHByb3BlcnRpZXMgbXVzdCBiZSBhbHdheXMgaW4gc3luYyB3aXRoIHRoZSBwYXJlbnQgdGFnXG4gICAgdmFyIG11c3RTeW5jID0gIWlzUmVzZXJ2ZWROYW1lKGspICYmIGNvbnRhaW5zKHByb3BzSW5TeW5jV2l0aFBhcmVudCwgayk7XG5cbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcyQxW2tdKSB8fCBtdXN0U3luYykge1xuICAgICAgLy8gdHJhY2sgdGhlIHByb3BlcnR5IHRvIGtlZXAgaW4gc3luY1xuICAgICAgLy8gc28gd2UgY2FuIGtlZXAgaXQgdXBkYXRlZFxuICAgICAgaWYgKCFtdXN0U3luYykgeyBwcm9wc0luU3luY1dpdGhQYXJlbnQucHVzaChrKTsgfVxuICAgICAgdGhpcyQxW2tdID0gdGFyZ2V0W2tdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTW92ZSB0aGUgcG9zaXRpb24gb2YgYSBjdXN0b20gdGFnIGluIGl0cyBwYXJlbnQgdGFnXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGFnTmFtZSAtIGtleSB3aGVyZSB0aGUgdGFnIHdhcyBzdG9yZWRcbiAqIEBwYXJhbSAgIHsgTnVtYmVyIH0gbmV3UG9zIC0gaW5kZXggd2hlcmUgdGhlIG5ldyB0YWcgd2lsbCBiZSBzdG9yZWRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkVGFnKHRhZ05hbWUsIG5ld1Bvcykge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgdGFncztcbiAgLy8gbm8gcGFyZW50IG5vIG1vdmVcbiAgaWYgKCFwYXJlbnQpIHsgcmV0dXJuIH1cblxuICB0YWdzID0gcGFyZW50LnRhZ3NbdGFnTmFtZV07XG5cbiAgaWYgKGlzQXJyYXkodGFncykpXG4gICAgeyB0YWdzLnNwbGljZShuZXdQb3MsIDAsIHRhZ3Muc3BsaWNlKHRhZ3MuaW5kZXhPZih0aGlzKSwgMSlbMF0pOyB9XG4gIGVsc2UgeyBhcnJheWlzaEFkZChwYXJlbnQudGFncywgdGFnTmFtZSwgdGhpcyk7IH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2hpbGQgdGFnIGluY2x1ZGluZyBpdCBjb3JyZWN0bHkgaW50byBpdHMgcGFyZW50XG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGNoaWxkIC0gY2hpbGQgdGFnIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IG9wdHMgLSB0YWcgb3B0aW9ucyBjb250YWluaW5nIHRoZSBET00gbm9kZSB3aGVyZSB0aGUgdGFnIHdpbGwgYmUgbW91bnRlZFxuICogQHBhcmFtICAgeyBTdHJpbmcgfSBpbm5lckhUTUwgLSBpbm5lciBodG1sIG9mIHRoZSBjaGlsZCBub2RlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHBhcmVudCAtIGluc3RhbmNlIG9mIHRoZSBwYXJlbnQgdGFnIGluY2x1ZGluZyB0aGUgY2hpbGQgY3VzdG9tIHRhZ1xuICogQHJldHVybnMgeyBPYmplY3QgfSBpbnN0YW5jZSBvZiB0aGUgbmV3IGNoaWxkIHRhZyBqdXN0IGNyZWF0ZWRcbiAqL1xuZnVuY3Rpb24gaW5pdENoaWxkVGFnKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbmV3IFRhZyQxKGNoaWxkLCBvcHRzLCBpbm5lckhUTUwpLFxuICAgIHRhZ05hbWUgPSBvcHRzLnRhZ05hbWUgfHwgZ2V0VGFnTmFtZShvcHRzLnJvb3QsIHRydWUpLFxuICAgIHB0YWcgPSBnZXRJbW1lZGlhdGVDdXN0b21QYXJlbnRUYWcocGFyZW50KTtcbiAgLy8gZml4IGZvciB0aGUgcGFyZW50IGF0dHJpYnV0ZSBpbiB0aGUgbG9vcGVkIGVsZW1lbnRzXG4gIGRlZmluZVByb3BlcnR5KHRhZywgJ3BhcmVudCcsIHB0YWcpO1xuICAvLyBzdG9yZSB0aGUgcmVhbCBwYXJlbnQgdGFnXG4gIC8vIGluIHNvbWUgY2FzZXMgdGhpcyBjb3VsZCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgY3VzdG9tIHBhcmVudCB0YWdcbiAgLy8gZm9yIGV4YW1wbGUgaW4gbmVzdGVkIGxvb3BzXG4gIHRhZy5fXy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgLy8gYWRkIHRoaXMgdGFnIHRvIHRoZSBjdXN0b20gcGFyZW50IHRhZ1xuICBhcnJheWlzaEFkZChwdGFnLnRhZ3MsIHRhZ05hbWUsIHRhZyk7XG5cbiAgLy8gYW5kIGFsc28gdG8gdGhlIHJlYWwgcGFyZW50IHRhZ1xuICBpZiAocHRhZyAhPT0gcGFyZW50KVxuICAgIHsgYXJyYXlpc2hBZGQocGFyZW50LnRhZ3MsIHRhZ05hbWUsIHRhZyk7IH1cblxuICAvLyBlbXB0eSB0aGUgY2hpbGQgbm9kZSBvbmNlIHdlIGdvdCBpdHMgdGVtcGxhdGVcbiAgLy8gdG8gYXZvaWQgdGhhdCBpdHMgY2hpbGRyZW4gZ2V0IGNvbXBpbGVkIG11bHRpcGxlIHRpbWVzXG4gIG9wdHMucm9vdC5pbm5lckhUTUwgPSAnJztcblxuICByZXR1cm4gdGFnXG59XG5cbi8qKlxuICogTG9vcCBiYWNrd2FyZCBhbGwgdGhlIHBhcmVudHMgdHJlZSB0byBkZXRlY3QgdGhlIGZpcnN0IGN1c3RvbSBwYXJlbnQgdGFnXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IHRhZyAtIGEgVGFnIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7IE9iamVjdCB9IHRoZSBpbnN0YW5jZSBvZiB0aGUgZmlyc3QgY3VzdG9tIHBhcmVudCB0YWcgZm91bmRcbiAqL1xuZnVuY3Rpb24gZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnKHRhZykge1xuICB2YXIgcHRhZyA9IHRhZztcbiAgd2hpbGUgKHB0YWcuX18uaXNBbm9ueW1vdXMpIHtcbiAgICBpZiAoIXB0YWcucGFyZW50KSB7IGJyZWFrIH1cbiAgICBwdGFnID0gcHRhZy5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHB0YWdcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIHRoZSB1bm1vdW50IG1ldGhvZCBvbiBhbGwgdGhlIGV4cHJlc3Npb25zXG4gKiBAcGFyYW0gICB7IEFycmF5IH0gZXhwcmVzc2lvbnMgLSBET00gZXhwcmVzc2lvbnNcbiAqL1xuZnVuY3Rpb24gdW5tb3VudEFsbChleHByZXNzaW9ucykge1xuICBlYWNoKGV4cHJlc3Npb25zLCBmdW5jdGlvbihleHByKSB7XG4gICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBUYWckMSkgeyBleHByLnVubW91bnQodHJ1ZSk7IH1cbiAgICBlbHNlIGlmIChleHByLnRhZ05hbWUpIHsgZXhwci50YWcudW5tb3VudCh0cnVlKTsgfVxuICAgIGVsc2UgaWYgKGV4cHIudW5tb3VudCkgeyBleHByLnVubW91bnQoKTsgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRhZyBuYW1lIG9mIGFueSBET00gbm9kZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSBkb20gLSBET00gbm9kZSB3ZSB3YW50IHRvIHBhcnNlXG4gKiBAcGFyYW0gICB7IEJvb2xlYW4gfSBza2lwRGF0YUlzIC0gaGFjayB0byBpZ25vcmUgdGhlIGRhdGEtaXMgYXR0cmlidXRlIHdoZW4gYXR0YWNoaW5nIHRvIHBhcmVudFxuICogQHJldHVybnMgeyBTdHJpbmcgfSBuYW1lIHRvIGlkZW50aWZ5IHRoaXMgZG9tIG5vZGUgaW4gcmlvdFxuICovXG5mdW5jdGlvbiBnZXRUYWdOYW1lKGRvbSwgc2tpcERhdGFJcykge1xuICB2YXIgY2hpbGQgPSBnZXRUYWcoZG9tKSxcbiAgICBuYW1lZFRhZyA9ICFza2lwRGF0YUlzICYmIGdldEF0dHIoZG9tLCBJU19ESVJFQ1RJVkUpO1xuICByZXR1cm4gbmFtZWRUYWcgJiYgIXRtcGwuaGFzRXhwcihuYW1lZFRhZykgP1xuICAgICAgICAgICAgICAgIG5hbWVkVGFnIDpcbiAgICAgICAgICAgICAgY2hpbGQgPyBjaGlsZC5uYW1lIDogZG9tLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIFdpdGggdGhpcyBmdW5jdGlvbiB3ZSBhdm9pZCB0aGF0IHRoZSBpbnRlcm5hbCBUYWcgbWV0aG9kcyBnZXQgb3ZlcnJpZGRlblxuICogQHBhcmFtICAgeyBPYmplY3QgfSBkYXRhIC0gb3B0aW9ucyB3ZSB3YW50IHRvIHVzZSB0byBleHRlbmQgdGhlIHRhZyBpbnN0YW5jZVxuICogQHJldHVybnMgeyBPYmplY3QgfSBjbGVhbiBvYmplY3Qgd2l0aG91dCBjb250YWluaW5nIHRoZSByaW90IGludGVybmFsIHJlc2VydmVkIHdvcmRzXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBEYXRhKGRhdGEpIHtcbiAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFRhZyQxKSAmJiAhKGRhdGEgJiYgaXNGdW5jdGlvbihkYXRhLnRyaWdnZXIpKSlcbiAgICB7IHJldHVybiBkYXRhIH1cblxuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgIGlmICghUkVfUkVTRVJWRURfTkFNRVMudGVzdChrZXkpKSB7IG9ba2V5XSA9IGRhdGFba2V5XTsgfVxuICB9XG4gIHJldHVybiBvXG59XG5cbi8qKlxuICogU2V0IHRoZSBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgZm9yIGEgZ2l2ZW4ga2V5LiBJZiBzb21ldGhpbmcgYWxyZWFkeVxuICogZXhpc3RzIHRoZXJlLCB0aGVuIGl0IGJlY29tZXMgYW4gYXJyYXkgY29udGFpbmluZyBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZS5cbiAqIEBwYXJhbSB7IE9iamVjdCB9IG9iaiAtIG9iamVjdCBvbiB3aGljaCB0byBzZXQgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0geyBTdHJpbmcgfSBrZXkgLSBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0geyBPYmplY3QgfSB2YWx1ZSAtIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgc2V0XG4gKiBAcGFyYW0geyBCb29sZWFuIH0gZW5zdXJlQXJyYXkgLSBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgcmVtYWlucyBhbiBhcnJheVxuICogQHBhcmFtIHsgTnVtYmVyIH0gaW5kZXggLSBhZGQgdGhlIG5ldyBpdGVtIGluIGEgY2VydGFpbiBhcnJheSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBhcnJheWlzaEFkZChvYmosIGtleSwgdmFsdWUsIGVuc3VyZUFycmF5LCBpbmRleCkge1xuICB2YXIgZGVzdCA9IG9ialtrZXldO1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KGRlc3QpO1xuICB2YXIgaGFzSW5kZXggPSAhaXNVbmRlZmluZWQoaW5kZXgpO1xuXG4gIGlmIChkZXN0ICYmIGRlc3QgPT09IHZhbHVlKSB7IHJldHVybiB9XG5cbiAgLy8gaWYgdGhlIGtleSB3YXMgbmV2ZXIgc2V0LCBzZXQgaXQgb25jZVxuICBpZiAoIWRlc3QgJiYgZW5zdXJlQXJyYXkpIHsgb2JqW2tleV0gPSBbdmFsdWVdOyB9XG4gIGVsc2UgaWYgKCFkZXN0KSB7IG9ialtrZXldID0gdmFsdWU7IH1cbiAgLy8gaWYgaXQgd2FzIGFuIGFycmF5IGFuZCBub3QgeWV0IHNldFxuICBlbHNlIHtcbiAgICBpZiAoaXNBcnIpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGRlc3QuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAvLyB0aGlzIGl0ZW0gbmV2ZXIgY2hhbmdlZCBpdHMgcG9zaXRpb25cbiAgICAgIGlmIChvbGRJbmRleCA9PT0gaW5kZXgpIHsgcmV0dXJuIH1cbiAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBmcm9tIGl0cyBvbGQgcG9zaXRpb25cbiAgICAgIGlmIChvbGRJbmRleCAhPT0gLTEpIHsgZGVzdC5zcGxpY2Uob2xkSW5kZXgsIDEpOyB9XG4gICAgICAvLyBtb3ZlIG9yIGFkZCB0aGUgaXRlbVxuICAgICAgaWYgKGhhc0luZGV4KSB7XG4gICAgICAgIGRlc3Quc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IG9ialtrZXldID0gW2Rlc3QsIHZhbHVlXTsgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gYW4gb2JqZWN0IGF0IGEgZ2l2ZW4ga2V5LiBJZiB0aGUga2V5IHBvaW50cyB0byBhbiBhcnJheSxcbiAqIHRoZW4gdGhlIGl0ZW0gaXMganVzdCByZW1vdmVkIGZyb20gdGhlIGFycmF5LlxuICogQHBhcmFtIHsgT2JqZWN0IH0gb2JqIC0gb2JqZWN0IG9uIHdoaWNoIHRvIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAqIEBwYXJhbSB7IFN0cmluZyB9IGtleSAtIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7IE9iamVjdCB9IHZhbHVlIC0gdGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSByZW1vdmVkXG4gKiBAcGFyYW0geyBCb29sZWFuIH0gZW5zdXJlQXJyYXkgLSBlbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgcmVtYWlucyBhbiBhcnJheVxuKi9cbmZ1bmN0aW9uIGFycmF5aXNoUmVtb3ZlKG9iaiwga2V5LCB2YWx1ZSwgZW5zdXJlQXJyYXkpIHtcbiAgaWYgKGlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgdmFyIGluZGV4ID0gb2JqW2tleV0uaW5kZXhPZih2YWx1ZSk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkgeyBvYmpba2V5XS5zcGxpY2UoaW5kZXgsIDEpOyB9XG4gICAgaWYgKCFvYmpba2V5XS5sZW5ndGgpIHsgZGVsZXRlIG9ialtrZXldOyB9XG4gICAgZWxzZSBpZiAob2JqW2tleV0ubGVuZ3RoID09PSAxICYmICFlbnN1cmVBcnJheSkgeyBvYmpba2V5XSA9IG9ialtrZXldWzBdOyB9XG4gIH0gZWxzZVxuICAgIHsgZGVsZXRlIG9ialtrZXldOyB9IC8vIG90aGVyd2lzZSBqdXN0IGRlbGV0ZSB0aGUga2V5XG59XG5cbi8qKlxuICogTW91bnQgYSB0YWcgY3JlYXRpbmcgbmV3IFRhZyBpbnN0YW5jZVxuICogQHBhcmFtICAgeyBPYmplY3QgfSByb290IC0gZG9tIG5vZGUgd2hlcmUgdGhlIHRhZyB3aWxsIGJlIG1vdW50ZWRcbiAqIEBwYXJhbSAgIHsgU3RyaW5nIH0gdGFnTmFtZSAtIG5hbWUgb2YgdGhlIHJpb3QgdGFnIHdlIHdhbnQgdG8gbW91bnRcbiAqIEBwYXJhbSAgIHsgT2JqZWN0IH0gb3B0cyAtIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgVGFnIGluc3RhbmNlXG4gKiBAcGFyYW0gICB7IE9iamVjdCB9IGN0eCAtIG9wdGlvbmFsIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZXh0ZW5kIGFuIGV4aXN0aW5nIGNsYXNzICggdXNlZCBpbiByaW90LlRhZyApXG4gKiBAcmV0dXJucyB7IFRhZyB9IGEgbmV3IFRhZyBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBtb3VudFRvKHJvb3QsIHRhZ05hbWUsIG9wdHMsIGN0eCkge1xuICB2YXIgaW1wbCA9IF9fVEFHX0lNUExbdGFnTmFtZV0sXG4gICAgaW1wbENsYXNzID0gX19UQUdfSU1QTFt0YWdOYW1lXS5jbGFzcyxcbiAgICB0YWcgPSBjdHggfHwgKGltcGxDbGFzcyA/IE9iamVjdC5jcmVhdGUoaW1wbENsYXNzLnByb3RvdHlwZSkgOiB7fSksXG4gICAgLy8gY2FjaGUgdGhlIGlubmVyIEhUTUwgdG8gZml4ICM4NTVcbiAgICBpbm5lckhUTUwgPSByb290Ll9pbm5lckhUTUwgPSByb290Ll9pbm5lckhUTUwgfHwgcm9vdC5pbm5lckhUTUw7XG5cbiAgLy8gY2xlYXIgdGhlIGlubmVyIGh0bWxcbiAgcm9vdC5pbm5lckhUTUwgPSAnJztcblxuICB2YXIgY29uZiA9IGV4dGVuZCh7IHJvb3Q6IHJvb3QsIG9wdHM6IG9wdHMgfSwgeyBwYXJlbnQ6IG9wdHMgPyBvcHRzLnBhcmVudCA6IG51bGwgfSk7XG5cbiAgaWYgKGltcGwgJiYgcm9vdCkgeyBUYWckMS5hcHBseSh0YWcsIFtpbXBsLCBjb25mLCBpbm5lckhUTUxdKTsgfVxuXG4gIGlmICh0YWcgJiYgdGFnLm1vdW50KSB7XG4gICAgdGFnLm1vdW50KHRydWUpO1xuICAgIC8vIGFkZCB0aGlzIHRhZyB0byB0aGUgdmlydHVhbERvbSB2YXJpYWJsZVxuICAgIGlmICghY29udGFpbnMoX19UQUdTX0NBQ0hFLCB0YWcpKSB7IF9fVEFHU19DQUNIRS5wdXNoKHRhZyk7IH1cbiAgfVxuXG4gIHJldHVybiB0YWdcbn1cblxuLyoqXG4gKiBtYWtlcyBhIHRhZyB2aXJ0dWFsIGFuZCByZXBsYWNlcyBhIHJlZmVyZW5jZSBpbiB0aGUgZG9tXG4gKiBAdGhpcyBUYWdcbiAqIEBwYXJhbSB7IHRhZyB9IHRoZSB0YWcgdG8gbWFrZSB2aXJ0dWFsXG4gKiBAcGFyYW0geyByZWYgfSB0aGUgZG9tIHJlZmVyZW5jZSBsb2NhdGlvblxuICovXG5mdW5jdGlvbiBtYWtlUmVwbGFjZVZpcnR1YWwodGFnLCByZWYpIHtcbiAgdmFyIGZyYWcgPSBjcmVhdGVGcmFnKCk7XG4gIG1ha2VWaXJ0dWFsLmNhbGwodGFnLCBmcmFnKTtcbiAgcmVmLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGZyYWcsIHJlZik7XG59XG5cbi8qKlxuICogQWRkcyB0aGUgZWxlbWVudHMgZm9yIGEgdmlydHVhbCB0YWdcbiAqIEB0aGlzIFRhZ1xuICogQHBhcmFtIHsgTm9kZSB9IHNyYyAtIHRoZSBub2RlIHRoYXQgd2lsbCBkbyB0aGUgaW5zZXJ0aW5nIG9yIGFwcGVuZGluZ1xuICogQHBhcmFtIHsgVGFnIH0gdGFyZ2V0IC0gb25seSBpZiBpbnNlcnRpbmcsIGluc2VydCBiZWZvcmUgdGhpcyB0YWcncyBmaXJzdCBjaGlsZFxuICovXG5mdW5jdGlvbiBtYWtlVmlydHVhbChzcmMsIHRhcmdldCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaGVhZCA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCksXG4gICAgdGFpbCA9IGNyZWF0ZURPTVBsYWNlaG9sZGVyKCksXG4gICAgZnJhZyA9IGNyZWF0ZUZyYWcoKSxcbiAgICBzaWIsIGVsO1xuXG4gIHRoaXMucm9vdC5pbnNlcnRCZWZvcmUoaGVhZCwgdGhpcy5yb290LmZpcnN0Q2hpbGQpO1xuICB0aGlzLnJvb3QuYXBwZW5kQ2hpbGQodGFpbCk7XG5cbiAgdGhpcy5fXy5oZWFkID0gZWwgPSBoZWFkO1xuICB0aGlzLl9fLnRhaWwgPSB0YWlsO1xuXG4gIHdoaWxlIChlbCkge1xuICAgIHNpYiA9IGVsLm5leHRTaWJsaW5nO1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHRoaXMkMS5fXy52aXJ0cy5wdXNoKGVsKTsgLy8gaG9sZCBmb3IgdW5tb3VudGluZ1xuICAgIGVsID0gc2liO1xuICB9XG5cbiAgaWYgKHRhcmdldClcbiAgICB7IHNyYy5pbnNlcnRCZWZvcmUoZnJhZywgdGFyZ2V0Ll9fLmhlYWQpOyB9XG4gIGVsc2VcbiAgICB7IHNyYy5hcHBlbmRDaGlsZChmcmFnKTsgfVxufVxuXG4vKipcbiAqIE1vdmUgdmlydHVhbCB0YWcgYW5kIGFsbCBjaGlsZCBub2Rlc1xuICogQHRoaXMgVGFnXG4gKiBAcGFyYW0geyBOb2RlIH0gc3JjICAtIHRoZSBub2RlIHRoYXQgd2lsbCBkbyB0aGUgaW5zZXJ0aW5nXG4gKiBAcGFyYW0geyBUYWcgfSB0YXJnZXQgLSBpbnNlcnQgYmVmb3JlIHRoaXMgdGFnJ3MgZmlyc3QgY2hpbGRcbiAqL1xuZnVuY3Rpb24gbW92ZVZpcnR1YWwoc3JjLCB0YXJnZXQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVsID0gdGhpcy5fXy5oZWFkLFxuICAgIGZyYWcgPSBjcmVhdGVGcmFnKCksXG4gICAgc2liO1xuXG4gIHdoaWxlIChlbCkge1xuICAgIHNpYiA9IGVsLm5leHRTaWJsaW5nO1xuICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIGVsID0gc2liO1xuICAgIGlmIChlbCA9PT0gdGhpcyQxLl9fLnRhaWwpIHtcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgc3JjLmluc2VydEJlZm9yZShmcmFnLCB0YXJnZXQuX18uaGVhZCk7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBzZWxlY3RvcnMgZm9yIHRhZ3NcbiAqIEBwYXJhbSAgIHsgQXJyYXkgfSB0YWdzIC0gdGFnIG5hbWVzIHRvIHNlbGVjdFxuICogQHJldHVybnMgeyBTdHJpbmcgfSBzZWxlY3RvclxuICovXG5mdW5jdGlvbiBzZWxlY3RUYWdzKHRhZ3MpIHtcbiAgLy8gc2VsZWN0IGFsbCB0YWdzXG4gIGlmICghdGFncykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoX19UQUdfSU1QTCk7XG4gICAgcmV0dXJuIGtleXMgKyBzZWxlY3RUYWdzKGtleXMpXG4gIH1cblxuICByZXR1cm4gdGFnc1xuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHQpIHsgcmV0dXJuICEvW14tXFx3XS8udGVzdCh0KTsgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uIChsaXN0LCB0KSB7XG4gICAgICB2YXIgbmFtZSA9IHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gbGlzdCArIFwiLFtcIiArIElTX0RJUkVDVElWRSArIFwiPVxcXCJcIiArIG5hbWUgKyBcIlxcXCJdXCJcbiAgICB9LCAnJylcbn1cblxuXG52YXIgdGFncyA9IE9iamVjdC5mcmVlemUoe1xuXHRnZXRUYWc6IGdldFRhZyxcblx0aW5oZXJpdEZyb206IGluaGVyaXRGcm9tLFxuXHRtb3ZlQ2hpbGRUYWc6IG1vdmVDaGlsZFRhZyxcblx0aW5pdENoaWxkVGFnOiBpbml0Q2hpbGRUYWcsXG5cdGdldEltbWVkaWF0ZUN1c3RvbVBhcmVudFRhZzogZ2V0SW1tZWRpYXRlQ3VzdG9tUGFyZW50VGFnLFxuXHR1bm1vdW50QWxsOiB1bm1vdW50QWxsLFxuXHRnZXRUYWdOYW1lOiBnZXRUYWdOYW1lLFxuXHRjbGVhblVwRGF0YTogY2xlYW5VcERhdGEsXG5cdGFycmF5aXNoQWRkOiBhcnJheWlzaEFkZCxcblx0YXJyYXlpc2hSZW1vdmU6IGFycmF5aXNoUmVtb3ZlLFxuXHRtb3VudFRvOiBtb3VudFRvLFxuXHRtYWtlUmVwbGFjZVZpcnR1YWw6IG1ha2VSZXBsYWNlVmlydHVhbCxcblx0bWFrZVZpcnR1YWw6IG1ha2VWaXJ0dWFsLFxuXHRtb3ZlVmlydHVhbDogbW92ZVZpcnR1YWwsXG5cdHNlbGVjdFRhZ3M6IHNlbGVjdFRhZ3Ncbn0pO1xuXG4vKipcbiAqIFJpb3QgcHVibGljIGFwaVxuICovXG52YXIgc2V0dGluZ3MgPSBzZXR0aW5ncyQxO1xudmFyIHV0aWwgPSB7XG4gIHRtcGw6IHRtcGwsXG4gIGJyYWNrZXRzOiBicmFja2V0cyxcbiAgc3R5bGVNYW5hZ2VyOiBzdHlsZU1hbmFnZXIsXG4gIHZkb206IF9fVEFHU19DQUNIRSxcbiAgc3R5bGVOb2RlOiBzdHlsZU1hbmFnZXIuc3R5bGVOb2RlLFxuICAvLyBleHBvcnQgdGhlIHJpb3QgaW50ZXJuYWwgdXRpbHMgYXMgd2VsbFxuICBkb206IGRvbSxcbiAgY2hlY2s6IGNoZWNrLFxuICBtaXNjOiBtaXNjLFxuICB0YWdzOiB0YWdzXG59O1xuXG4vLyBleHBvcnQgdGhlIGNvcmUgcHJvcHMvbWV0aG9kc1xudmFyIFRhZyQkMSA9IFRhZyQyO1xudmFyIHRhZyQkMSA9IHRhZyQxO1xudmFyIHRhZzIkJDEgPSB0YWcyJDE7XG52YXIgbW91bnQkMSA9IG1vdW50JDI7XG52YXIgbWl4aW4kJDEgPSBtaXhpbiQxO1xudmFyIHVwZGF0ZSQkMSA9IHVwZGF0ZSQxO1xudmFyIHVucmVnaXN0ZXIkJDEgPSB1bnJlZ2lzdGVyJDE7XG52YXIgdmVyc2lvbiQkMSA9IHZlcnNpb24kMTtcbnZhciBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZSQxO1xuXG52YXIgcmlvdCQxID0gZXh0ZW5kKHt9LCBjb3JlLCB7XG4gIG9ic2VydmFibGU6IG9ic2VydmFibGUkMSxcbiAgc2V0dGluZ3M6IHNldHRpbmdzLFxuICB1dGlsOiB1dGlsLFxufSk7XG5cblxudmFyIHJpb3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdHV0aWw6IHV0aWwsXG5cdFRhZzogVGFnJCQxLFxuXHR0YWc6IHRhZyQkMSxcblx0dGFnMjogdGFnMiQkMSxcblx0bW91bnQ6IG1vdW50JDEsXG5cdG1peGluOiBtaXhpbiQkMSxcblx0dXBkYXRlOiB1cGRhdGUkJDEsXG5cdHVucmVnaXN0ZXI6IHVucmVnaXN0ZXIkJDEsXG5cdHZlcnNpb246IHZlcnNpb24kJDEsXG5cdG9ic2VydmFibGU6IG9ic2VydmFibGUsXG5cdGRlZmF1bHQ6IHJpb3QkMVxufSk7XG5cbi8qKlxuICogQ29tcGlsZXIgZm9yIHJpb3QgY3VzdG9tIHRhZ3NcbiAqIEB2ZXJzaW9uIHYzLjIuMVxuICovXG5cbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5mdW5jdGlvbiBzYWZlUmVnZXggKHJlKSB7XG4gIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICB2YXIgc3JjID0gcmUuc291cmNlO1xuICB2YXIgb3B0ID0gcmUuZ2xvYmFsID8gJ2cnIDogJyc7XG5cbiAgaWYgKHJlLmlnbm9yZUNhc2UpIHsgb3B0ICs9ICdpJzsgfVxuICBpZiAocmUubXVsdGlsaW5lKSAgeyBvcHQgKz0gJ20nOyB9XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBzcmMgPSBzcmMucmVwbGFjZSgnQCcsICdcXFxcJyArIGFyZ3VtZW50cyQxW2ldKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVnRXhwKHNyYywgb3B0KVxufVxuXG4vKipcbiAqIEBtb2R1bGUgcGFyc2Vyc1xuICovXG52YXIgcGFyc2VycyQxID0gKGZ1bmN0aW9uICh3aW4pIHtcblxuICB2YXIgX3AgPSB7fTtcblxuICBmdW5jdGlvbiBfciAobmFtZSkge1xuICAgIHZhciBwYXJzZXIgPSB3aW5bbmFtZV07XG5cbiAgICBpZiAocGFyc2VyKSB7IHJldHVybiBwYXJzZXIgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgXCInICsgbmFtZSArICdcIiBub3QgbG9hZGVkLicpXG4gIH1cblxuICBmdW5jdGlvbiBfcmVxIChuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikgeyB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBmb3JtYXQgZm9yIHBhcnNlcnMuX3JlcScpIH1cblxuICAgIHZhciBwYXJzZXIgPSBfcFtwYXJ0c1swXV1bcGFydHNbMV1dO1xuICAgIGlmIChwYXJzZXIpIHsgcmV0dXJuIHBhcnNlciB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlciBcIicgKyBuYW1lICsgJ1wiIG5vdCBmb3VuZC4nKVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kIChvYmosIHByb3BzKSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHByb3BzW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclB1ZyAoY29tcGlsZXJOYW1lLCBodG1sLCBvcHRzLCB1cmwpIHtcbiAgICBvcHRzID0gZXh0ZW5kKHtcbiAgICAgIHByZXR0eTogdHJ1ZSxcbiAgICAgIGZpbGVuYW1lOiB1cmwsXG4gICAgICBkb2N0eXBlOiAnaHRtbCdcbiAgICB9LCBvcHRzKTtcbiAgICByZXR1cm4gX3IoY29tcGlsZXJOYW1lKS5yZW5kZXIoaHRtbCwgb3B0cylcbiAgfVxuXG4gIF9wLmh0bWwgPSB7XG4gICAgamFkZTogZnVuY3Rpb24gKGh0bWwsIG9wdHMsIHVybCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIGNvbnNvbGUubG9nKCdERVBSRUNBVElPTiBXQVJOSU5HOiBqYWRlIHdhcyByZW5hbWVkIFwicHVnXCIgLSBUaGUgamFkZSBwYXJzZXIgd2lsbCBiZSByZW1vdmVkIGluIHJpb3RAMy4wLjAhJyk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICByZXR1cm4gcmVuZGVyUHVnKCdqYWRlJywgaHRtbCwgb3B0cywgdXJsKVxuICAgIH0sXG4gICAgcHVnOiBmdW5jdGlvbiAoaHRtbCwgb3B0cywgdXJsKSB7XG4gICAgICByZXR1cm4gcmVuZGVyUHVnKCdwdWcnLCBodG1sLCBvcHRzLCB1cmwpXG4gICAgfVxuICB9O1xuICBfcC5jc3MgPSB7XG4gICAgbGVzczogZnVuY3Rpb24gKHRhZywgY3NzLCBvcHRzLCB1cmwpIHtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIG9wdHMgPSBleHRlbmQoe1xuICAgICAgICBzeW5jOiB0cnVlLFxuICAgICAgICBzeW5jSW1wb3J0OiB0cnVlLFxuICAgICAgICBmaWxlbmFtZTogdXJsXG4gICAgICB9LCBvcHRzKTtcbiAgICAgIF9yKCdsZXNzJykucmVuZGVyKGNzcywgb3B0cywgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIGlmIChlcnIpIHsgdGhyb3cgZXJyIH1cbiAgICAgICAgcmV0ID0gcmVzdWx0LmNzcztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldFxuICAgIH1cbiAgfTtcbiAgX3AuanMgPSB7XG5cbiAgICBlczY6IGZ1bmN0aW9uIChqcywgb3B0cywgdXJsKSB7XG4gICAgICByZXR1cm4gX3IoJ0JhYmVsJykudHJhbnNmb3JtKCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGpzLFxuICAgICAgICBleHRlbmQoe1xuICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIFsndHJhbnNmb3JtLWVzMjAxNS10ZW1wbGF0ZS1saXRlcmFscycsIHsgbG9vc2U6IHRydWUgfV0sXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1saXRlcmFscycsXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1mdW5jdGlvbi1uYW1lJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tZXMyMDE1LWFycm93LWZ1bmN0aW9ucycsXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1ibG9jay1zY29wZWQtZnVuY3Rpb25zJyxcbiAgICAgICAgICAgIFsndHJhbnNmb3JtLWVzMjAxNS1jbGFzc2VzJywgeyBsb29zZTogdHJ1ZSB9XSxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tZXMyMDE1LW9iamVjdC1zdXBlcicsXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1zaG9ydGhhbmQtcHJvcGVydGllcycsXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1kdXBsaWNhdGUta2V5cycsXG4gICAgICAgICAgICBbJ3RyYW5zZm9ybS1lczIwMTUtY29tcHV0ZWQtcHJvcGVydGllcycsIHsgbG9vc2U6IHRydWUgfV0sXG4gICAgICAgICAgICBbJ3RyYW5zZm9ybS1lczIwMTUtZm9yLW9mJywgeyBsb29zZTogdHJ1ZSB9XSxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tZXMyMDE1LXN0aWNreS1yZWdleCcsXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS11bmljb2RlLXJlZ2V4JyxcbiAgICAgICAgICAgICdjaGVjay1lczIwMTUtY29uc3RhbnRzJyxcbiAgICAgICAgICAgIFsndHJhbnNmb3JtLWVzMjAxNS1zcHJlYWQnLCB7IGxvb3NlOiB0cnVlIH1dLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtcGFyYW1ldGVycycsXG4gICAgICAgICAgICBbJ3RyYW5zZm9ybS1lczIwMTUtZGVzdHJ1Y3R1cmluZycsIHsgbG9vc2U6IHRydWUgfV0sXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1ibG9jay1zY29waW5nJyxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tZXMyMDE1LXR5cGVvZi1zeW1ib2wnLFxuICAgICAgICAgICAgWyd0cmFuc2Zvcm0tZXMyMDE1LW1vZHVsZXMtY29tbW9uanMnLCB7IGFsbG93VG9wTGV2ZWxUaGlzOiB0cnVlIH1dLFxuICAgICAgICAgICAgWyd0cmFuc2Zvcm0tcmVnZW5lcmF0b3InLCB7IGFzeW5jOiBmYWxzZSwgYXN5bmNHZW5lcmF0b3JzOiBmYWxzZSB9XVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0c1xuICAgICAgKSkuY29kZVxuICAgIH0sXG4gICAgYnVibGU6IGZ1bmN0aW9uIChqcywgb3B0cywgdXJsKSB7XG4gICAgICBvcHRzID0gZXh0ZW5kKHtcbiAgICAgICAgc291cmNlOiB1cmwsXG4gICAgICAgIG1vZHVsZXM6IGZhbHNlXG4gICAgICB9LCBvcHRzKTtcbiAgICAgIHJldHVybiBfcignYnVibGUnKS50cmFuc2Zvcm0oanMsIG9wdHMpLmNvZGVcbiAgICB9LFxuICAgIGNvZmZlZTogZnVuY3Rpb24gKGpzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gX3IoJ0NvZmZlZVNjcmlwdCcpLmNvbXBpbGUoanMsIGV4dGVuZCh7IGJhcmU6IHRydWUgfSwgb3B0cykpXG4gICAgfSxcbiAgICBsaXZlc2NyaXB0OiBmdW5jdGlvbiAoanMsIG9wdHMpIHtcbiAgICAgIHJldHVybiBfcignbGl2ZXNjcmlwdCcpLmNvbXBpbGUoanMsIGV4dGVuZCh7IGJhcmU6IHRydWUsIGhlYWRlcjogZmFsc2UgfSwgb3B0cykpXG4gICAgfSxcbiAgICB0eXBlc2NyaXB0OiBmdW5jdGlvbiAoanMsIG9wdHMpIHtcbiAgICAgIHJldHVybiBfcigndHlwZXNjcmlwdCcpKGpzLCBvcHRzKVxuICAgIH0sXG4gICAgbm9uZTogZnVuY3Rpb24gKGpzKSB7XG4gICAgICByZXR1cm4ganNcbiAgICB9XG4gIH07XG4gIF9wLmpzLmphdmFzY3JpcHQgICA9IF9wLmpzLm5vbmU7XG4gIF9wLmpzLmNvZmZlZXNjcmlwdCA9IF9wLmpzLmNvZmZlZTtcbiAgX3AuX3JlcSAgPSBfcmVxO1xuICBfcC51dGlscyA9IHtcbiAgICBleHRlbmQ6IGV4dGVuZFxuICB9O1xuXG4gIHJldHVybiBfcFxuXG59KSh3aW5kb3cgfHwgZ2xvYmFsKTtcblxuLyoqXG4gKiBAbW9kdWxlIGNvbXBpbGVyXG4gKi9cblxudmFyIGV4dGVuZCQxID0gcGFyc2VycyQxLnV0aWxzLmV4dGVuZDtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIFNfTElORVNUUiA9IC9cIlteXCJcXG5cXFxcXSooPzpcXFxcW1xcU1xcc11bXlwiXFxuXFxcXF0qKSpcInwnW14nXFxuXFxcXF0qKD86XFxcXFtcXFNcXHNdW14nXFxuXFxcXF0qKSonLy5zb3VyY2U7XG5cbnZhciBTX1NUUklOR1MgPSBicmFja2V0cy5SX1NUUklOR1Muc291cmNlO1xuXG52YXIgSFRNTF9BVFRSUyA9IC8gKihbLVxcdzpcXHhBMC1cXHhGRl0rKSA/KD86PSA/KCdbXiddKid8XCJbXlwiXSpcInxcXFMrKSk/L2c7XG5cbnZhciBIVE1MX0NPTU1TID0gUmVnRXhwKC88IS0tKD8hPilbXFxTXFxzXSo/LS0+Ly5zb3VyY2UgKyAnfCcgKyBTX0xJTkVTVFIsICdnJyk7XG5cbnZhciBIVE1MX1RBR1MgPSAvPCgtP1tBLVphLXpdWy1cXHdcXHhBMC1cXHhGRl0qKSg/OlxccysoW15cIidcXC8+XSooPzooPzpcIlteXCJdKlwifCdbXiddKid8XFwvW14+XSlbXidcIlxcLz5dKikqKXxcXHMqKShcXC8/KT4vZztcblxudmFyIEhUTUxfUEFDSyA9IC8+WyBcXHRdKzwoLT9bQS1aYS16XXxcXC9bLUEtWmEtel0pL2c7XG5cbnZhciBSSU9UX0FUVFJTID0gWydzdHlsZScsICdzcmMnLCAnZCcsICd2YWx1ZSddO1xuXG52YXIgVk9JRF9UQUdTID0gL14oPzppbnB1dHxpbWd8YnJ8d2JyfGhyfGFyZWF8YmFzZXxjb2x8ZW1iZWR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2spJC87XG5cbnZhciBQUkVfVEFHUyA9IC88cHJlKD86XFxzKyg/OlteXCI+XSp8XCJbXlwiXSpcIikqKT8+KFtcXFNcXHNdKz8pPFxcL3ByZVxccyo+L2dpO1xuXG52YXIgU1BFQ19UWVBFUyA9IC9eXCIoPzpudW1iZXJ8ZGF0ZSg/OnRpbWUpP3x0aW1lfG1vbnRofGVtYWlsfGNvbG9yKVxcYi9pO1xuXG52YXIgSU1QT1JUX1NUQVRFTUVOVCA9IC9eXFxzKmltcG9ydCg/IVxcdykoPzooPzpcXHN8W15cXHMnXCJdKSopWyd8XCJdLipcXG4/L2dtO1xuXG52YXIgVFJJTV9UUkFJTCA9IC9bIFxcdF0rJC9nbTtcblxudmFyIFJFX0hBU0VYUFIgPSBzYWZlUmVnZXgoL0AjXFxkLywgJ3gwMScpO1xudmFyIFJFX1JFUEVYUFIgPSBzYWZlUmVnZXgoL0AjKFxcZCspL2csICd4MDEnKTtcbnZhciBDSF9JREVYUFIgID0gJ1xceDAxIyc7XG52YXIgQ0hfRFFDT0RFICA9ICdcXHUyMDU3JztcbnZhciBEUSA9ICdcIic7XG52YXIgU1EgPSBcIidcIjtcblxuZnVuY3Rpb24gY2xlYW5Tb3VyY2UgKHNyYykge1xuICB2YXJcbiAgICBtbSxcbiAgICByZSA9IEhUTUxfQ09NTVM7XG5cbiAgaWYgKH5zcmMuaW5kZXhPZignXFxyJykpIHtcbiAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJyk7XG4gIH1cblxuICByZS5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAoKG1tID0gcmUuZXhlYyhzcmMpKSkge1xuICAgIGlmIChtbVswXVswXSA9PT0gJzwnKSB7XG4gICAgICBzcmMgPSBSZWdFeHAubGVmdENvbnRleHQgKyBSZWdFeHAucmlnaHRDb250ZXh0O1xuICAgICAgcmUubGFzdEluZGV4ID0gbW1bM10gKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3JjXG59XG5cbmZ1bmN0aW9uIHBhcnNlQXR0cmlicyAoc3RyLCBwY2V4KSB7XG4gIHZhclxuICAgIGxpc3QgPSBbXSxcbiAgICBtYXRjaCxcbiAgICB0eXBlLCB2ZXhwO1xuXG4gIEhUTUxfQVRUUlMubGFzdEluZGV4ID0gMDtcblxuICBzdHIgPSBzdHIucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXG4gIHdoaWxlICgobWF0Y2ggPSBIVE1MX0FUVFJTLmV4ZWMoc3RyKSkpIHtcbiAgICB2YXJcbiAgICAgIGsgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgdiA9IG1hdGNoWzJdO1xuXG4gICAgaWYgKCF2KSB7XG4gICAgICBsaXN0LnB1c2goayk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKHZbMF0gIT09IERRKSB7XG4gICAgICAgIHYgPSBEUSArICh2WzBdID09PSBTUSA/IHYuc2xpY2UoMSwgLTEpIDogdikgKyBEUTtcbiAgICAgIH1cblxuICAgICAgaWYgKGsgPT09ICd0eXBlJyAmJiBTUEVDX1RZUEVTLnRlc3QodikpIHtcbiAgICAgICAgdHlwZSA9IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoUkVfSEFTRVhQUi50ZXN0KHYpKSB7XG5cbiAgICAgICAgICBpZiAoayA9PT0gJ3ZhbHVlJykgeyB2ZXhwID0gMTsgfVxuICAgICAgICAgIGlmICh+UklPVF9BVFRSUy5pbmRleE9mKGspKSB7IGsgPSAncmlvdC0nICsgazsgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdC5wdXNoKGsgKyAnPScgKyB2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSkge1xuICAgIGlmICh2ZXhwKSB7IHR5cGUgPSBEUSArIHBjZXguX2JwWzBdICsgU1EgKyB0eXBlLnNsaWNlKDEsIC0xKSArIFNRICsgcGNleC5fYnBbMV0gKyBEUTsgfVxuICAgIGxpc3QucHVzaCgndHlwZT0nICsgdHlwZSk7XG4gIH1cbiAgcmV0dXJuIGxpc3Quam9pbignICcpXG59XG5cbmZ1bmN0aW9uIHNwbGl0SHRtbCAoaHRtbCwgb3B0cywgcGNleCkge1xuICB2YXIgX2JwID0gcGNleC5fYnA7XG5cbiAgaWYgKGh0bWwgJiYgX2JwWzRdLnRlc3QoaHRtbCkpIHtcbiAgICB2YXJcbiAgICAgIGpzZm4gPSBvcHRzLmV4cHIgJiYgKG9wdHMucGFyc2VyIHx8IG9wdHMudHlwZSkgPyBfY29tcGlsZUpTIDogMCxcbiAgICAgIGxpc3QgPSBicmFja2V0cy5zcGxpdChodG1sLCAwLCBfYnApLFxuICAgICAgZXhwcjtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgZXhwciA9IGxpc3RbaV07XG4gICAgICBpZiAoZXhwclswXSA9PT0gJ14nKSB7XG4gICAgICAgIGV4cHIgPSBleHByLnNsaWNlKDEpO1xuICAgICAgfSBlbHNlIGlmIChqc2ZuKSB7XG4gICAgICAgIGV4cHIgPSBqc2ZuKGV4cHIsIG9wdHMpLnRyaW0oKTtcbiAgICAgICAgaWYgKGV4cHIuc2xpY2UoLTEpID09PSAnOycpIHsgZXhwciA9IGV4cHIuc2xpY2UoMCwgLTEpOyB9XG4gICAgICB9XG4gICAgICBsaXN0W2ldID0gQ0hfSURFWFBSICsgKHBjZXgucHVzaChleHByKSAtIDEpICsgX2JwWzFdO1xuICAgIH1cbiAgICBodG1sID0gbGlzdC5qb2luKCcnKTtcbiAgfVxuICByZXR1cm4gaHRtbFxufVxuXG5mdW5jdGlvbiByZXN0b3JlRXhwciAoaHRtbCwgcGNleCkge1xuICBpZiAocGNleC5sZW5ndGgpIHtcbiAgICBodG1sID0gaHRtbC5yZXBsYWNlKFJFX1JFUEVYUFIsIGZ1bmN0aW9uIChfLCBkKSB7XG5cbiAgICAgIHJldHVybiBwY2V4Ll9icFswXSArIHBjZXhbZF0udHJpbSgpLnJlcGxhY2UoL1tcXHJcXG5dKy9nLCAnICcpLnJlcGxhY2UoL1wiL2csIENIX0RRQ09ERSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaHRtbFxufVxuXG5mdW5jdGlvbiBfY29tcGlsZUhUTUwgKGh0bWwsIG9wdHMsIHBjZXgpIHtcbiAgaWYgKCEvXFxTLy50ZXN0KGh0bWwpKSB7IHJldHVybiAnJyB9XG5cbiAgaHRtbCA9IHNwbGl0SHRtbChodG1sLCBvcHRzLCBwY2V4KVxuICAgIC5yZXBsYWNlKEhUTUxfVEFHUywgZnVuY3Rpb24gKF8sIG5hbWUsIGF0dHIsIGVuZHMpIHtcblxuICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgZW5kcyA9IGVuZHMgJiYgIVZPSURfVEFHUy50ZXN0KG5hbWUpID8gJz48LycgKyBuYW1lIDogJyc7XG5cbiAgICAgIGlmIChhdHRyKSB7IG5hbWUgKz0gJyAnICsgcGFyc2VBdHRyaWJzKGF0dHIsIHBjZXgpOyB9XG5cbiAgICAgIHJldHVybiAnPCcgKyBuYW1lICsgZW5kcyArICc+J1xuICAgIH0pO1xuXG4gIGlmICghb3B0cy53aGl0ZXNwYWNlKSB7XG4gICAgdmFyIHAgPSBbXTtcblxuICAgIGlmICgvPHByZVtcXHM+XS8udGVzdChodG1sKSkge1xuICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZShQUkVfVEFHUywgZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgcC5wdXNoKHEpO1xuICAgICAgICByZXR1cm4gJ1xcdTAwMDInXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBodG1sID0gaHRtbC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXG4gICAgaWYgKHAubGVuZ3RoKSB7IGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcdTAwMDIvZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gcC5zaGlmdCgpIH0pOyB9XG4gIH1cblxuICBpZiAob3B0cy5jb21wYWN0KSB7IGh0bWwgPSBodG1sLnJlcGxhY2UoSFRNTF9QQUNLLCAnPjwkMScpOyB9XG5cbiAgcmV0dXJuIHJlc3RvcmVFeHByKGh0bWwsIHBjZXgpLnJlcGxhY2UoVFJJTV9UUkFJTCwgJycpXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVIVE1MIChodG1sLCBvcHRzLCBwY2V4KSB7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICBwY2V4ID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFwY2V4KSB7IHBjZXggPSBbXTsgfVxuICAgIGlmICghb3B0cykgeyBvcHRzID0ge307IH1cbiAgfVxuXG4gIHBjZXguX2JwID0gYnJhY2tldHMuYXJyYXkob3B0cy5icmFja2V0cyk7XG5cbiAgcmV0dXJuIF9jb21waWxlSFRNTChjbGVhblNvdXJjZShodG1sKSwgb3B0cywgcGNleClcbn1cblxudmFyIEpTX0VTNlNJR04gPSAvXlsgXFx0XSooKCg/OmFzeW5jfFxcKilcXHMqKT8oWyRfQS1aYS16XVskXFx3XSopKVxccypcXChbXigpXSpcXClcXHMqey9tO1xuXG52YXIgSlNfRVM2RU5EID0gUmVnRXhwKCdbe31dfCcgKyBicmFja2V0cy5TX1FCTE9DS1MsICdnJyk7XG5cbnZhciBKU19DT01NUyA9IFJlZ0V4cChicmFja2V0cy5SX01MQ09NTVMuc291cmNlICsgJ3wvL1teXFxyXFxuXSp8JyArIGJyYWNrZXRzLlNfUUJMT0NLUywgJ2cnKTtcblxuZnVuY3Rpb24gcmlvdGpzIChqcykge1xuICB2YXJcbiAgICBwYXJ0cyA9IFtdLFxuICAgIG1hdGNoLFxuICAgIHRvZXM1LFxuICAgIHBvcyxcbiAgICBtZXRob2QsXG4gICAgcHJlZml4LFxuICAgIG5hbWUsXG4gICAgUkUgPSBSZWdFeHA7XG5cbiAgaWYgKH5qcy5pbmRleE9mKCcvJykpIHsganMgPSBybUNvbW1zKGpzLCBKU19DT01NUyk7IH1cblxuICB3aGlsZSAoKG1hdGNoID0ganMubWF0Y2goSlNfRVM2U0lHTikpKSB7XG5cbiAgICBwYXJ0cy5wdXNoKFJFLmxlZnRDb250ZXh0KTtcbiAgICBqcyAgPSBSRS5yaWdodENvbnRleHQ7XG4gICAgcG9zID0gc2tpcEJvZHkoanMsIEpTX0VTNkVORCk7XG5cbiAgICBtZXRob2QgPSBtYXRjaFsxXTtcbiAgICBwcmVmaXggPSBtYXRjaFsyXSB8fCAnJztcbiAgICBuYW1lICA9IG1hdGNoWzNdO1xuXG4gICAgdG9lczUgPSAhL14oPzppZnx3aGlsZXxmb3J8c3dpdGNofGNhdGNofGZ1bmN0aW9uKSQvLnRlc3QobmFtZSk7XG5cbiAgICBpZiAodG9lczUpIHtcbiAgICAgIG5hbWUgPSBtYXRjaFswXS5yZXBsYWNlKG1ldGhvZCwgJ3RoaXMuJyArIG5hbWUgKyAnID0nICsgcHJlZml4ICsgJyBmdW5jdGlvbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMF07XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChuYW1lLCBqcy5zbGljZSgwLCBwb3MpKTtcbiAgICBqcyA9IGpzLnNsaWNlKHBvcyk7XG5cbiAgICBpZiAodG9lczUgJiYgIS9eXFxzKi5cXHMqYmluZFxcYi8udGVzdChqcykpIHsgcGFydHMucHVzaCgnLmJpbmQodGhpcyknKTsgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA/IHBhcnRzLmpvaW4oJycpICsganMgOiBqc1xuXG4gIGZ1bmN0aW9uIHJtQ29tbXMgKHMsIHIsIG0pIHtcbiAgICByLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gci5leGVjKHMpKSkge1xuICAgICAgaWYgKG1bMF1bMF0gPT09ICcvJyAmJiAhbVsxXSAmJiAhbVsyXSkge1xuICAgICAgICBzID0gUkUubGVmdENvbnRleHQgKyAnICcgKyBSRS5yaWdodENvbnRleHQ7XG4gICAgICAgIHIubGFzdEluZGV4ID0gbVszXSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzXG4gIH1cblxuICBmdW5jdGlvbiBza2lwQm9keSAocywgcikge1xuICAgIHZhciBtLCBpID0gMTtcblxuICAgIHIubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaSAmJiAobSA9IHIuZXhlYyhzKSkpIHtcbiAgICAgIGlmIChtWzBdID09PSAneycpIHsgKytpOyB9XG4gICAgICBlbHNlIGlmIChtWzBdID09PSAnfScpIHsgLS1pOyB9XG4gICAgfVxuICAgIHJldHVybiBpID8gcy5sZW5ndGggOiByLmxhc3RJbmRleFxuICB9XG59XG5cbmZ1bmN0aW9uIF9jb21waWxlSlMgKGpzLCBvcHRzLCB0eXBlLCBwYXJzZXJPcHRzLCB1cmwpIHtcbiAgaWYgKCEvXFxTLy50ZXN0KGpzKSkgeyByZXR1cm4gJycgfVxuICBpZiAoIXR5cGUpIHsgdHlwZSA9IG9wdHMudHlwZTsgfVxuXG4gIHZhciBwYXJzZXIgPSBvcHRzLnBhcnNlciB8fCB0eXBlICYmIHBhcnNlcnMkMS5fcmVxKCdqcy4nICsgdHlwZSwgdHJ1ZSkgfHwgcmlvdGpzO1xuXG4gIHJldHVybiBwYXJzZXIoanMsIHBhcnNlck9wdHMsIHVybCkucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJykucmVwbGFjZShUUklNX1RSQUlMLCAnJylcbn1cblxuZnVuY3Rpb24gY29tcGlsZUpTIChqcywgb3B0cywgdHlwZSwgdXNlck9wdHMpIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgIHVzZXJPcHRzID0gdHlwZTtcbiAgICB0eXBlID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgaWYgKHR5cGUgJiYgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdXNlck9wdHMgPSB0eXBlO1xuICAgIHR5cGUgPSAnJztcbiAgfVxuICBpZiAoIXVzZXJPcHRzKSB7IHVzZXJPcHRzID0ge307IH1cblxuICByZXR1cm4gX2NvbXBpbGVKUyhqcywgb3B0cyB8fCB7fSwgdHlwZSwgdXNlck9wdHMucGFyc2VyT3B0aW9ucywgdXNlck9wdHMudXJsKVxufVxuXG52YXIgQ1NTX1NFTEVDVE9SID0gUmVnRXhwKCcoW3t9XXxeKVs7IF0qKCg/OlteQCA7e31dW157fV0qKT9bXkAgO3t9Ol0gPykoPz17KXwnICsgU19MSU5FU1RSLCAnZycpO1xuXG5mdW5jdGlvbiBzY29wZWRDU1MgKHRhZywgY3NzKSB7XG4gIHZhciBzY29wZSA9ICc6c2NvcGUnO1xuXG4gIHJldHVybiBjc3MucmVwbGFjZShDU1NfU0VMRUNUT1IsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcblxuICAgIGlmICghcDIpIHsgcmV0dXJuIG0gfVxuXG4gICAgcDIgPSBwMi5yZXBsYWNlKC9bXixdKy9nLCBmdW5jdGlvbiAoc2VsKSB7XG4gICAgICB2YXIgcyA9IHNlbC50cmltKCk7XG5cbiAgICAgIGlmIChzLmluZGV4T2YodGFnKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsXG4gICAgICB9XG5cbiAgICAgIGlmICghcyB8fCBzID09PSAnZnJvbScgfHwgcyA9PT0gJ3RvJyB8fCBzLnNsaWNlKC0xKSA9PT0gJyUnKSB7XG4gICAgICAgIHJldHVybiBzZWxcbiAgICAgIH1cblxuICAgICAgaWYgKHMuaW5kZXhPZihzY29wZSkgPCAwKSB7XG4gICAgICAgIHMgPSB0YWcgKyAnICcgKyBzICsgJyxbZGF0YS1pcz1cIicgKyB0YWcgKyAnXCJdICcgKyBzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShzY29wZSwgdGFnKSArICcsJyArXG4gICAgICAgICAgICBzLnJlcGxhY2Uoc2NvcGUsICdbZGF0YS1pcz1cIicgKyB0YWcgKyAnXCJdJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHAxID8gcDEgKyAnICcgKyBwMiA6IHAyXG4gIH0pXG59XG5cbmZ1bmN0aW9uIF9jb21waWxlQ1NTIChjc3MsIHRhZywgdHlwZSwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodHlwZSkge1xuICAgIGlmICh0eXBlICE9PSAnY3NzJykge1xuXG4gICAgICB2YXIgcGFyc2VyID0gcGFyc2VycyQxLl9yZXEoJ2Nzcy4nICsgdHlwZSwgdHJ1ZSk7XG4gICAgICBjc3MgPSBwYXJzZXIodGFnLCBjc3MsIG9wdHMucGFyc2VyT3B0cyB8fCB7fSwgb3B0cy51cmwpO1xuICAgIH1cbiAgfVxuXG4gIGNzcyA9IGNzcy5yZXBsYWNlKGJyYWNrZXRzLlJfTUxDT01NUywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCk7XG4gIGlmICh0YWcpIHsgY3NzID0gc2NvcGVkQ1NTKHRhZywgY3NzKTsgfVxuXG4gIHJldHVybiBjc3Ncbn1cblxuZnVuY3Rpb24gY29tcGlsZUNTUyAoY3NzLCB0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB0eXBlO1xuICAgIHR5cGUgPSAnJztcbiAgfSBlbHNlIGlmICghb3B0cykgeyBvcHRzID0ge307IH1cblxuICByZXR1cm4gX2NvbXBpbGVDU1MoY3NzLCBvcHRzLnRhZ05hbWUsIHR5cGUsIG9wdHMpXG59XG5cbnZhciBUWVBFX0FUVFIgPSAvXFxzdHlwZVxccyo9XFxzKig/OihbJ1wiXSkoLis/KVxcMXwoXFxTKykpL2k7XG5cbnZhciBNSVNDX0FUVFIgPSAnXFxcXHMqPVxcXFxzKignICsgU19TVFJJTkdTICsgJ3x7W159XSt9fFxcXFxTKyknO1xuXG52YXIgRU5EX1RBR1MgPSAvXFwvPlxcbnxePCg/OlxcLz8tP1tBLVphLXpdWy1cXHdcXHhBMC1cXHhGRl0qXFxzKnwtP1tBLVphLXpdWy1cXHdcXHhBMC1cXHhGRl0qXFxzK1stXFx3OlxceEEwLVxceEZGXVtcXFNcXHNdKj8pPlxcbi87XG5cbmZ1bmN0aW9uIF9xIChzLCByKSB7XG4gIGlmICghcykgeyByZXR1cm4gXCInJ1wiIH1cbiAgcyA9IFNRICsgcy5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKSArIFNRO1xuICByZXR1cm4gciAmJiB+cy5pbmRleE9mKCdcXG4nKSA/IHMucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIDogc1xufVxuXG5mdW5jdGlvbiBta3RhZyAobmFtZSwgaHRtbCwgY3NzLCBhdHRyLCBqcywgaW1wb3J0cywgb3B0cykge1xuICB2YXJcbiAgICBjID0gb3B0cy5kZWJ1ZyA/ICcsXFxuICAnIDogJywgJyxcbiAgICBzID0gJ30pOyc7XG5cbiAgaWYgKGpzICYmIGpzLnNsaWNlKC0xKSAhPT0gJ1xcbicpIHsgcyA9ICdcXG4nICsgczsgfVxuXG4gIHJldHVybiBpbXBvcnRzICsgJ3Jpb3QudGFnMihcXCcnICsgbmFtZSArIFNRICtcbiAgICBjICsgX3EoaHRtbCwgMSkgK1xuICAgIGMgKyBfcShjc3MpICtcbiAgICBjICsgX3EoYXR0cikgKyAnLCBmdW5jdGlvbihvcHRzKSB7XFxuJyArIGpzICsgc1xufVxuXG5mdW5jdGlvbiBzcGxpdEJsb2NrcyAoc3RyKSB7XG4gIGlmICgvPFstXFx3XS8udGVzdChzdHIpKSB7XG4gICAgdmFyXG4gICAgICBtLFxuICAgICAgayA9IHN0ci5sYXN0SW5kZXhPZignPCcpLFxuICAgICAgbiA9IHN0ci5sZW5ndGg7XG5cbiAgICB3aGlsZSAofmspIHtcbiAgICAgIG0gPSBzdHIuc2xpY2UoaywgbikubWF0Y2goRU5EX1RBR1MpO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgayArPSBtLmluZGV4ICsgbVswXS5sZW5ndGg7XG4gICAgICAgIG0gPSBzdHIuc2xpY2UoMCwgayk7XG4gICAgICAgIGlmIChtLnNsaWNlKC01KSA9PT0gJzwtLz5cXG4nKSB7IG0gPSBtLnNsaWNlKDAsIC01KTsgfVxuICAgICAgICByZXR1cm4gW20sIHN0ci5zbGljZShrKV1cbiAgICAgIH1cbiAgICAgIG4gPSBrO1xuICAgICAgayA9IHN0ci5sYXN0SW5kZXhPZignPCcsIGsgLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsnJywgc3RyXVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlIChhdHRyaWJzKSB7XG4gIGlmIChhdHRyaWJzKSB7XG4gICAgdmFyIG1hdGNoID0gYXR0cmlicy5tYXRjaChUWVBFX0FUVFIpO1xuXG4gICAgbWF0Y2ggPSBtYXRjaCAmJiAobWF0Y2hbMl0gfHwgbWF0Y2hbM10pO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoLnJlcGxhY2UoJ3RleHQvJywgJycpXG4gICAgfVxuICB9XG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBnZXRBdHRyaWIgKGF0dHJpYnMsIG5hbWUpIHtcbiAgaWYgKGF0dHJpYnMpIHtcbiAgICB2YXIgbWF0Y2ggPSBhdHRyaWJzLm1hdGNoKFJlZ0V4cCgnXFxcXHMnICsgbmFtZSArIE1JU0NfQVRUUiwgJ2knKSk7XG5cbiAgICBtYXRjaCA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuICgvXlsnXCJdLykudGVzdChtYXRjaCkgPyBtYXRjaC5zbGljZSgxLCAtMSkgOiBtYXRjaFxuICAgIH1cbiAgfVxuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVIVE1MIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgICAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpXG4gICAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxuICAgICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcbiAgICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXG4gICAgICAgICAgLnJlcGxhY2UoLyYjMDM5Oy9nLCAnXFwnJylcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2VyT3B0aW9ucyAoYXR0cmlicykge1xuICB2YXIgb3B0cyA9IHVuZXNjYXBlSFRNTChnZXRBdHRyaWIoYXR0cmlicywgJ29wdGlvbnMnKSk7XG5cbiAgcmV0dXJuIG9wdHMgPyBKU09OLnBhcnNlKG9wdHMpIDogbnVsbFxufVxuXG5mdW5jdGlvbiBnZXRDb2RlIChjb2RlLCBvcHRzLCBhdHRyaWJzLCBiYXNlKSB7XG4gIHZhclxuICAgIHR5cGUgPSBnZXRUeXBlKGF0dHJpYnMpLFxuICAgIHNyYyAgPSBnZXRBdHRyaWIoYXR0cmlicywgJ3NyYycpLFxuICAgIGpzUGFyc2VyT3B0aW9ucyA9IGV4dGVuZCQxKHt9LCBvcHRzLnBhcnNlck9wdGlvbnMuanMpO1xuXG4gIGlmIChzcmMpIHsgcmV0dXJuIGZhbHNlIH1cblxuICByZXR1cm4gX2NvbXBpbGVKUyhcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBleHRlbmQkMShqc1BhcnNlck9wdGlvbnMsIGdldFBhcnNlck9wdGlvbnMoYXR0cmlicykpLFxuICAgICAgICAgIGJhc2VcbiAgICAgICAgKVxufVxuXG5mdW5jdGlvbiBjc3NDb2RlIChjb2RlLCBvcHRzLCBhdHRyaWJzLCB1cmwsIHRhZykge1xuICB2YXJcbiAgICBwYXJzZXJTdHlsZU9wdGlvbnMgPSBleHRlbmQkMSh7fSwgb3B0cy5wYXJzZXJPcHRpb25zLnN0eWxlKSxcbiAgICBleHRyYU9wdHMgPSB7XG4gICAgICBwYXJzZXJPcHRzOiBleHRlbmQkMShwYXJzZXJTdHlsZU9wdGlvbnMsIGdldFBhcnNlck9wdGlvbnMoYXR0cmlicykpLFxuICAgICAgdXJsOiB1cmxcbiAgICB9O1xuXG4gIHJldHVybiBfY29tcGlsZUNTUyhjb2RlLCB0YWcsIGdldFR5cGUoYXR0cmlicykgfHwgb3B0cy5zdHlsZSwgZXh0cmFPcHRzKVxufVxuXG5mdW5jdGlvbiBjb21waWxlVGVtcGxhdGUgKGh0bWwsIHVybCwgbGFuZywgb3B0cykge1xuXG4gIHZhciBwYXJzZXIgPSBwYXJzZXJzJDEuX3JlcSgnaHRtbC4nICsgbGFuZywgdHJ1ZSk7XG4gIHJldHVybiBwYXJzZXIoaHRtbCwgb3B0cywgdXJsKVxufVxuXG52YXIgQ1VTVF9UQUcgPSBSZWdFeHAoL14oWyBcXHRdKik8KC0/W0EtWmEtel1bLVxcd1xceEEwLVxceEZGXSopKD86XFxzKyhbXidcIlxcLz5dKyg/Oig/OkB8XFwvW14+XSlbXidcIlxcLz5dKikqKXxcXHMqKT8oPzpcXC8+fD5bIFxcdF0qXFxuPyhbXFxTXFxzXSopXlxcMTxcXC9cXDJcXHMqPnw+KC4qKTxcXC9cXDJcXHMqPikvXG4gICAgLnNvdXJjZS5yZXBsYWNlKCdAJywgU19TVFJJTkdTKSwgJ2dpbScpO1xudmFyIFNDUklQVFMgPSAvPHNjcmlwdChcXHMrW14+XSopPz5cXG4/KFtcXFNcXHNdKj8pPFxcL3NjcmlwdFxccyo+L2dpO1xudmFyIFNUWUxFUyA9IC88c3R5bGUoXFxzK1tePl0qKT8+XFxuPyhbXFxTXFxzXSo/KTxcXC9zdHlsZVxccyo+L2dpO1xuXG5mdW5jdGlvbiBjb21waWxlJDEgKHNyYywgb3B0cywgdXJsKSB7XG4gIHZhclxuICAgIHBhcnRzID0gW10sXG4gICAgaW5jbHVkZWQsXG4gICAgZGVmYXVsdFBhcnNlcnB0aW9ucyA9IHtcblxuICAgICAgdGVtcGxhdGU6IHt9LFxuICAgICAganM6IHt9LFxuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcblxuICBpZiAoIW9wdHMpIHsgb3B0cyA9IHt9OyB9XG5cbiAgb3B0cy5wYXJzZXJPcHRpb25zID0gZXh0ZW5kJDEoZGVmYXVsdFBhcnNlcnB0aW9ucywgb3B0cy5wYXJzZXJPcHRpb25zIHx8IHt9KTtcblxuICBpbmNsdWRlZCA9IG9wdHMuZXhjbHVkZVxuICAgID8gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIG9wdHMuZXhjbHVkZS5pbmRleE9mKHMpIDwgMCB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuXG4gIGlmICghdXJsKSB7IHVybCA9ICcnOyB9XG5cbiAgdmFyIF9icCA9IGJyYWNrZXRzLmFycmF5KG9wdHMuYnJhY2tldHMpO1xuXG4gIGlmIChvcHRzLnRlbXBsYXRlKSB7XG4gICAgc3JjID0gY29tcGlsZVRlbXBsYXRlKHNyYywgdXJsLCBvcHRzLnRlbXBsYXRlLCBvcHRzLnBhcnNlck9wdGlvbnMudGVtcGxhdGUpO1xuICB9XG5cbiAgc3JjID0gY2xlYW5Tb3VyY2Uoc3JjKVxuICAgIC5yZXBsYWNlKENVU1RfVEFHLCBmdW5jdGlvbiAoXywgaW5kZW50LCB0YWdOYW1lLCBhdHRyaWJzLCBib2R5LCBib2R5Mikge1xuICAgICAgdmFyXG4gICAgICAgIGpzY29kZSA9ICcnLFxuICAgICAgICBzdHlsZXMgPSAnJyxcbiAgICAgICAgaHRtbCA9ICcnLFxuICAgICAgICBpbXBvcnRzID0gJycsXG4gICAgICAgIHBjZXggPSBbXTtcblxuICAgICAgcGNleC5fYnAgPSBfYnA7XG5cbiAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGF0dHJpYnMgPSBhdHRyaWJzICYmIGluY2x1ZGVkKCdhdHRyaWJzJylcbiAgICAgICAgPyByZXN0b3JlRXhwcihcbiAgICAgICAgICAgIHBhcnNlQXR0cmlicyhcbiAgICAgICAgICAgICAgc3BsaXRIdG1sKGF0dHJpYnMsIG9wdHMsIHBjZXgpLFxuICAgICAgICAgICAgcGNleCksXG4gICAgICAgICAgcGNleCkgOiAnJztcblxuICAgICAgaWYgKChib2R5IHx8IChib2R5ID0gYm9keTIpKSAmJiAvXFxTLy50ZXN0KGJvZHkpKSB7XG5cbiAgICAgICAgaWYgKGJvZHkyKSB7XG5cbiAgICAgICAgICBpZiAoaW5jbHVkZWQoJ2h0bWwnKSkgeyBodG1sID0gX2NvbXBpbGVIVE1MKGJvZHkyLCBvcHRzLCBwY2V4KTsgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZShSZWdFeHAoJ14nICsgaW5kZW50LCAnZ20nKSwgJycpO1xuXG4gICAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZShTQ1JJUFRTLCBmdW5jdGlvbiAoX20sIF9hdHRycywgX3NjcmlwdCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVkKCdqcycpKSB7XG4gICAgICAgICAgICAgIHZhciBjb2RlID0gZ2V0Q29kZShfc2NyaXB0LCBvcHRzLCBfYXR0cnMsIHVybCk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvZGUpIHsganNjb2RlICs9IChqc2NvZGUgPyAnXFxuJyA6ICcnKSArIGNvZGU7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZShTVFlMRVMsIGZ1bmN0aW9uIChfbSwgX2F0dHJzLCBfc3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlZCgnY3NzJykpIHtcbiAgICAgICAgICAgICAgc3R5bGVzICs9IChzdHlsZXMgPyAnICcgOiAnJykgKyBjc3NDb2RlKF9zdHlsZSwgb3B0cywgX2F0dHJzLCB1cmwsIHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgYmxvY2tzID0gc3BsaXRCbG9ja3MoYm9keS5yZXBsYWNlKFRSSU1fVFJBSUwsICcnKSk7XG5cbiAgICAgICAgICBpZiAoaW5jbHVkZWQoJ2h0bWwnKSkge1xuICAgICAgICAgICAgaHRtbCA9IF9jb21waWxlSFRNTChibG9ja3NbMF0sIG9wdHMsIHBjZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmNsdWRlZCgnanMnKSkge1xuICAgICAgICAgICAgYm9keSA9IF9jb21waWxlSlMoYmxvY2tzWzFdLCBvcHRzLCBudWxsLCBudWxsLCB1cmwpO1xuICAgICAgICAgICAgaWYgKGJvZHkpIHsganNjb2RlICs9IChqc2NvZGUgPyAnXFxuJyA6ICcnKSArIGJvZHk7IH1cbiAgICAgICAgICAgIGpzY29kZSA9IGpzY29kZS5yZXBsYWNlKElNUE9SVF9TVEFURU1FTlQsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgIGltcG9ydHMgKz0gcy50cmltKCkgKyAnXFxuJztcbiAgICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAganNjb2RlID0gL1xcUy8udGVzdChqc2NvZGUpID8ganNjb2RlLnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpIDogJyc7XG5cbiAgICAgIGlmIChvcHRzLmVudGl0aWVzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgaHRtbDogaHRtbCxcbiAgICAgICAgICBjc3M6IHN0eWxlcyxcbiAgICAgICAgICBhdHRyaWJzOiBhdHRyaWJzLFxuICAgICAgICAgIGpzOiBqc2NvZGUsXG4gICAgICAgICAgaW1wb3J0czogaW1wb3J0c1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBta3RhZyh0YWdOYW1lLCBodG1sLCBzdHlsZXMsIGF0dHJpYnMsIGpzY29kZSwgaW1wb3J0cywgb3B0cylcbiAgICB9KTtcblxuICBpZiAob3B0cy5lbnRpdGllcykgeyByZXR1cm4gcGFydHMgfVxuXG4gIHJldHVybiBzcmNcbn1cblxudmFyIHZlcnNpb24kMiA9ICd2My4yLjEnO1xuXG52YXIgY29tcGlsZXIgPSB7XG4gIGNvbXBpbGU6IGNvbXBpbGUkMSxcbiAgY29tcGlsZUhUTUw6IGNvbXBpbGVIVE1MLFxuICBjb21waWxlQ1NTOiBjb21waWxlQ1NTLFxuICBjb21waWxlSlM6IGNvbXBpbGVKUyxcbiAgcGFyc2VyczogcGFyc2VycyQxLFxuICB2ZXJzaW9uOiB2ZXJzaW9uJDJcbn07XG5cbnZhciBwcm9taXNlO1xudmFyIHJlYWR5OyAgICAgICAvLyBhbGwgdGhlIHNjcmlwdHMgd2VyZSBjb21waWxlZD9cblxuLy8gZ2V0cyB0aGUgc291cmNlIG9mIGFuIGV4dGVybmFsIHRhZyB3aXRoIGFuIGFzeW5jIGNhbGxcbmZ1bmN0aW9uIEdFVCAodXJsLCBmbiwgb3B0cykge1xuICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQgJiZcbiAgICAgICAocmVxLnN0YXR1cyA9PT0gMjAwIHx8ICFyZXEuc3RhdHVzICYmIHJlcS5yZXNwb25zZVRleHQubGVuZ3RoKSkge1xuICAgICAgZm4ocmVxLnJlc3BvbnNlVGV4dCwgb3B0cywgdXJsKTtcbiAgICB9XG4gIH07XG4gIHJlcS5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICByZXEuc2VuZCgnJyk7XG59XG5cbi8vIGV2YWx1YXRlcyBhIGNvbXBpbGVkIHRhZyB3aXRoaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5mdW5jdGlvbiBnbG9iYWxFdmFsIChqcywgdXJsKSB7XG4gIGlmICh0eXBlb2YganMgPT09IFRfU1RSSU5HKSB7XG4gICAgdmFyXG4gICAgICBub2RlID0gbWtFbCgnc2NyaXB0JyksXG4gICAgICByb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgLy8gbWFrZSB0aGUgc291cmNlIGF2YWlsYWJsZSBpbiB0aGUgXCIobm8gZG9tYWluKVwiIHRhYlxuICAgIC8vIG9mIENocm9tZSBEZXZUb29scywgd2l0aCBhIC5qcyBleHRlbnNpb25cbiAgICBpZiAodXJsKSB7IGpzICs9ICdcXG4vLyMgc291cmNlVVJMPScgKyB1cmwgKyAnLmpzJzsgfVxuXG4gICAgbm9kZS50ZXh0ID0ganM7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuICB9XG59XG5cbi8vIGNvbXBpbGVzIGFsbCB0aGUgaW50ZXJuYWwgYW5kIGV4dGVybmFsIHRhZ3Mgb24gdGhlIHBhZ2VcbmZ1bmN0aW9uIGNvbXBpbGVTY3JpcHRzIChmbiwgeG9wdCkge1xuICB2YXJcbiAgICBzY3JpcHRzID0gJCQoJ3NjcmlwdFt0eXBlPVwicmlvdC90YWdcIl0nKSxcbiAgICBzY3JpcHRzQW1vdW50ID0gc2NyaXB0cy5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBwcm9taXNlLnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgcmVhZHkgPSB0cnVlO1xuICAgIGlmIChmbikgeyBmbigpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21waWxlVGFnIChzcmMsIG9wdHMsIHVybCkge1xuICAgIHZhciBjb2RlID0gY29tcGlsZXIuY29tcGlsZShzcmMsIG9wdHMsIHVybCk7XG5cbiAgICBnbG9iYWxFdmFsKGNvZGUsIHVybCk7XG4gICAgaWYgKCEtLXNjcmlwdHNBbW91bnQpIHsgZG9uZSgpOyB9XG4gIH1cblxuICBpZiAoIXNjcmlwdHNBbW91bnQpIHsgZG9uZSgpOyB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyXG4gICAgICAgIHNjcmlwdCA9IHNjcmlwdHNbaV0sXG4gICAgICAgIG9wdHMgPSBleHRlbmQoe3RlbXBsYXRlOiBnZXRBdHRyKHNjcmlwdCwgJ3RlbXBsYXRlJyl9LCB4b3B0KSxcbiAgICAgICAgdXJsID0gZ2V0QXR0cihzY3JpcHQsICdzcmMnKSB8fCBnZXRBdHRyKHNjcmlwdCwgJ2RhdGEtc3JjJyk7XG5cbiAgICAgIHVybCA/IEdFVCh1cmwsIGNvbXBpbGVUYWcsIG9wdHMpIDogY29tcGlsZVRhZyhzY3JpcHQuaW5uZXJIVE1MLCBvcHRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHBhcnNlcnMgPSBjb21waWxlci5wYXJzZXJzO1xuXG4vKlxuICBDb21waWxhdGlvbiBmb3IgdGhlIGJyb3dzZXJcbiovXG52YXIgY29tcGlsZSA9IGZ1bmN0aW9uIChhcmcsIGZuLCBvcHRzKSB7XG5cbiAgaWYgKHR5cGVvZiBhcmcgPT09IFRfU1RSSU5HKSB7XG5cbiAgICAvLyAybmQgcGFyYW1ldGVyIGlzIG9wdGlvbmFsLCBidXQgY2FuIGJlIG51bGxcbiAgICBpZiAoaXNPYmplY3QoZm4pKSB7XG4gICAgICBvcHRzID0gZm47XG4gICAgICBmbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGByaW90LmNvbXBpbGUodGFnIFssIGNhbGxiYWNrIHwgdHJ1ZV1bLCBvcHRpb25zXSlgXG4gICAgaWYgKC9eXFxzKjwvbS50ZXN0KGFyZykpIHtcbiAgICAgIHZhciBqcyA9IGNvbXBpbGVyLmNvbXBpbGUoYXJnLCBvcHRzKTtcbiAgICAgIGlmIChmbiAhPT0gdHJ1ZSkgeyBnbG9iYWxFdmFsKGpzKTsgfVxuICAgICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7IGZuKGpzLCBhcmcsIG9wdHMpOyB9XG4gICAgICByZXR1cm4ganNcbiAgICB9XG5cbiAgICAvLyBgcmlvdC5jb21waWxlKHVybCBbLCBjYWxsYmFja11bLCBvcHRpb25zXSlgXG4gICAgR0VUKGFyZywgZnVuY3Rpb24gKHN0ciwgb3B0cywgdXJsKSB7XG4gICAgICB2YXIganMgPSBjb21waWxlci5jb21waWxlKHN0ciwgb3B0cywgdXJsKTtcbiAgICAgIGdsb2JhbEV2YWwoanMsIHVybCk7XG4gICAgICBpZiAoZm4pIHsgZm4oanMsIHN0ciwgb3B0cyk7IH1cbiAgICB9LCBvcHRzKTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoYXJnKSkge1xuICAgIHZhciBpID0gYXJnLmxlbmd0aDtcbiAgICAvLyBgcmlvdC5jb21waWxlKFt1cmxzTGlzdF0gWywgY2FsbGJhY2tdWywgb3B0aW9uc10pYFxuICAgIGFyZy5mb3JFYWNoKGZ1bmN0aW9uKHN0cikge1xuICAgICAgR0VUKHN0ciwgZnVuY3Rpb24gKHN0ciwgb3B0cywgdXJsKSB7XG4gICAgICAgIHZhciBqcyA9IGNvbXBpbGVyLmNvbXBpbGUoc3RyLCBvcHRzLCB1cmwpO1xuICAgICAgICBnbG9iYWxFdmFsKGpzLCB1cmwpO1xuICAgICAgICBpIC0tO1xuICAgICAgICBpZiAoIWkgJiYgZm4pIHsgZm4oanMsIHN0ciwgb3B0cyk7IH1cbiAgICAgIH0sIG9wdHMpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuXG4gICAgLy8gYHJpb3QuY29tcGlsZShbY2FsbGJhY2tdWywgb3B0aW9uc10pYFxuICAgIGlmIChpc0Z1bmN0aW9uKGFyZykpIHtcbiAgICAgIG9wdHMgPSBmbjtcbiAgICAgIGZuID0gYXJnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzID0gYXJnO1xuICAgICAgZm4gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICByZXR1cm4gZm4gJiYgZm4oKVxuICAgIH1cblxuICAgIGlmIChwcm9taXNlKSB7XG4gICAgICBpZiAoZm4pIHsgcHJvbWlzZS5vbigncmVhZHknLCBmbik7IH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gb2JzZXJ2YWJsZSQxKCk7XG4gICAgICBjb21waWxlU2NyaXB0cyhmbiwgb3B0cyk7XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG1vdW50JCQxKCkge1xuICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHZhciByZXQ7XG4gIGNvbXBpbGUoZnVuY3Rpb24gKCkgeyByZXQgPSBtb3VudCQxLmFwcGx5KHJpb3QkMiwgYXJncyk7IH0pO1xuICByZXR1cm4gcmV0XG59XG5cbnZhciByaW90X2NvbXBpbGVyID0gZXh0ZW5kKHt9LCByaW90JDIsIHtcbiAgbW91bnQ6IG1vdW50JCQxLFxuICBjb21waWxlOiBjb21waWxlLFxuICBwYXJzZXJzOiBwYXJzZXJzXG59KTtcblxucmV0dXJuIHJpb3RfY29tcGlsZXI7XG5cbn0pKSk7XG4iLCJcbi8qKlxuICogVGhlIHJpb3QgdGVtcGxhdGUgZW5naW5lXG4gKiBAdmVyc2lvbiB2My4wLjNcbiAqL1xuLyoqXG4gKiByaW90LnV0aWwuYnJhY2tldHNcbiAqXG4gKiAtIGBicmFja2V0cyAgICBgIC0gUmV0dXJucyBhIHN0cmluZyBvciByZWdleCBiYXNlZCBvbiBpdHMgcGFyYW1ldGVyXG4gKiAtIGBicmFja2V0cy5zZXRgIC0gQ2hhbmdlIHRoZSBjdXJyZW50IHJpb3QgYnJhY2tldHNcbiAqXG4gKiBAbW9kdWxlXG4gKi9cblxuLyogZ2xvYmFsIHJpb3QgKi9cblxuZXhwb3J0XG52YXIgYnJhY2tldHMgPSAoZnVuY3Rpb24gKFVOREVGKSB7XG5cbiAgdmFyXG4gICAgUkVHTE9CID0gJ2cnLFxuXG4gICAgUl9NTENPTU1TID0gL1xcL1xcKlteKl0qXFwqKyg/OlteKlxcL11bXipdKlxcKispKlxcLy9nLFxuXG4gICAgUl9TVFJJTkdTID0gL1wiW15cIlxcXFxdKig/OlxcXFxbXFxTXFxzXVteXCJcXFxcXSopKlwifCdbXidcXFxcXSooPzpcXFxcW1xcU1xcc11bXidcXFxcXSopKid8YFteYFxcXFxdKig/OlxcXFxbXFxTXFxzXVteYFxcXFxdKikqYC9nLFxuXG4gICAgU19RQkxPQ0tTID0gUl9TVFJJTkdTLnNvdXJjZSArICd8JyArXG4gICAgICAvKD86XFxicmV0dXJuXFxzK3woPzpbJFxcd1xcKVxcXV18XFwrXFwrfC0tKVxccyooXFwvKSg/IVsqXFwvXSkpLy5zb3VyY2UgKyAnfCcgK1xuICAgICAgL1xcLyg/PVteKlxcL10pW15bXFwvXFxcXF0qKD86KD86XFxbKD86XFxcXC58W15cXF1cXFxcXSopKlxcXXxcXFxcLilbXltcXC9cXFxcXSopKj8oXFwvKVtnaW1dKi8uc291cmNlLFxuXG4gICAgVU5TVVBQT1JURUQgPSBSZWdFeHAoJ1tcXFxcJyArICd4MDAtXFxcXHgxRjw+YS16QS1aMC05XFwnXCIsO1xcXFxcXFxcXScpLFxuXG4gICAgTkVFRF9FU0NBUEUgPSAvKD89W1tcXF0oKSorPy5eJHxdKS9nLFxuXG4gICAgRklOREJSQUNFUyA9IHtcbiAgICAgICcoJzogUmVnRXhwKCcoWygpXSl8JyAgICsgU19RQkxPQ0tTLCBSRUdMT0IpLFxuICAgICAgJ1snOiBSZWdFeHAoJyhbW1xcXFxdXSl8JyArIFNfUUJMT0NLUywgUkVHTE9CKSxcbiAgICAgICd7JzogUmVnRXhwKCcoW3t9XSl8JyAgICsgU19RQkxPQ0tTLCBSRUdMT0IpXG4gICAgfSxcblxuICAgIERFRkFVTFQgPSAneyB9J1xuXG4gIHZhciBfcGFpcnMgPSBbXG4gICAgJ3snLCAnfScsXG4gICAgJ3snLCAnfScsXG4gICAgL3tbXn1dKn0vLFxuICAgIC9cXFxcKFt7fV0pL2csXG4gICAgL1xcXFwoeyl8ey9nLFxuICAgIFJlZ0V4cCgnXFxcXFxcXFwofSl8KFtbKHtdKXwofSl8JyArIFNfUUJMT0NLUywgUkVHTE9CKSxcbiAgICBERUZBVUxULFxuICAgIC9eXFxzKntcXF4/XFxzKihbJFxcd10rKSg/OlxccyosXFxzKihcXFMrKSk/XFxzK2luXFxzKyhcXFMuKilcXHMqfS8sXG4gICAgLyhefFteXFxcXF0pez1bXFxTXFxzXSo/fS9cbiAgXVxuXG4gIHZhclxuICAgIGNhY2hlZEJyYWNrZXRzID0gVU5ERUYsXG4gICAgX3JlZ2V4LFxuICAgIF9jYWNoZSA9IFtdLFxuICAgIF9zZXR0aW5nc1xuXG4gIGZ1bmN0aW9uIF9sb29wYmFjayAocmUpIHsgcmV0dXJuIHJlIH1cblxuICBmdW5jdGlvbiBfcmV3cml0ZSAocmUsIGJwKSB7XG4gICAgaWYgKCFicCkgYnAgPSBfY2FjaGVcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcbiAgICAgIHJlLnNvdXJjZS5yZXBsYWNlKC97L2csIGJwWzJdKS5yZXBsYWNlKC99L2csIGJwWzNdKSwgcmUuZ2xvYmFsID8gUkVHTE9CIDogJydcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlIChwYWlyKSB7XG4gICAgaWYgKHBhaXIgPT09IERFRkFVTFQpIHJldHVybiBfcGFpcnNcblxuICAgIHZhciBhcnIgPSBwYWlyLnNwbGl0KCcgJylcblxuICAgIGlmIChhcnIubGVuZ3RoICE9PSAyIHx8IFVOU1VQUE9SVEVELnRlc3QocGFpcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYnJhY2tldHMgXCInICsgcGFpciArICdcIicpXG4gICAgfVxuICAgIGFyciA9IGFyci5jb25jYXQocGFpci5yZXBsYWNlKE5FRURfRVNDQVBFLCAnXFxcXCcpLnNwbGl0KCcgJykpXG5cbiAgICBhcnJbNF0gPSBfcmV3cml0ZShhcnJbMV0ubGVuZ3RoID4gMSA/IC97W1xcU1xcc10qP30vIDogX3BhaXJzWzRdLCBhcnIpXG4gICAgYXJyWzVdID0gX3Jld3JpdGUocGFpci5sZW5ndGggPiAzID8gL1xcXFwoe3x9KS9nIDogX3BhaXJzWzVdLCBhcnIpXG4gICAgYXJyWzZdID0gX3Jld3JpdGUoX3BhaXJzWzZdLCBhcnIpXG4gICAgYXJyWzddID0gUmVnRXhwKCdcXFxcXFxcXCgnICsgYXJyWzNdICsgJyl8KFtbKHtdKXwoJyArIGFyclszXSArICcpfCcgKyBTX1FCTE9DS1MsIFJFR0xPQilcbiAgICBhcnJbOF0gPSBwYWlyXG4gICAgcmV0dXJuIGFyclxuICB9XG5cbiAgZnVuY3Rpb24gX2JyYWNrZXRzIChyZU9ySWR4KSB7XG4gICAgcmV0dXJuIHJlT3JJZHggaW5zdGFuY2VvZiBSZWdFeHAgPyBfcmVnZXgocmVPcklkeCkgOiBfY2FjaGVbcmVPcklkeF1cbiAgfVxuXG4gIF9icmFja2V0cy5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChzdHIsIHRtcGwsIF9icCkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBfYnAgaXMgZm9yIHRoZSBjb21waWxlclxuICAgIGlmICghX2JwKSBfYnAgPSBfY2FjaGVcblxuICAgIHZhclxuICAgICAgcGFydHMgPSBbXSxcbiAgICAgIG1hdGNoLFxuICAgICAgaXNleHByLFxuICAgICAgc3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZSA9IF9icFs2XVxuXG4gICAgaXNleHByID0gc3RhcnQgPSByZS5sYXN0SW5kZXggPSAwXG5cbiAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhzdHIpKSkge1xuXG4gICAgICBwb3MgPSBtYXRjaC5pbmRleFxuXG4gICAgICBpZiAoaXNleHByKSB7XG5cbiAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgcmUubGFzdEluZGV4ID0gc2tpcEJyYWNlcyhzdHIsIG1hdGNoWzJdLCByZS5sYXN0SW5kZXgpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hdGNoWzNdKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW1hdGNoWzFdKSB7XG4gICAgICAgIHVuZXNjYXBlU3RyKHN0ci5zbGljZShzdGFydCwgcG9zKSlcbiAgICAgICAgc3RhcnQgPSByZS5sYXN0SW5kZXhcbiAgICAgICAgcmUgPSBfYnBbNiArIChpc2V4cHIgXj0gMSldXG4gICAgICAgIHJlLmxhc3RJbmRleCA9IHN0YXJ0XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0ciAmJiBzdGFydCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgIHVuZXNjYXBlU3RyKHN0ci5zbGljZShzdGFydCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzXG5cbiAgICBmdW5jdGlvbiB1bmVzY2FwZVN0ciAocykge1xuICAgICAgaWYgKHRtcGwgfHwgaXNleHByKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocyAmJiBzLnJlcGxhY2UoX2JwWzVdLCAnJDEnKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gocylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2lwQnJhY2VzIChzLCBjaCwgaXgpIHtcbiAgICAgIHZhclxuICAgICAgICBtYXRjaCxcbiAgICAgICAgcmVjY2ggPSBGSU5EQlJBQ0VTW2NoXVxuXG4gICAgICByZWNjaC5sYXN0SW5kZXggPSBpeFxuICAgICAgaXggPSAxXG4gICAgICB3aGlsZSAoKG1hdGNoID0gcmVjY2guZXhlYyhzKSkpIHtcbiAgICAgICAgaWYgKG1hdGNoWzFdICYmXG4gICAgICAgICAgIShtYXRjaFsxXSA9PT0gY2ggPyArK2l4IDogLS1peCkpIGJyZWFrXG4gICAgICB9XG4gICAgICByZXR1cm4gaXggPyBzLmxlbmd0aCA6IHJlY2NoLmxhc3RJbmRleFxuICAgIH1cbiAgfVxuXG4gIF9icmFja2V0cy5oYXNFeHByID0gZnVuY3Rpb24gaGFzRXhwciAoc3RyKSB7XG4gICAgcmV0dXJuIF9jYWNoZVs0XS50ZXN0KHN0cilcbiAgfVxuXG4gIF9icmFja2V0cy5sb29wS2V5cyA9IGZ1bmN0aW9uIGxvb3BLZXlzIChleHByKSB7XG4gICAgdmFyIG0gPSBleHByLm1hdGNoKF9jYWNoZVs5XSlcblxuICAgIHJldHVybiBtXG4gICAgICA/IHsga2V5OiBtWzFdLCBwb3M6IG1bMl0sIHZhbDogX2NhY2hlWzBdICsgbVszXS50cmltKCkgKyBfY2FjaGVbMV0gfVxuICAgICAgOiB7IHZhbDogZXhwci50cmltKCkgfVxuICB9XG5cbiAgX2JyYWNrZXRzLmFycmF5ID0gZnVuY3Rpb24gYXJyYXkgKHBhaXIpIHtcbiAgICByZXR1cm4gcGFpciA/IF9jcmVhdGUocGFpcikgOiBfY2FjaGVcbiAgfVxuXG4gIGZ1bmN0aW9uIF9yZXNldCAocGFpcikge1xuICAgIGlmICgocGFpciB8fCAocGFpciA9IERFRkFVTFQpKSAhPT0gX2NhY2hlWzhdKSB7XG4gICAgICBfY2FjaGUgPSBfY3JlYXRlKHBhaXIpXG4gICAgICBfcmVnZXggPSBwYWlyID09PSBERUZBVUxUID8gX2xvb3BiYWNrIDogX3Jld3JpdGVcbiAgICAgIF9jYWNoZVs5XSA9IF9yZWdleChfcGFpcnNbOV0pXG4gICAgfVxuICAgIGNhY2hlZEJyYWNrZXRzID0gcGFpclxuICB9XG5cbiAgZnVuY3Rpb24gX3NldFNldHRpbmdzIChvKSB7XG4gICAgdmFyIGJcblxuICAgIG8gPSBvIHx8IHt9XG4gICAgYiA9IG8uYnJhY2tldHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ2JyYWNrZXRzJywge1xuICAgICAgc2V0OiBfcmVzZXQsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlZEJyYWNrZXRzIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgICBfc2V0dGluZ3MgPSBvXG4gICAgX3Jlc2V0KGIpXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2JyYWNrZXRzLCAnc2V0dGluZ3MnLCB7XG4gICAgc2V0OiBfc2V0U2V0dGluZ3MsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfc2V0dGluZ3MgfVxuICB9KVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpbiB0aGUgYnJvd3NlciByaW90IGlzIGFsd2F5cyBpbiB0aGUgc2NvcGUgKi9cbiAgX2JyYWNrZXRzLnNldHRpbmdzID0gdHlwZW9mIHJpb3QgIT09ICd1bmRlZmluZWQnICYmIHJpb3Quc2V0dGluZ3MgfHwge31cbiAgX2JyYWNrZXRzLnNldCA9IF9yZXNldFxuXG4gIF9icmFja2V0cy5SX1NUUklOR1MgPSBSX1NUUklOR1NcbiAgX2JyYWNrZXRzLlJfTUxDT01NUyA9IFJfTUxDT01NU1xuICBfYnJhY2tldHMuU19RQkxPQ0tTID0gU19RQkxPQ0tTXG5cbiAgcmV0dXJuIF9icmFja2V0c1xuXG59KSgpXG5cbi8qKlxuICogQG1vZHVsZSB0bXBsXG4gKlxuICogdG1wbCAgICAgICAgICAtIFJvb3QgZnVuY3Rpb24sIHJldHVybnMgdGhlIHRlbXBsYXRlIHZhbHVlLCByZW5kZXIgd2l0aCBkYXRhXG4gKiB0bXBsLmhhc0V4cHIgIC0gVGVzdCB0aGUgZXhpc3RlbmNlIG9mIGEgZXhwcmVzc2lvbiBpbnNpZGUgYSBzdHJpbmdcbiAqIHRtcGwubG9vcEtleXMgLSBHZXQgdGhlIGtleXMgZm9yIGFuICdlYWNoJyBsb29wICh1c2VkIGJ5IGBfZWFjaGApXG4gKi9cblxuZXhwb3J0XG52YXIgdG1wbCA9IChmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIF9jYWNoZSA9IHt9XG5cbiAgZnVuY3Rpb24gX3RtcGwgKHN0ciwgZGF0YSkge1xuICAgIGlmICghc3RyKSByZXR1cm4gc3RyXG5cbiAgICByZXR1cm4gKF9jYWNoZVtzdHJdIHx8IChfY2FjaGVbc3RyXSA9IF9jcmVhdGUoc3RyKSkpLmNhbGwoZGF0YSwgX2xvZ0VycilcbiAgfVxuXG4gIF90bXBsLmhhc0V4cHIgPSBicmFja2V0cy5oYXNFeHByXG5cbiAgX3RtcGwubG9vcEtleXMgPSBicmFja2V0cy5sb29wS2V5c1xuXG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gIF90bXBsLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IF9jYWNoZSA9IHt9IH1cblxuICBfdG1wbC5lcnJvckhhbmRsZXIgPSBudWxsXG5cbiAgZnVuY3Rpb24gX2xvZ0VyciAoZXJyLCBjdHgpIHtcblxuICAgIGVyci5yaW90RGF0YSA9IHtcbiAgICAgIHRhZ05hbWU6IGN0eCAmJiBjdHguX18gJiYgY3R4Ll9fLnRhZ05hbWUsXG4gICAgICBfcmlvdF9pZDogY3R4ICYmIGN0eC5fcmlvdF9pZCAgLy9lc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgIH1cblxuICAgIGlmIChfdG1wbC5lcnJvckhhbmRsZXIpIF90bXBsLmVycm9ySGFuZGxlcihlcnIpXG4gICAgZWxzZSBpZiAoXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBpZiAoZXJyLnJpb3REYXRhLnRhZ05hbWUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUmlvdCB0ZW1wbGF0ZSBlcnJvciB0aHJvd24gaW4gdGhlIDwlcz4gdGFnJywgZXJyLnJpb3REYXRhLnRhZ05hbWUpXG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlIChzdHIpIHtcbiAgICB2YXIgZXhwciA9IF9nZXRUbXBsKHN0cilcblxuICAgIGlmIChleHByLnNsaWNlKDAsIDExKSAhPT0gJ3RyeXtyZXR1cm4gJykgZXhwciA9ICdyZXR1cm4gJyArIGV4cHJcblxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ0UnLCBleHByICsgJzsnKSAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXG4gIH1cblxuICB2YXJcbiAgICBDSF9JREVYUFIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MjA1NyksXG4gICAgUkVfQ1NOQU1FID0gL14oPzooLT9bX0EtWmEtelxceEEwLVxceEZGXVstXFx3XFx4QTAtXFx4RkZdKil8XFx1MjA1NyhcXGQrKX4pOi8sXG4gICAgUkVfUUJMT0NLID0gUmVnRXhwKGJyYWNrZXRzLlNfUUJMT0NLUywgJ2cnKSxcbiAgICBSRV9EUVVPVEUgPSAvXFx1MjA1Ny9nLFxuICAgIFJFX1FCTUFSSyA9IC9cXHUyMDU3KFxcZCspfi9nXG5cbiAgZnVuY3Rpb24gX2dldFRtcGwgKHN0cikge1xuICAgIHZhclxuICAgICAgcXN0ciA9IFtdLFxuICAgICAgZXhwcixcbiAgICAgIHBhcnRzID0gYnJhY2tldHMuc3BsaXQoc3RyLnJlcGxhY2UoUkVfRFFVT1RFLCAnXCInKSwgMSlcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyIHx8IHBhcnRzWzBdKSB7XG4gICAgICB2YXIgaSwgaiwgbGlzdCA9IFtdXG5cbiAgICAgIGZvciAoaSA9IGogPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICBleHByID0gcGFydHNbaV1cblxuICAgICAgICBpZiAoZXhwciAmJiAoZXhwciA9IGkgJiAxXG5cbiAgICAgICAgICAgID8gX3BhcnNlRXhwcihleHByLCAxLCBxc3RyKVxuXG4gICAgICAgICAgICA6ICdcIicgKyBleHByXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxuP3xcXG4vZywgJ1xcXFxuJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICtcbiAgICAgICAgICAgICAgJ1wiJ1xuXG4gICAgICAgICAgKSkgbGlzdFtqKytdID0gZXhwclxuXG4gICAgICB9XG5cbiAgICAgIGV4cHIgPSBqIDwgMiA/IGxpc3RbMF1cbiAgICAgICAgICAgOiAnWycgKyBsaXN0LmpvaW4oJywnKSArICddLmpvaW4oXCJcIiknXG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBleHByID0gX3BhcnNlRXhwcihwYXJ0c1sxXSwgMCwgcXN0cilcbiAgICB9XG5cbiAgICBpZiAocXN0clswXSkge1xuICAgICAgZXhwciA9IGV4cHIucmVwbGFjZShSRV9RQk1BUkssIGZ1bmN0aW9uIChfLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIHFzdHJbcG9zXVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9XG5cbiAgdmFyXG4gICAgUkVfQlJFTkQgPSB7XG4gICAgICAnKCc6IC9bKCldL2csXG4gICAgICAnWyc6IC9bW1xcXV0vZyxcbiAgICAgICd7JzogL1t7fV0vZ1xuICAgIH1cblxuICBmdW5jdGlvbiBfcGFyc2VFeHByIChleHByLCBhc1RleHQsIHFzdHIpIHtcblxuICAgIGV4cHIgPSBleHByXG4gICAgICAgICAgLnJlcGxhY2UoUkVfUUJMT0NLLCBmdW5jdGlvbiAocywgZGl2KSB7XG4gICAgICAgICAgICByZXR1cm4gcy5sZW5ndGggPiAyICYmICFkaXYgPyBDSF9JREVYUFIgKyAocXN0ci5wdXNoKHMpIC0gMSkgKyAnficgOiBzXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXCA/KFtbXFwoe30sP1xcLjpdKVxcID8vZywgJyQxJylcblxuICAgIGlmIChleHByKSB7XG4gICAgICB2YXJcbiAgICAgICAgbGlzdCA9IFtdLFxuICAgICAgICBjbnQgPSAwLFxuICAgICAgICBtYXRjaFxuXG4gICAgICB3aGlsZSAoZXhwciAmJlxuICAgICAgICAgICAgKG1hdGNoID0gZXhwci5tYXRjaChSRV9DU05BTUUpKSAmJlxuICAgICAgICAgICAgIW1hdGNoLmluZGV4XG4gICAgICAgICkge1xuICAgICAgICB2YXJcbiAgICAgICAgICBrZXksXG4gICAgICAgICAganNiLFxuICAgICAgICAgIHJlID0gLyx8KFtbeyhdKXwkL2dcblxuICAgICAgICBleHByID0gUmVnRXhwLnJpZ2h0Q29udGV4dFxuICAgICAgICBrZXkgID0gbWF0Y2hbMl0gPyBxc3RyW21hdGNoWzJdXS5zbGljZSgxLCAtMSkudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKSA6IG1hdGNoWzFdXG5cbiAgICAgICAgd2hpbGUgKGpzYiA9IChtYXRjaCA9IHJlLmV4ZWMoZXhwcikpWzFdKSBza2lwQnJhY2VzKGpzYiwgcmUpXG5cbiAgICAgICAganNiICA9IGV4cHIuc2xpY2UoMCwgbWF0Y2guaW5kZXgpXG4gICAgICAgIGV4cHIgPSBSZWdFeHAucmlnaHRDb250ZXh0XG5cbiAgICAgICAgbGlzdFtjbnQrK10gPSBfd3JhcEV4cHIoanNiLCAxLCBrZXkpXG4gICAgICB9XG5cbiAgICAgIGV4cHIgPSAhY250ID8gX3dyYXBFeHByKGV4cHIsIGFzVGV4dClcbiAgICAgICAgICAgOiBjbnQgPiAxID8gJ1snICsgbGlzdC5qb2luKCcsJykgKyAnXS5qb2luKFwiIFwiKS50cmltKCknIDogbGlzdFswXVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuXG4gICAgZnVuY3Rpb24gc2tpcEJyYWNlcyAoY2gsIHJlKSB7XG4gICAgICB2YXJcbiAgICAgICAgbW0sXG4gICAgICAgIGx2ID0gMSxcbiAgICAgICAgaXIgPSBSRV9CUkVORFtjaF1cblxuICAgICAgaXIubGFzdEluZGV4ID0gcmUubGFzdEluZGV4XG4gICAgICB3aGlsZSAobW0gPSBpci5leGVjKGV4cHIpKSB7XG4gICAgICAgIGlmIChtbVswXSA9PT0gY2gpICsrbHZcbiAgICAgICAgZWxzZSBpZiAoIS0tbHYpIGJyZWFrXG4gICAgICB9XG4gICAgICByZS5sYXN0SW5kZXggPSBsdiA/IGV4cHIubGVuZ3RoIDogaXIubGFzdEluZGV4XG4gICAgfVxuICB9XG5cbiAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vdCBib3RoXG4gIHZhciAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIEpTX0NPTlRFWFQgPSAnXCJpbiB0aGlzP3RoaXM6JyArICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyA/ICdnbG9iYWwnIDogJ3dpbmRvdycpICsgJykuJyxcbiAgICBKU19WQVJOQU1FID0gL1sse11bXFwkXFx3XSsoPz06KXwoXiAqfFteJFxcd1xcLntdKSg/ISg/OnR5cGVvZnx0cnVlfGZhbHNlfG51bGx8dW5kZWZpbmVkfGlufGluc3RhbmNlb2Z8aXMoPzpGaW5pdGV8TmFOKXx2b2lkfE5hTnxuZXd8RGF0ZXxSZWdFeHB8TWF0aCkoPyFbJFxcd10pKShbJF9BLVphLXpdWyRcXHddKikvZyxcbiAgICBKU19OT1BST1BTID0gL14oPz0oXFwuWyRcXHddKykpXFwxKD86W14uWyhdfCQpL1xuXG4gIGZ1bmN0aW9uIF93cmFwRXhwciAoZXhwciwgYXNUZXh0LCBrZXkpIHtcbiAgICB2YXIgdGJcblxuICAgIGV4cHIgPSBleHByLnJlcGxhY2UoSlNfVkFSTkFNRSwgZnVuY3Rpb24gKG1hdGNoLCBwLCBtdmFyLCBwb3MsIHMpIHtcbiAgICAgIGlmIChtdmFyKSB7XG4gICAgICAgIHBvcyA9IHRiID8gMCA6IHBvcyArIG1hdGNoLmxlbmd0aFxuXG4gICAgICAgIGlmIChtdmFyICE9PSAndGhpcycgJiYgbXZhciAhPT0gJ2dsb2JhbCcgJiYgbXZhciAhPT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICBtYXRjaCA9IHAgKyAnKFwiJyArIG12YXIgKyBKU19DT05URVhUICsgbXZhclxuICAgICAgICAgIGlmIChwb3MpIHRiID0gKHMgPSBzW3Bvc10pID09PSAnLicgfHwgcyA9PT0gJygnIHx8IHMgPT09ICdbJ1xuICAgICAgICB9IGVsc2UgaWYgKHBvcykge1xuICAgICAgICAgIHRiID0gIUpTX05PUFJPUFMudGVzdChzLnNsaWNlKHBvcykpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaFxuICAgIH0pXG5cbiAgICBpZiAodGIpIHtcbiAgICAgIGV4cHIgPSAndHJ5e3JldHVybiAnICsgZXhwciArICd9Y2F0Y2goZSl7RShlLHRoaXMpfSdcbiAgICB9XG5cbiAgICBpZiAoa2V5KSB7XG5cbiAgICAgIGV4cHIgPSAodGJcbiAgICAgICAgICA/ICdmdW5jdGlvbigpeycgKyBleHByICsgJ30uY2FsbCh0aGlzKScgOiAnKCcgKyBleHByICsgJyknXG4gICAgICAgICkgKyAnP1wiJyArIGtleSArICdcIjpcIlwiJ1xuXG4gICAgfSBlbHNlIGlmIChhc1RleHQpIHtcblxuICAgICAgZXhwciA9ICdmdW5jdGlvbih2KXsnICsgKHRiXG4gICAgICAgICAgPyBleHByLnJlcGxhY2UoJ3JldHVybiAnLCAndj0nKSA6ICd2PSgnICsgZXhwciArICcpJ1xuICAgICAgICApICsgJztyZXR1cm4gdnx8dj09PTA/djpcIlwifS5jYWxsKHRoaXMpJ1xuICAgIH1cblxuICAgIHJldHVybiBleHByXG4gIH1cblxuICBfdG1wbC52ZXJzaW9uID0gYnJhY2tldHMudmVyc2lvbiA9ICd2My4wLjMnXG5cbiAgcmV0dXJuIF90bXBsXG5cbn0pKClcblxuIiwiLyoqXG4gKiBDb21waWxlciBmb3IgcmlvdCBjdXN0b20gdGFnc1xuICogQHZlcnNpb24gdjMuMi4xXG4gKi9cblxuaW1wb3J0IHsgYnJhY2tldHMgfSBmcm9tICdyaW90LXRtcGwnXG5cbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5mdW5jdGlvbiBzYWZlUmVnZXggKHJlKSB7XG4gIHZhciBzcmMgPSByZS5zb3VyY2VcbiAgdmFyIG9wdCA9IHJlLmdsb2JhbCA/ICdnJyA6ICcnXG5cbiAgaWYgKHJlLmlnbm9yZUNhc2UpIG9wdCArPSAnaSdcbiAgaWYgKHJlLm11bHRpbGluZSkgIG9wdCArPSAnbSdcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHNyYyA9IHNyYy5yZXBsYWNlKCdAJywgJ1xcXFwnICsgYXJndW1lbnRzW2ldKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAoc3JjLCBvcHQpXG59XG5cbi8qKlxuICogQG1vZHVsZSBwYXJzZXJzXG4gKi9cbnZhciBwYXJzZXJzID0gKGZ1bmN0aW9uICh3aW4pIHtcblxuICB2YXIgX3AgPSB7fVxuXG4gIGZ1bmN0aW9uIF9yIChuYW1lKSB7XG4gICAgdmFyIHBhcnNlciA9IHdpbltuYW1lXVxuXG4gICAgaWYgKHBhcnNlcikgcmV0dXJuIHBhcnNlclxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgXCInICsgbmFtZSArICdcIiBub3QgbG9hZGVkLicpXG4gIH1cblxuICBmdW5jdGlvbiBfcmVxIChuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpXG5cbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBmb3JtYXQgZm9yIHBhcnNlcnMuX3JlcScpXG5cbiAgICB2YXIgcGFyc2VyID0gX3BbcGFydHNbMF1dW3BhcnRzWzFdXVxuICAgIGlmIChwYXJzZXIpIHJldHVybiBwYXJzZXJcblxuICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VyIFwiJyArIG5hbWUgKyAnXCIgbm90IGZvdW5kLicpXG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQgKG9iaiwgcHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gcHJvcHNbcHJvcF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJQdWcgKGNvbXBpbGVyTmFtZSwgaHRtbCwgb3B0cywgdXJsKSB7XG4gICAgb3B0cyA9IGV4dGVuZCh7XG4gICAgICBwcmV0dHk6IHRydWUsXG4gICAgICBmaWxlbmFtZTogdXJsLFxuICAgICAgZG9jdHlwZTogJ2h0bWwnXG4gICAgfSwgb3B0cylcbiAgICByZXR1cm4gX3IoY29tcGlsZXJOYW1lKS5yZW5kZXIoaHRtbCwgb3B0cylcbiAgfVxuXG4gIF9wLmh0bWwgPSB7XG4gICAgamFkZTogZnVuY3Rpb24gKGh0bWwsIG9wdHMsIHVybCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIGNvbnNvbGUubG9nKCdERVBSRUNBVElPTiBXQVJOSU5HOiBqYWRlIHdhcyByZW5hbWVkIFwicHVnXCIgLSBUaGUgamFkZSBwYXJzZXIgd2lsbCBiZSByZW1vdmVkIGluIHJpb3RAMy4wLjAhJylcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgIHJldHVybiByZW5kZXJQdWcoJ2phZGUnLCBodG1sLCBvcHRzLCB1cmwpXG4gICAgfSxcbiAgICBwdWc6IGZ1bmN0aW9uIChodG1sLCBvcHRzLCB1cmwpIHtcbiAgICAgIHJldHVybiByZW5kZXJQdWcoJ3B1ZycsIGh0bWwsIG9wdHMsIHVybClcbiAgICB9XG4gIH1cbiAgX3AuY3NzID0ge1xuICAgIGxlc3M6IGZ1bmN0aW9uICh0YWcsIGNzcywgb3B0cywgdXJsKSB7XG4gICAgICB2YXIgcmV0XG5cbiAgICAgIG9wdHMgPSBleHRlbmQoe1xuICAgICAgICBzeW5jOiB0cnVlLFxuICAgICAgICBzeW5jSW1wb3J0OiB0cnVlLFxuICAgICAgICBmaWxlbmFtZTogdXJsXG4gICAgICB9LCBvcHRzKVxuICAgICAgX3IoJ2xlc3MnKS5yZW5kZXIoY3NzLCBvcHRzLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgaWYgKGVycikgdGhyb3cgZXJyXG4gICAgICAgIHJldCA9IHJlc3VsdC5jc3NcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuICB9XG4gIF9wLmpzID0ge1xuXG4gICAgZXM2OiBmdW5jdGlvbiAoanMsIG9wdHMsIHVybCkge1xuICAgICAgcmV0dXJuIF9yKCdCYWJlbCcpLnRyYW5zZm9ybSggLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBqcyxcbiAgICAgICAgZXh0ZW5kKHtcbiAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICBbJ3RyYW5zZm9ybS1lczIwMTUtdGVtcGxhdGUtbGl0ZXJhbHMnLCB7IGxvb3NlOiB0cnVlIH1dLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtbGl0ZXJhbHMnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtZnVuY3Rpb24tbmFtZScsXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1hcnJvdy1mdW5jdGlvbnMnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtYmxvY2stc2NvcGVkLWZ1bmN0aW9ucycsXG4gICAgICAgICAgICBbJ3RyYW5zZm9ybS1lczIwMTUtY2xhc3NlcycsIHsgbG9vc2U6IHRydWUgfV0sXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1vYmplY3Qtc3VwZXInLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtc2hvcnRoYW5kLXByb3BlcnRpZXMnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtZHVwbGljYXRlLWtleXMnLFxuICAgICAgICAgICAgWyd0cmFuc2Zvcm0tZXMyMDE1LWNvbXB1dGVkLXByb3BlcnRpZXMnLCB7IGxvb3NlOiB0cnVlIH1dLFxuICAgICAgICAgICAgWyd0cmFuc2Zvcm0tZXMyMDE1LWZvci1vZicsIHsgbG9vc2U6IHRydWUgfV0sXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS1zdGlja3ktcmVnZXgnLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtdW5pY29kZS1yZWdleCcsXG4gICAgICAgICAgICAnY2hlY2stZXMyMDE1LWNvbnN0YW50cycsXG4gICAgICAgICAgICBbJ3RyYW5zZm9ybS1lczIwMTUtc3ByZWFkJywgeyBsb29zZTogdHJ1ZSB9XSxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0tZXMyMDE1LXBhcmFtZXRlcnMnLFxuICAgICAgICAgICAgWyd0cmFuc2Zvcm0tZXMyMDE1LWRlc3RydWN0dXJpbmcnLCB7IGxvb3NlOiB0cnVlIH1dLFxuICAgICAgICAgICAgJ3RyYW5zZm9ybS1lczIwMTUtYmxvY2stc2NvcGluZycsXG4gICAgICAgICAgICAndHJhbnNmb3JtLWVzMjAxNS10eXBlb2Ytc3ltYm9sJyxcbiAgICAgICAgICAgIFsndHJhbnNmb3JtLWVzMjAxNS1tb2R1bGVzLWNvbW1vbmpzJywgeyBhbGxvd1RvcExldmVsVGhpczogdHJ1ZSB9XSxcbiAgICAgICAgICAgIFsndHJhbnNmb3JtLXJlZ2VuZXJhdG9yJywgeyBhc3luYzogZmFsc2UsIGFzeW5jR2VuZXJhdG9yczogZmFsc2UgfV1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIG9wdHNcbiAgICAgICkpLmNvZGVcbiAgICB9LFxuICAgIGJ1YmxlOiBmdW5jdGlvbiAoanMsIG9wdHMsIHVybCkge1xuICAgICAgb3B0cyA9IGV4dGVuZCh7XG4gICAgICAgIHNvdXJjZTogdXJsLFxuICAgICAgICBtb2R1bGVzOiBmYWxzZVxuICAgICAgfSwgb3B0cylcbiAgICAgIHJldHVybiBfcignYnVibGUnKS50cmFuc2Zvcm0oanMsIG9wdHMpLmNvZGVcbiAgICB9LFxuICAgIGNvZmZlZTogZnVuY3Rpb24gKGpzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gX3IoJ0NvZmZlZVNjcmlwdCcpLmNvbXBpbGUoanMsIGV4dGVuZCh7IGJhcmU6IHRydWUgfSwgb3B0cykpXG4gICAgfSxcbiAgICBsaXZlc2NyaXB0OiBmdW5jdGlvbiAoanMsIG9wdHMpIHtcbiAgICAgIHJldHVybiBfcignbGl2ZXNjcmlwdCcpLmNvbXBpbGUoanMsIGV4dGVuZCh7IGJhcmU6IHRydWUsIGhlYWRlcjogZmFsc2UgfSwgb3B0cykpXG4gICAgfSxcbiAgICB0eXBlc2NyaXB0OiBmdW5jdGlvbiAoanMsIG9wdHMpIHtcbiAgICAgIHJldHVybiBfcigndHlwZXNjcmlwdCcpKGpzLCBvcHRzKVxuICAgIH0sXG4gICAgbm9uZTogZnVuY3Rpb24gKGpzKSB7XG4gICAgICByZXR1cm4ganNcbiAgICB9XG4gIH1cbiAgX3AuanMuamF2YXNjcmlwdCAgID0gX3AuanMubm9uZVxuICBfcC5qcy5jb2ZmZWVzY3JpcHQgPSBfcC5qcy5jb2ZmZWVcbiAgX3AuX3JlcSAgPSBfcmVxXG4gIF9wLnV0aWxzID0ge1xuICAgIGV4dGVuZDogZXh0ZW5kXG4gIH1cblxuICByZXR1cm4gX3BcblxufSkod2luZG93IHx8IGdsb2JhbClcblxuLyoqXG4gKiBAbW9kdWxlIGNvbXBpbGVyXG4gKi9cblxudmFyIGV4dGVuZCA9IHBhcnNlcnMudXRpbHMuZXh0ZW5kXG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBTX0xJTkVTVFIgPSAvXCJbXlwiXFxuXFxcXF0qKD86XFxcXFtcXFNcXHNdW15cIlxcblxcXFxdKikqXCJ8J1teJ1xcblxcXFxdKig/OlxcXFxbXFxTXFxzXVteJ1xcblxcXFxdKikqJy8uc291cmNlXG5cbnZhciBTX1NUUklOR1MgPSBicmFja2V0cy5SX1NUUklOR1Muc291cmNlXG5cbnZhciBIVE1MX0FUVFJTID0gLyAqKFstXFx3OlxceEEwLVxceEZGXSspID8oPzo9ID8oJ1teJ10qJ3xcIlteXCJdKlwifFxcUyspKT8vZ1xuXG52YXIgSFRNTF9DT01NUyA9IFJlZ0V4cCgvPCEtLSg/IT4pW1xcU1xcc10qPy0tPi8uc291cmNlICsgJ3wnICsgU19MSU5FU1RSLCAnZycpXG5cbnZhciBIVE1MX1RBR1MgPSAvPCgtP1tBLVphLXpdWy1cXHdcXHhBMC1cXHhGRl0qKSg/OlxccysoW15cIidcXC8+XSooPzooPzpcIlteXCJdKlwifCdbXiddKid8XFwvW14+XSlbXidcIlxcLz5dKikqKXxcXHMqKShcXC8/KT4vZ1xuXG52YXIgSFRNTF9QQUNLID0gLz5bIFxcdF0rPCgtP1tBLVphLXpdfFxcL1stQS1aYS16XSkvZ1xuXG52YXIgUklPVF9BVFRSUyA9IFsnc3R5bGUnLCAnc3JjJywgJ2QnLCAndmFsdWUnXVxuXG52YXIgVk9JRF9UQUdTID0gL14oPzppbnB1dHxpbWd8YnJ8d2JyfGhyfGFyZWF8YmFzZXxjb2x8ZW1iZWR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2spJC9cblxudmFyIFBSRV9UQUdTID0gLzxwcmUoPzpcXHMrKD86W15cIj5dKnxcIlteXCJdKlwiKSopPz4oW1xcU1xcc10rPyk8XFwvcHJlXFxzKj4vZ2lcblxudmFyIFNQRUNfVFlQRVMgPSAvXlwiKD86bnVtYmVyfGRhdGUoPzp0aW1lKT98dGltZXxtb250aHxlbWFpbHxjb2xvcilcXGIvaVxuXG52YXIgSU1QT1JUX1NUQVRFTUVOVCA9IC9eXFxzKmltcG9ydCg/IVxcdykoPzooPzpcXHN8W15cXHMnXCJdKSopWyd8XCJdLipcXG4/L2dtXG5cbnZhciBUUklNX1RSQUlMID0gL1sgXFx0XSskL2dtXG5cbnZhclxuICBSRV9IQVNFWFBSID0gc2FmZVJlZ2V4KC9AI1xcZC8sICd4MDEnKSxcbiAgUkVfUkVQRVhQUiA9IHNhZmVSZWdleCgvQCMoXFxkKykvZywgJ3gwMScpLFxuICBDSF9JREVYUFIgID0gJ1xceDAxIycsXG4gIENIX0RRQ09ERSAgPSAnXFx1MjA1NycsXG4gIERRID0gJ1wiJyxcbiAgU1EgPSBcIidcIlxuXG5mdW5jdGlvbiBjbGVhblNvdXJjZSAoc3JjKSB7XG4gIHZhclxuICAgIG1tLFxuICAgIHJlID0gSFRNTF9DT01NU1xuXG4gIGlmICh+c3JjLmluZGV4T2YoJ1xccicpKSB7XG4gICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpXG4gIH1cblxuICByZS5sYXN0SW5kZXggPSAwXG4gIHdoaWxlICgobW0gPSByZS5leGVjKHNyYykpKSB7XG4gICAgaWYgKG1tWzBdWzBdID09PSAnPCcpIHtcbiAgICAgIHNyYyA9IFJlZ0V4cC5sZWZ0Q29udGV4dCArIFJlZ0V4cC5yaWdodENvbnRleHRcbiAgICAgIHJlLmxhc3RJbmRleCA9IG1tWzNdICsgMVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3JjXG59XG5cbmZ1bmN0aW9uIHBhcnNlQXR0cmlicyAoc3RyLCBwY2V4KSB7XG4gIHZhclxuICAgIGxpc3QgPSBbXSxcbiAgICBtYXRjaCxcbiAgICB0eXBlLCB2ZXhwXG5cbiAgSFRNTF9BVFRSUy5sYXN0SW5kZXggPSAwXG5cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1xccysvZywgJyAnKVxuXG4gIHdoaWxlICgobWF0Y2ggPSBIVE1MX0FUVFJTLmV4ZWMoc3RyKSkpIHtcbiAgICB2YXJcbiAgICAgIGsgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgdiA9IG1hdGNoWzJdXG5cbiAgICBpZiAoIXYpIHtcbiAgICAgIGxpc3QucHVzaChrKVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICh2WzBdICE9PSBEUSkge1xuICAgICAgICB2ID0gRFEgKyAodlswXSA9PT0gU1EgPyB2LnNsaWNlKDEsIC0xKSA6IHYpICsgRFFcbiAgICAgIH1cblxuICAgICAgaWYgKGsgPT09ICd0eXBlJyAmJiBTUEVDX1RZUEVTLnRlc3QodikpIHtcbiAgICAgICAgdHlwZSA9IHZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChSRV9IQVNFWFBSLnRlc3QodikpIHtcblxuICAgICAgICAgIGlmIChrID09PSAndmFsdWUnKSB2ZXhwID0gMVxuICAgICAgICAgIGlmICh+UklPVF9BVFRSUy5pbmRleE9mKGspKSBrID0gJ3Jpb3QtJyArIGtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChrICsgJz0nICsgdilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSkge1xuICAgIGlmICh2ZXhwKSB0eXBlID0gRFEgKyBwY2V4Ll9icFswXSArIFNRICsgdHlwZS5zbGljZSgxLCAtMSkgKyBTUSArIHBjZXguX2JwWzFdICsgRFFcbiAgICBsaXN0LnB1c2goJ3R5cGU9JyArIHR5cGUpXG4gIH1cbiAgcmV0dXJuIGxpc3Quam9pbignICcpXG59XG5cbmZ1bmN0aW9uIHNwbGl0SHRtbCAoaHRtbCwgb3B0cywgcGNleCkge1xuICB2YXIgX2JwID0gcGNleC5fYnBcblxuICBpZiAoaHRtbCAmJiBfYnBbNF0udGVzdChodG1sKSkge1xuICAgIHZhclxuICAgICAganNmbiA9IG9wdHMuZXhwciAmJiAob3B0cy5wYXJzZXIgfHwgb3B0cy50eXBlKSA/IF9jb21waWxlSlMgOiAwLFxuICAgICAgbGlzdCA9IGJyYWNrZXRzLnNwbGl0KGh0bWwsIDAsIF9icCksXG4gICAgICBleHByXG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGV4cHIgPSBsaXN0W2ldXG4gICAgICBpZiAoZXhwclswXSA9PT0gJ14nKSB7XG4gICAgICAgIGV4cHIgPSBleHByLnNsaWNlKDEpXG4gICAgICB9IGVsc2UgaWYgKGpzZm4pIHtcbiAgICAgICAgZXhwciA9IGpzZm4oZXhwciwgb3B0cykudHJpbSgpXG4gICAgICAgIGlmIChleHByLnNsaWNlKC0xKSA9PT0gJzsnKSBleHByID0gZXhwci5zbGljZSgwLCAtMSlcbiAgICAgIH1cbiAgICAgIGxpc3RbaV0gPSBDSF9JREVYUFIgKyAocGNleC5wdXNoKGV4cHIpIC0gMSkgKyBfYnBbMV1cbiAgICB9XG4gICAgaHRtbCA9IGxpc3Quam9pbignJylcbiAgfVxuICByZXR1cm4gaHRtbFxufVxuXG5mdW5jdGlvbiByZXN0b3JlRXhwciAoaHRtbCwgcGNleCkge1xuICBpZiAocGNleC5sZW5ndGgpIHtcbiAgICBodG1sID0gaHRtbC5yZXBsYWNlKFJFX1JFUEVYUFIsIGZ1bmN0aW9uIChfLCBkKSB7XG5cbiAgICAgIHJldHVybiBwY2V4Ll9icFswXSArIHBjZXhbZF0udHJpbSgpLnJlcGxhY2UoL1tcXHJcXG5dKy9nLCAnICcpLnJlcGxhY2UoL1wiL2csIENIX0RRQ09ERSlcbiAgICB9KVxuICB9XG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIF9jb21waWxlSFRNTCAoaHRtbCwgb3B0cywgcGNleCkge1xuICBpZiAoIS9cXFMvLnRlc3QoaHRtbCkpIHJldHVybiAnJ1xuXG4gIGh0bWwgPSBzcGxpdEh0bWwoaHRtbCwgb3B0cywgcGNleClcbiAgICAucmVwbGFjZShIVE1MX1RBR1MsIGZ1bmN0aW9uIChfLCBuYW1lLCBhdHRyLCBlbmRzKSB7XG5cbiAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgICAgZW5kcyA9IGVuZHMgJiYgIVZPSURfVEFHUy50ZXN0KG5hbWUpID8gJz48LycgKyBuYW1lIDogJydcblxuICAgICAgaWYgKGF0dHIpIG5hbWUgKz0gJyAnICsgcGFyc2VBdHRyaWJzKGF0dHIsIHBjZXgpXG5cbiAgICAgIHJldHVybiAnPCcgKyBuYW1lICsgZW5kcyArICc+J1xuICAgIH0pXG5cbiAgaWYgKCFvcHRzLndoaXRlc3BhY2UpIHtcbiAgICB2YXIgcCA9IFtdXG5cbiAgICBpZiAoLzxwcmVbXFxzPl0vLnRlc3QoaHRtbCkpIHtcbiAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoUFJFX1RBR1MsIGZ1bmN0aW9uIChxKSB7XG4gICAgICAgIHAucHVzaChxKVxuICAgICAgICByZXR1cm4gJ1xcdTAwMDInXG4gICAgICB9KVxuICAgIH1cblxuICAgIGh0bWwgPSBodG1sLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJylcblxuICAgIGlmIChwLmxlbmd0aCkgaHRtbCA9IGh0bWwucmVwbGFjZSgvXFx1MDAwMi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwLnNoaWZ0KCkgfSlcbiAgfVxuXG4gIGlmIChvcHRzLmNvbXBhY3QpIGh0bWwgPSBodG1sLnJlcGxhY2UoSFRNTF9QQUNLLCAnPjwkMScpXG5cbiAgcmV0dXJuIHJlc3RvcmVFeHByKGh0bWwsIHBjZXgpLnJlcGxhY2UoVFJJTV9UUkFJTCwgJycpXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVIVE1MIChodG1sLCBvcHRzLCBwY2V4KSB7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICBwY2V4ID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9IGVsc2Uge1xuICAgIGlmICghcGNleCkgcGNleCA9IFtdXG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgfVxuXG4gIHBjZXguX2JwID0gYnJhY2tldHMuYXJyYXkob3B0cy5icmFja2V0cylcblxuICByZXR1cm4gX2NvbXBpbGVIVE1MKGNsZWFuU291cmNlKGh0bWwpLCBvcHRzLCBwY2V4KVxufVxuXG52YXIgSlNfRVM2U0lHTiA9IC9eWyBcXHRdKigoKD86YXN5bmN8XFwqKVxccyopPyhbJF9BLVphLXpdWyRcXHddKikpXFxzKlxcKFteKCldKlxcKVxccyp7L21cblxudmFyIEpTX0VTNkVORCA9IFJlZ0V4cCgnW3t9XXwnICsgYnJhY2tldHMuU19RQkxPQ0tTLCAnZycpXG5cbnZhciBKU19DT01NUyA9IFJlZ0V4cChicmFja2V0cy5SX01MQ09NTVMuc291cmNlICsgJ3wvL1teXFxyXFxuXSp8JyArIGJyYWNrZXRzLlNfUUJMT0NLUywgJ2cnKVxuXG5mdW5jdGlvbiByaW90anMgKGpzKSB7XG4gIHZhclxuICAgIHBhcnRzID0gW10sXG4gICAgbWF0Y2gsXG4gICAgdG9lczUsXG4gICAgcG9zLFxuICAgIG1ldGhvZCxcbiAgICBwcmVmaXgsXG4gICAgbmFtZSxcbiAgICBSRSA9IFJlZ0V4cFxuXG4gIGlmICh+anMuaW5kZXhPZignLycpKSBqcyA9IHJtQ29tbXMoanMsIEpTX0NPTU1TKVxuXG4gIHdoaWxlICgobWF0Y2ggPSBqcy5tYXRjaChKU19FUzZTSUdOKSkpIHtcblxuICAgIHBhcnRzLnB1c2goUkUubGVmdENvbnRleHQpXG4gICAganMgID0gUkUucmlnaHRDb250ZXh0XG4gICAgcG9zID0gc2tpcEJvZHkoanMsIEpTX0VTNkVORClcblxuICAgIG1ldGhvZCA9IG1hdGNoWzFdXG4gICAgcHJlZml4ID0gbWF0Y2hbMl0gfHwgJydcbiAgICBuYW1lICA9IG1hdGNoWzNdXG5cbiAgICB0b2VzNSA9ICEvXig/OmlmfHdoaWxlfGZvcnxzd2l0Y2h8Y2F0Y2h8ZnVuY3Rpb24pJC8udGVzdChuYW1lKVxuXG4gICAgaWYgKHRvZXM1KSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMF0ucmVwbGFjZShtZXRob2QsICd0aGlzLicgKyBuYW1lICsgJyA9JyArIHByZWZpeCArICcgZnVuY3Rpb24nKVxuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbWF0Y2hbMF1cbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKG5hbWUsIGpzLnNsaWNlKDAsIHBvcykpXG4gICAganMgPSBqcy5zbGljZShwb3MpXG5cbiAgICBpZiAodG9lczUgJiYgIS9eXFxzKi5cXHMqYmluZFxcYi8udGVzdChqcykpIHBhcnRzLnB1c2goJy5iaW5kKHRoaXMpJylcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPyBwYXJ0cy5qb2luKCcnKSArIGpzIDoganNcblxuICBmdW5jdGlvbiBybUNvbW1zIChzLCByLCBtKSB7XG4gICAgci5sYXN0SW5kZXggPSAwXG4gICAgd2hpbGUgKChtID0gci5leGVjKHMpKSkge1xuICAgICAgaWYgKG1bMF1bMF0gPT09ICcvJyAmJiAhbVsxXSAmJiAhbVsyXSkge1xuICAgICAgICBzID0gUkUubGVmdENvbnRleHQgKyAnICcgKyBSRS5yaWdodENvbnRleHRcbiAgICAgICAgci5sYXN0SW5kZXggPSBtWzNdICsgMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc1xuICB9XG5cbiAgZnVuY3Rpb24gc2tpcEJvZHkgKHMsIHIpIHtcbiAgICB2YXIgbSwgaSA9IDFcblxuICAgIHIubGFzdEluZGV4ID0gMFxuICAgIHdoaWxlIChpICYmIChtID0gci5leGVjKHMpKSkge1xuICAgICAgaWYgKG1bMF0gPT09ICd7JykgKytpXG4gICAgICBlbHNlIGlmIChtWzBdID09PSAnfScpIC0taVxuICAgIH1cbiAgICByZXR1cm4gaSA/IHMubGVuZ3RoIDogci5sYXN0SW5kZXhcbiAgfVxufVxuXG5mdW5jdGlvbiBfY29tcGlsZUpTIChqcywgb3B0cywgdHlwZSwgcGFyc2VyT3B0cywgdXJsKSB7XG4gIGlmICghL1xcUy8udGVzdChqcykpIHJldHVybiAnJ1xuICBpZiAoIXR5cGUpIHR5cGUgPSBvcHRzLnR5cGVcblxuICB2YXIgcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgdHlwZSAmJiBwYXJzZXJzLl9yZXEoJ2pzLicgKyB0eXBlLCB0cnVlKSB8fCByaW90anNcblxuICByZXR1cm4gcGFyc2VyKGpzLCBwYXJzZXJPcHRzLCB1cmwpLnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpLnJlcGxhY2UoVFJJTV9UUkFJTCwgJycpXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVKUyAoanMsIG9wdHMsIHR5cGUsIHVzZXJPcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICB1c2VyT3B0cyA9IHR5cGVcbiAgICB0eXBlID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHVzZXJPcHRzID0gdHlwZVxuICAgIHR5cGUgPSAnJ1xuICB9XG4gIGlmICghdXNlck9wdHMpIHVzZXJPcHRzID0ge31cblxuICByZXR1cm4gX2NvbXBpbGVKUyhqcywgb3B0cyB8fCB7fSwgdHlwZSwgdXNlck9wdHMucGFyc2VyT3B0aW9ucywgdXNlck9wdHMudXJsKVxufVxuXG52YXIgQ1NTX1NFTEVDVE9SID0gUmVnRXhwKCcoW3t9XXxeKVs7IF0qKCg/OlteQCA7e31dW157fV0qKT9bXkAgO3t9Ol0gPykoPz17KXwnICsgU19MSU5FU1RSLCAnZycpXG5cbmZ1bmN0aW9uIHNjb3BlZENTUyAodGFnLCBjc3MpIHtcbiAgdmFyIHNjb3BlID0gJzpzY29wZSdcblxuICByZXR1cm4gY3NzLnJlcGxhY2UoQ1NTX1NFTEVDVE9SLCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XG5cbiAgICBpZiAoIXAyKSByZXR1cm4gbVxuXG4gICAgcDIgPSBwMi5yZXBsYWNlKC9bXixdKy9nLCBmdW5jdGlvbiAoc2VsKSB7XG4gICAgICB2YXIgcyA9IHNlbC50cmltKClcblxuICAgICAgaWYgKHMuaW5kZXhPZih0YWcpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxcbiAgICAgIH1cblxuICAgICAgaWYgKCFzIHx8IHMgPT09ICdmcm9tJyB8fCBzID09PSAndG8nIHx8IHMuc2xpY2UoLTEpID09PSAnJScpIHtcbiAgICAgICAgcmV0dXJuIHNlbFxuICAgICAgfVxuXG4gICAgICBpZiAocy5pbmRleE9mKHNjb3BlKSA8IDApIHtcbiAgICAgICAgcyA9IHRhZyArICcgJyArIHMgKyAnLFtkYXRhLWlzPVwiJyArIHRhZyArICdcIl0gJyArIHNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2NvcGUsIHRhZykgKyAnLCcgK1xuICAgICAgICAgICAgcy5yZXBsYWNlKHNjb3BlLCAnW2RhdGEtaXM9XCInICsgdGFnICsgJ1wiXScpXG4gICAgICB9XG4gICAgICByZXR1cm4gc1xuICAgIH0pXG5cbiAgICByZXR1cm4gcDEgPyBwMSArICcgJyArIHAyIDogcDJcbiAgfSlcbn1cblxuZnVuY3Rpb24gX2NvbXBpbGVDU1MgKGNzcywgdGFnLCB0eXBlLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPT0gJ2NzcycpIHtcblxuICAgICAgdmFyIHBhcnNlciA9IHBhcnNlcnMuX3JlcSgnY3NzLicgKyB0eXBlLCB0cnVlKVxuICAgICAgY3NzID0gcGFyc2VyKHRhZywgY3NzLCBvcHRzLnBhcnNlck9wdHMgfHwge30sIG9wdHMudXJsKVxuICAgIH1cbiAgfVxuXG4gIGNzcyA9IGNzcy5yZXBsYWNlKGJyYWNrZXRzLlJfTUxDT01NUywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKClcbiAgaWYgKHRhZykgY3NzID0gc2NvcGVkQ1NTKHRhZywgY3NzKVxuXG4gIHJldHVybiBjc3Ncbn1cblxuZnVuY3Rpb24gY29tcGlsZUNTUyAoY3NzLCB0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB0eXBlXG4gICAgdHlwZSA9ICcnXG4gIH0gZWxzZSBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIHJldHVybiBfY29tcGlsZUNTUyhjc3MsIG9wdHMudGFnTmFtZSwgdHlwZSwgb3B0cylcbn1cblxudmFyIFRZUEVfQVRUUiA9IC9cXHN0eXBlXFxzKj1cXHMqKD86KFsnXCJdKSguKz8pXFwxfChcXFMrKSkvaVxuXG52YXIgTUlTQ19BVFRSID0gJ1xcXFxzKj1cXFxccyooJyArIFNfU1RSSU5HUyArICd8e1tefV0rfXxcXFxcUyspJ1xuXG52YXIgRU5EX1RBR1MgPSAvXFwvPlxcbnxePCg/OlxcLz8tP1tBLVphLXpdWy1cXHdcXHhBMC1cXHhGRl0qXFxzKnwtP1tBLVphLXpdWy1cXHdcXHhBMC1cXHhGRl0qXFxzK1stXFx3OlxceEEwLVxceEZGXVtcXFNcXHNdKj8pPlxcbi9cblxuZnVuY3Rpb24gX3EgKHMsIHIpIHtcbiAgaWYgKCFzKSByZXR1cm4gXCInJ1wiXG4gIHMgPSBTUSArIHMucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIikgKyBTUVxuICByZXR1cm4gciAmJiB+cy5pbmRleE9mKCdcXG4nKSA/IHMucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIDogc1xufVxuXG5mdW5jdGlvbiBta3RhZyAobmFtZSwgaHRtbCwgY3NzLCBhdHRyLCBqcywgaW1wb3J0cywgb3B0cykge1xuICB2YXJcbiAgICBjID0gb3B0cy5kZWJ1ZyA/ICcsXFxuICAnIDogJywgJyxcbiAgICBzID0gJ30pOydcblxuICBpZiAoanMgJiYganMuc2xpY2UoLTEpICE9PSAnXFxuJykgcyA9ICdcXG4nICsgc1xuXG4gIHJldHVybiBpbXBvcnRzICsgJ3Jpb3QudGFnMihcXCcnICsgbmFtZSArIFNRICtcbiAgICBjICsgX3EoaHRtbCwgMSkgK1xuICAgIGMgKyBfcShjc3MpICtcbiAgICBjICsgX3EoYXR0cikgKyAnLCBmdW5jdGlvbihvcHRzKSB7XFxuJyArIGpzICsgc1xufVxuXG5mdW5jdGlvbiBzcGxpdEJsb2NrcyAoc3RyKSB7XG4gIGlmICgvPFstXFx3XS8udGVzdChzdHIpKSB7XG4gICAgdmFyXG4gICAgICBtLFxuICAgICAgayA9IHN0ci5sYXN0SW5kZXhPZignPCcpLFxuICAgICAgbiA9IHN0ci5sZW5ndGhcblxuICAgIHdoaWxlICh+aykge1xuICAgICAgbSA9IHN0ci5zbGljZShrLCBuKS5tYXRjaChFTkRfVEFHUylcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGsgKz0gbS5pbmRleCArIG1bMF0ubGVuZ3RoXG4gICAgICAgIG0gPSBzdHIuc2xpY2UoMCwgaylcbiAgICAgICAgaWYgKG0uc2xpY2UoLTUpID09PSAnPC0vPlxcbicpIG0gPSBtLnNsaWNlKDAsIC01KVxuICAgICAgICByZXR1cm4gW20sIHN0ci5zbGljZShrKV1cbiAgICAgIH1cbiAgICAgIG4gPSBrXG4gICAgICBrID0gc3RyLmxhc3RJbmRleE9mKCc8JywgayAtIDEpXG4gICAgfVxuICB9XG4gIHJldHVybiBbJycsIHN0cl1cbn1cblxuZnVuY3Rpb24gZ2V0VHlwZSAoYXR0cmlicykge1xuICBpZiAoYXR0cmlicykge1xuICAgIHZhciBtYXRjaCA9IGF0dHJpYnMubWF0Y2goVFlQRV9BVFRSKVxuXG4gICAgbWF0Y2ggPSBtYXRjaCAmJiAobWF0Y2hbMl0gfHwgbWF0Y2hbM10pXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2gucmVwbGFjZSgndGV4dC8nLCAnJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYiAoYXR0cmlicywgbmFtZSkge1xuICBpZiAoYXR0cmlicykge1xuICAgIHZhciBtYXRjaCA9IGF0dHJpYnMubWF0Y2goUmVnRXhwKCdcXFxccycgKyBuYW1lICsgTUlTQ19BVFRSLCAnaScpKVxuXG4gICAgbWF0Y2ggPSBtYXRjaCAmJiBtYXRjaFsxXVxuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuICgvXlsnXCJdLykudGVzdChtYXRjaCkgPyBtYXRjaC5zbGljZSgxLCAtMSkgOiBtYXRjaFxuICAgIH1cbiAgfVxuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVIVE1MIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgICAgICAgIC5yZXBsYWNlKC8mYW1wOy9nLCAnJicpXG4gICAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxuICAgICAgICAgIC5yZXBsYWNlKC8mZ3Q7L2csICc+JylcbiAgICAgICAgICAucmVwbGFjZSgvJnF1b3Q7L2csICdcIicpXG4gICAgICAgICAgLnJlcGxhY2UoLyYjMDM5Oy9nLCAnXFwnJylcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2VyT3B0aW9ucyAoYXR0cmlicykge1xuICB2YXIgb3B0cyA9IHVuZXNjYXBlSFRNTChnZXRBdHRyaWIoYXR0cmlicywgJ29wdGlvbnMnKSlcblxuICByZXR1cm4gb3B0cyA/IEpTT04ucGFyc2Uob3B0cykgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGdldENvZGUgKGNvZGUsIG9wdHMsIGF0dHJpYnMsIGJhc2UpIHtcbiAgdmFyXG4gICAgdHlwZSA9IGdldFR5cGUoYXR0cmlicyksXG4gICAgc3JjICA9IGdldEF0dHJpYihhdHRyaWJzLCAnc3JjJyksXG4gICAganNQYXJzZXJPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRzLnBhcnNlck9wdGlvbnMuanMpXG5cbiAgaWYgKHNyYykgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIF9jb21waWxlSlMoXG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBvcHRzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZXh0ZW5kKGpzUGFyc2VyT3B0aW9ucywgZ2V0UGFyc2VyT3B0aW9ucyhhdHRyaWJzKSksXG4gICAgICAgICAgYmFzZVxuICAgICAgICApXG59XG5cbmZ1bmN0aW9uIGNzc0NvZGUgKGNvZGUsIG9wdHMsIGF0dHJpYnMsIHVybCwgdGFnKSB7XG4gIHZhclxuICAgIHBhcnNlclN0eWxlT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0cy5wYXJzZXJPcHRpb25zLnN0eWxlKSxcbiAgICBleHRyYU9wdHMgPSB7XG4gICAgICBwYXJzZXJPcHRzOiBleHRlbmQocGFyc2VyU3R5bGVPcHRpb25zLCBnZXRQYXJzZXJPcHRpb25zKGF0dHJpYnMpKSxcbiAgICAgIHVybDogdXJsXG4gICAgfVxuXG4gIHJldHVybiBfY29tcGlsZUNTUyhjb2RlLCB0YWcsIGdldFR5cGUoYXR0cmlicykgfHwgb3B0cy5zdHlsZSwgZXh0cmFPcHRzKVxufVxuXG5mdW5jdGlvbiBjb21waWxlVGVtcGxhdGUgKGh0bWwsIHVybCwgbGFuZywgb3B0cykge1xuXG4gIHZhciBwYXJzZXIgPSBwYXJzZXJzLl9yZXEoJ2h0bWwuJyArIGxhbmcsIHRydWUpXG4gIHJldHVybiBwYXJzZXIoaHRtbCwgb3B0cywgdXJsKVxufVxuXG52YXJcblxuICBDVVNUX1RBRyA9IFJlZ0V4cCgvXihbIFxcdF0qKTwoLT9bQS1aYS16XVstXFx3XFx4QTAtXFx4RkZdKikoPzpcXHMrKFteJ1wiXFwvPl0rKD86KD86QHxcXC9bXj5dKVteJ1wiXFwvPl0qKSopfFxccyopPyg/OlxcLz58PlsgXFx0XSpcXG4/KFtcXFNcXHNdKileXFwxPFxcL1xcMlxccyo+fD4oLiopPFxcL1xcMlxccyo+KS9cbiAgICAuc291cmNlLnJlcGxhY2UoJ0AnLCBTX1NUUklOR1MpLCAnZ2ltJyksXG5cbiAgU0NSSVBUUyA9IC88c2NyaXB0KFxccytbXj5dKik/Plxcbj8oW1xcU1xcc10qPyk8XFwvc2NyaXB0XFxzKj4vZ2ksXG5cbiAgU1RZTEVTID0gLzxzdHlsZShcXHMrW14+XSopPz5cXG4/KFtcXFNcXHNdKj8pPFxcL3N0eWxlXFxzKj4vZ2lcblxuZnVuY3Rpb24gY29tcGlsZSAoc3JjLCBvcHRzLCB1cmwpIHtcbiAgdmFyXG4gICAgcGFydHMgPSBbXSxcbiAgICBpbmNsdWRlZCxcbiAgICBkZWZhdWx0UGFyc2VycHRpb25zID0ge1xuXG4gICAgICB0ZW1wbGF0ZToge30sXG4gICAgICBqczoge30sXG4gICAgICBzdHlsZToge31cbiAgICB9XG5cbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cblxuICBvcHRzLnBhcnNlck9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdFBhcnNlcnB0aW9ucywgb3B0cy5wYXJzZXJPcHRpb25zIHx8IHt9KVxuXG4gIGluY2x1ZGVkID0gb3B0cy5leGNsdWRlXG4gICAgPyBmdW5jdGlvbiAocykgeyByZXR1cm4gb3B0cy5leGNsdWRlLmluZGV4T2YocykgPCAwIH0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH1cblxuICBpZiAoIXVybCkgdXJsID0gJydcblxuICB2YXIgX2JwID0gYnJhY2tldHMuYXJyYXkob3B0cy5icmFja2V0cylcblxuICBpZiAob3B0cy50ZW1wbGF0ZSkge1xuICAgIHNyYyA9IGNvbXBpbGVUZW1wbGF0ZShzcmMsIHVybCwgb3B0cy50ZW1wbGF0ZSwgb3B0cy5wYXJzZXJPcHRpb25zLnRlbXBsYXRlKVxuICB9XG5cbiAgc3JjID0gY2xlYW5Tb3VyY2Uoc3JjKVxuICAgIC5yZXBsYWNlKENVU1RfVEFHLCBmdW5jdGlvbiAoXywgaW5kZW50LCB0YWdOYW1lLCBhdHRyaWJzLCBib2R5LCBib2R5Mikge1xuICAgICAgdmFyXG4gICAgICAgIGpzY29kZSA9ICcnLFxuICAgICAgICBzdHlsZXMgPSAnJyxcbiAgICAgICAgaHRtbCA9ICcnLFxuICAgICAgICBpbXBvcnRzID0gJycsXG4gICAgICAgIHBjZXggPSBbXVxuXG4gICAgICBwY2V4Ll9icCA9IF9icFxuXG4gICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAgIGF0dHJpYnMgPSBhdHRyaWJzICYmIGluY2x1ZGVkKCdhdHRyaWJzJylcbiAgICAgICAgPyByZXN0b3JlRXhwcihcbiAgICAgICAgICAgIHBhcnNlQXR0cmlicyhcbiAgICAgICAgICAgICAgc3BsaXRIdG1sKGF0dHJpYnMsIG9wdHMsIHBjZXgpLFxuICAgICAgICAgICAgcGNleCksXG4gICAgICAgICAgcGNleCkgOiAnJ1xuXG4gICAgICBpZiAoKGJvZHkgfHwgKGJvZHkgPSBib2R5MikpICYmIC9cXFMvLnRlc3QoYm9keSkpIHtcblxuICAgICAgICBpZiAoYm9keTIpIHtcblxuICAgICAgICAgIGlmIChpbmNsdWRlZCgnaHRtbCcpKSBodG1sID0gX2NvbXBpbGVIVE1MKGJvZHkyLCBvcHRzLCBwY2V4KVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgYm9keSA9IGJvZHkucmVwbGFjZShSZWdFeHAoJ14nICsgaW5kZW50LCAnZ20nKSwgJycpXG5cbiAgICAgICAgICBib2R5ID0gYm9keS5yZXBsYWNlKFNDUklQVFMsIGZ1bmN0aW9uIChfbSwgX2F0dHJzLCBfc2NyaXB0KSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZWQoJ2pzJykpIHtcbiAgICAgICAgICAgICAgdmFyIGNvZGUgPSBnZXRDb2RlKF9zY3JpcHQsIG9wdHMsIF9hdHRycywgdXJsKVxuXG4gICAgICAgICAgICAgIGlmIChjb2RlKSBqc2NvZGUgKz0gKGpzY29kZSA/ICdcXG4nIDogJycpICsgY29kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoU1RZTEVTLCBmdW5jdGlvbiAoX20sIF9hdHRycywgX3N0eWxlKSB7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZWQoJ2NzcycpKSB7XG4gICAgICAgICAgICAgIHN0eWxlcyArPSAoc3R5bGVzID8gJyAnIDogJycpICsgY3NzQ29kZShfc3R5bGUsIG9wdHMsIF9hdHRycywgdXJsLCB0YWdOYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHZhciBibG9ja3MgPSBzcGxpdEJsb2Nrcyhib2R5LnJlcGxhY2UoVFJJTV9UUkFJTCwgJycpKVxuXG4gICAgICAgICAgaWYgKGluY2x1ZGVkKCdodG1sJykpIHtcbiAgICAgICAgICAgIGh0bWwgPSBfY29tcGlsZUhUTUwoYmxvY2tzWzBdLCBvcHRzLCBwY2V4KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmNsdWRlZCgnanMnKSkge1xuICAgICAgICAgICAgYm9keSA9IF9jb21waWxlSlMoYmxvY2tzWzFdLCBvcHRzLCBudWxsLCBudWxsLCB1cmwpXG4gICAgICAgICAgICBpZiAoYm9keSkganNjb2RlICs9IChqc2NvZGUgPyAnXFxuJyA6ICcnKSArIGJvZHlcbiAgICAgICAgICAgIGpzY29kZSA9IGpzY29kZS5yZXBsYWNlKElNUE9SVF9TVEFURU1FTlQsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgIGltcG9ydHMgKz0gcy50cmltKCkgKyAnXFxuJ1xuICAgICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGpzY29kZSA9IC9cXFMvLnRlc3QoanNjb2RlKSA/IGpzY29kZS5yZXBsYWNlKC9cXG57Myx9L2csICdcXG5cXG4nKSA6ICcnXG5cbiAgICAgIGlmIChvcHRzLmVudGl0aWVzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgICAgICAgaHRtbDogaHRtbCxcbiAgICAgICAgICBjc3M6IHN0eWxlcyxcbiAgICAgICAgICBhdHRyaWJzOiBhdHRyaWJzLFxuICAgICAgICAgIGpzOiBqc2NvZGUsXG4gICAgICAgICAgaW1wb3J0czogaW1wb3J0c1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1rdGFnKHRhZ05hbWUsIGh0bWwsIHN0eWxlcywgYXR0cmlicywganNjb2RlLCBpbXBvcnRzLCBvcHRzKVxuICAgIH0pXG5cbiAgaWYgKG9wdHMuZW50aXRpZXMpIHJldHVybiBwYXJ0c1xuXG4gIHJldHVybiBzcmNcbn1cblxudmFyIHZlcnNpb24gPSAndjMuMi4xJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXBpbGUsXG4gIGNvbXBpbGVIVE1MLFxuICBjb21waWxlQ1NTLFxuICBjb21waWxlSlMsXG4gIHBhcnNlcnMsXG4gIHZlcnNpb25cbn1cbiIsIi8vIGltcG9ydCBobGpzIGZyb20gXCJoaWdobGlnaHQuanNcIjtcclxuaW1wb3J0IHJpb3QgZnJvbSBcInJpb3QvcmlvdCtjb21waWxlclwiO1xyXG5pbXBvcnQgY29tcGlsZXIgZnJvbSBcInJpb3QtY29tcGlsZXJcIjtcclxuXHJcbnJpb3QubW91bnQoJyonKTtcclxuXHJcbi8vIGNvbXBpbGVyLmNvbXBpbGUoZnVuY3Rpb24oKSB7XHJcbi8vICAgLy8gaGVyZSB0YWdzIGFyZSBjb21waWxlZCBhbmQgcmlvdC5tb3VudCB3b3JrcyBzeW5jaHJvbm91c2x5XHJcbi8vICAgdmFyIHRhZ3MgPSByaW90Lm1vdW50KCcqJylcclxuLy8gICBjb25zb2xlLmxvZyhcInRhZ3NcIiwgdGFncyk7XHJcbi8vIH0pIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJ0aGlzIiwiX19UQUdTX0NBQ0hFIiwiX19UQUdfSU1QTCIsIkdMT0JBTF9NSVhJTiIsIkFUVFJTX1BSRUZJWCIsIlJFRl9ESVJFQ1RJVkVTIiwiSVNfRElSRUNUSVZFIiwiQ09ORElUSU9OQUxfRElSRUNUSVZFIiwiTE9PUF9ESVJFQ1RJVkUiLCJMT09QX05PX1JFT1JERVJfRElSRUNUSVZFIiwiU0hPV19ESVJFQ1RJVkUiLCJISURFX0RJUkVDVElWRSIsIlJJT1RfRVZFTlRTX0tFWSIsIlRfU1RSSU5HIiwiVF9PQkpFQ1QiLCJUX1VOREVGIiwiVF9GVU5DVElPTiIsIlhMSU5LX05TIiwiWExJTktfUkVHRVgiLCJXSU4iLCJ3aW5kb3ciLCJ1bmRlZmluZWQiLCJSRV9TUEVDSUFMX1RBR1MiLCJSRV9TUEVDSUFMX1RBR1NfTk9fT1BUSU9OIiwiUkVfRVZFTlRTX1BSRUZJWCIsIlJFX1JFU0VSVkVEX05BTUVTIiwiUkVfSFRNTF9BVFRSUyIsIkNBU0VfU0VOU0lUSVZFX0FUVFJJQlVURVMiLCJSRV9CT09MX0FUVFJTIiwiSUVfVkVSU0lPTiIsImRvY3VtZW50IiwiZG9jdW1lbnRNb2RlIiwiaXNCb29sQXR0ciIsInZhbHVlIiwidGVzdCIsImlzRnVuY3Rpb24iLCJpc09iamVjdCIsImlzVW5kZWZpbmVkIiwiaXNTdHJpbmciLCJpc0JsYW5rIiwiaXNBcnJheSIsIkFycmF5IiwiaXNXcml0YWJsZSIsIm9iaiIsImtleSIsImRlc2NyaXB0b3IiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ3cml0YWJsZSIsImlzUmVzZXJ2ZWROYW1lIiwiY2hlY2siLCJmcmVlemUiLCIkJCIsInNlbGVjdG9yIiwiY3R4IiwicXVlcnlTZWxlY3RvckFsbCIsIiQiLCJxdWVyeVNlbGVjdG9yIiwiY3JlYXRlRnJhZyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJjcmVhdGVET01QbGFjZWhvbGRlciIsImNyZWF0ZVRleHROb2RlIiwibWtFbCIsIm5hbWUiLCJjcmVhdGVFbGVtZW50Iiwic2V0SW5uZXJIVE1MIiwiY29udGFpbmVyIiwiaHRtbCIsImlubmVySFRNTCIsImRvYyIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsIm5vZGUiLCJvd25lckRvY3VtZW50IiwiaW1wb3J0Tm9kZSIsImRvY3VtZW50RWxlbWVudCIsImFwcGVuZENoaWxkIiwidG9nZ2xlVmlzaWJpbGl0eSIsImRvbSIsInNob3ciLCJzdHlsZSIsImRpc3BsYXkiLCJyZW1BdHRyIiwicmVtb3ZlQXR0cmlidXRlIiwic3R5bGVPYmplY3RUb1N0cmluZyIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJwcm9wIiwiZ2V0QXR0ciIsImdldEF0dHJpYnV0ZSIsInNldEF0dHIiLCJ2YWwiLCJ4bGluayIsImV4ZWMiLCJzZXRBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZSIsInNhZmVJbnNlcnQiLCJyb290IiwiY3VyciIsIm5leHQiLCJpbnNlcnRCZWZvcmUiLCJwYXJlbnROb2RlIiwid2Fsa0F0dHJzIiwiZm4iLCJtIiwidG9Mb3dlckNhc2UiLCJ3YWxrTm9kZXMiLCJjb250ZXh0IiwicmVzIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwic3R5bGVOb2RlIiwiY3NzVGV4dFByb3AiLCJieU5hbWUiLCJyZW1haW5kZXIiLCJuZWVkc0luamVjdCIsIm5ld05vZGUiLCJ1c2VyTm9kZSIsImlkIiwicmVwbGFjZUNoaWxkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZVNoZWV0Iiwic3R5bGVNYW5hZ2VyIiwiYWRkIiwiY3NzIiwicHVzaCIsImluamVjdCIsIm1hcCIsImsiLCJjb25jYXQiLCJqb2luIiwiY3NzVGV4dCIsImJyYWNrZXRzIiwiVU5ERUYiLCJSRUdMT0IiLCJSX01MQ09NTVMiLCJSX1NUUklOR1MiLCJTX1FCTE9DS1MiLCJzb3VyY2UiLCJVTlNVUFBPUlRFRCIsIlJlZ0V4cCIsIk5FRURfRVNDQVBFIiwiRklOREJSQUNFUyIsIkRFRkFVTFQiLCJfcGFpcnMiLCJjYWNoZWRCcmFja2V0cyIsIl9yZWdleCIsIl9jYWNoZSIsIl9zZXR0aW5ncyIsIl9sb29wYmFjayIsInJlIiwiX3Jld3JpdGUiLCJicCIsInJlcGxhY2UiLCJfY3JlYXRlIiwicGFpciIsImFyciIsInNwbGl0IiwibGVuZ3RoIiwiRXJyb3IiLCJfYnJhY2tldHMiLCJyZU9ySWR4Iiwic3RyIiwidG1wbCIsIl9icCIsInBhcnRzIiwibWF0Y2giLCJpc2V4cHIiLCJzdGFydCIsInBvcyIsImxhc3RJbmRleCIsImluZGV4Iiwic2tpcEJyYWNlcyIsInNsaWNlIiwidW5lc2NhcGVTdHIiLCJzIiwiY2giLCJpeCIsInJlY2NoIiwiaGFzRXhwciIsImxvb3BLZXlzIiwiZXhwciIsInRyaW0iLCJhcnJheSIsIl9yZXNldCIsIl9zZXRTZXR0aW5ncyIsIm8iLCJiIiwiZGVmaW5lUHJvcGVydHkiLCJzZXR0aW5ncyIsInJpb3QiLCJzZXQiLCJfdG1wbCIsImRhdGEiLCJjYWxsIiwiX2xvZ0VyciIsImNsZWFyQ2FjaGUiLCJlcnJvckhhbmRsZXIiLCJlcnIiLCJyaW90RGF0YSIsIl9fIiwidGFnTmFtZSIsIl9yaW90X2lkIiwiY29uc29sZSIsImVycm9yIiwiX2dldFRtcGwiLCJGdW5jdGlvbiIsIkNIX0lERVhQUiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlJFX0NTTkFNRSIsIlJFX1FCTE9DSyIsIlJFX0RRVU9URSIsIlJFX1FCTUFSSyIsInFzdHIiLCJpIiwiaiIsImxpc3QiLCJfcGFyc2VFeHByIiwiXyIsIlJFX0JSRU5EIiwiYXNUZXh0IiwiZGl2IiwiY250IiwianNiIiwicmlnaHRDb250ZXh0IiwiX3dyYXBFeHByIiwibW0iLCJsdiIsImlyIiwiSlNfVkFSTkFNRSIsIkpTX05PUFJPUFMiLCJ0YiIsInAiLCJtdmFyIiwiSlNfQ09OVEVYVCIsInZlcnNpb24iLCJvYnNlcnZhYmxlJDEiLCJlbCIsImNhbGxiYWNrcyIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnRpZXMiLCJldmVudCIsImNiIiwic3BsaWNlIiwib24iLCJvZmYiLCJhcHBseSIsImFyZ3VtZW50cyIsImFyZ3VtZW50cyQxIiwiYXJnbGVuIiwiYXJncyIsImZucyIsInRyaWdnZXIiLCJlYWNoIiwibGVuIiwiY29udGFpbnMiLCJpdGVtIiwiaW5kZXhPZiIsInRvQ2FtZWwiLCJjIiwidG9VcHBlckNhc2UiLCJzdGFydHNXaXRoIiwib3B0aW9ucyIsImV4dGVuZCIsInNyYyIsIm1pc2MiLCJzZXR0aW5ncyQxIiwiY3JlYXRlIiwiaGFuZGxlRXZlbnQiLCJoYW5kbGVyIiwiZSIsInB0YWciLCJwYXJlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0Iiwic3JjRWxlbWVudCIsIndoaWNoIiwiY2hhckNvZGUiLCJrZXlDb2RlIiwicHJldmVudFVwZGF0ZSIsImdldEltbWVkaWF0ZUN1c3RvbVBhcmVudFRhZyIsImlzTW91bnRlZCIsInVwZGF0ZSIsInNldEV2ZW50SGFuZGxlciIsInRhZyIsImV2ZW50TmFtZSIsImJpbmQiLCJsaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURhdGFJcyIsImNvbmYiLCJpc1ZpcnR1YWwiLCJoZWFkIiwicmVmIiwidW5tb3VudCIsImltcGwiLCJoYXNJbXBsIiwiaW5pdENoaWxkVGFnIiwiYXR0cnMiLCJhIiwibW91bnQiLCJvblVubW91bnQiLCJkZWxOYW1lIiwib3B0cyIsImRhdGFJcyIsInRhZ3MiLCJfdGFncyIsIm5vcm1hbGl6ZUF0dHJOYW1lIiwiYXR0ck5hbWUiLCJ1cGRhdGVFeHByZXNzaW9uIiwiYXR0ciIsImlzVG9nZ2xlIiwiaXNDbGFzc0F0dHIiLCJpc09iaiIsImlzU3R5bGVBdHRyIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzQXR0clJlbW92ZWQiLCJib29sIiwiaXNSdGFnIiwid2FzUGFyc2VkT25jZSIsIm5vZGVWYWx1ZSIsImhpZGRlbiIsInVwZGF0ZUFsbEV4cHJlc3Npb25zIiwiZXhwcmVzc2lvbnMiLCJJZkV4cHIiLCJpbml0Iiwic3R1YiIsInByaXN0aW5lIiwicmVtb3ZlQ2hpbGQiLCJjdXJyZW50IiwiY2xvbmVOb2RlIiwiX3RhZyIsIlJlZkV4cHIiLCJhdHRyVmFsdWUiLCJyYXdWYWx1ZSIsImhhc0V4cCIsIm9sZCIsImN1c3RvbVBhcmVudCIsInRhZ09yRG9tIiwicmVmcyIsIm1raXRlbSIsImJhc2UiLCJ1bm1vdW50UmVkdW5kYW50IiwiaXRlbXMiLCJyZW1vdmUiLCJtb3ZlTmVzdGVkVGFncyIsInRoaXMkMSIsIm1vdmUiLCJuZXh0VGFnIiwiaW5zZXJ0IiwiYXBwZW5kIiwiX2VhY2giLCJtdXN0UmVvcmRlciIsImdldFRhZ05hbWUiLCJwbGFjZWhvbGRlciIsImNoaWxkIiwiZ2V0VGFnIiwiaWZFeHByIiwib2xkSXRlbXMiLCJoYXNLZXlzIiwiaXNMb29wIiwiaXNBbm9ueW1vdXMiLCJ1cGRhdGVFYWNoIiwiZnJhZyIsImlzT2JqZWN0JCQxIiwiZmlsdGVyIiwiZG9SZW9yZGVyIiwib2xkUG9zIiwiaXNOZXciLCJtdXN0QXBwZW5kIiwibXVzdENyZWF0ZSIsIlRhZyQxIiwidCIsInBhcnNlRXhwcmVzc2lvbnMiLCJtdXN0SW5jbHVkZVJvb3QiLCJ0cmVlIiwiY2hpbGRyZW4iLCJ0eXBlIiwibm9kZVR5cGUiLCJ0YWdJbXBsIiwiYXR0cmlidXRlcyIsInBhcmVudEVsZW1lbnQiLCJvdXRlckhUTUwiLCJwYXJzZUF0dHJpYnV0ZXMiLCJyZUhhc1lpZWxkIiwicmVZaWVsZEFsbCIsInJlWWllbGRTcmMiLCJyZVlpZWxkRGVzdCIsInJvb3RFbHMiLCJ0ciIsInRoIiwidGQiLCJjb2wiLCJ0YmxUYWdzIiwiR0VORVJJQyIsInNwZWNpYWxUYWdzIiwic2VsZWN0Iiwic2VsZWN0ZWRJbmRleCIsInRuYW1lIiwiY2hpbGRFbGVtZW50Q291bnQiLCJyZXBsYWNlWWllbGQiLCJ0ZXh0IiwiZGVmIiwibWtkb20iLCJUYWckMiIsIm9uQ3JlYXRlIiwiY2xhc3MiLCJjb25zdHJ1Y3RvciIsInRhZyQxIiwidGFnMiQxIiwibW91bnQkMiIsInB1c2hUYWdzVG8iLCJyaW90VGFnIiwibW91bnRUbyIsImVsZW0iLCJhbGxUYWdzIiwic2VsZWN0VGFncyIsIm5vZGVMaXN0IiwiX2VsIiwibWl4aW5zIiwiZ2xvYmFscyIsIm1peGluc19pZCIsIm1peGluJDEiLCJtaXgiLCJnIiwic3RvcmUiLCJ1cGRhdGUkMSIsInVucmVnaXN0ZXIkMSIsInZlcnNpb24kMSIsImNvcmUiLCJfX3VpZCIsInVwZGF0ZU9wdHMiLCJpbnN0QXR0cnMiLCJza2lwQW5vbnltb3VzIiwic2tpcEFub255bW91c1RhZ3MiLCJjbGVhblVwRGF0YSIsInByb3BzSW5TeW5jV2l0aFBhcmVudCIsInRhZ1VwZGF0ZSIsIm5leHRPcHRzIiwiY2FuVHJpZ2dlciIsInNob3VsZFVwZGF0ZSIsInRhZ01peGluIiwiaW5zdGFuY2UiLCJwcm9wcyIsInByb3BzQmxhY2tsaXN0IiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImdldE93blByb3BlcnR5TmFtZXMiLCJoYXNHZXR0ZXJTZXR0ZXIiLCJnZXQiLCJoYXNPd25Qcm9wZXJ0eSIsInRhZ01vdW50IiwiaXNQcm90b3R5cGVPZiIsInYiLCJpbXBsQXR0cnMiLCJnbG9iYWxNaXhpbiIsIm1peGluIiwib25lIiwidGFnVW5tb3VudCIsIm11c3RLZWVwUm9vdCIsInRhZ0luZGV4IiwiZm9yRWFjaCIsInZpcnRzIiwiaW5oZXJpdEZyb20iLCJtdXN0U3luYyIsIm1vdmVDaGlsZFRhZyIsIm5ld1BvcyIsInVubW91bnRBbGwiLCJza2lwRGF0YUlzIiwibmFtZWRUYWciLCJhcnJheWlzaEFkZCIsImVuc3VyZUFycmF5IiwiZGVzdCIsImlzQXJyIiwiaGFzSW5kZXgiLCJvbGRJbmRleCIsImFycmF5aXNoUmVtb3ZlIiwiaW1wbENsYXNzIiwiX2lubmVySFRNTCIsIm1ha2VSZXBsYWNlVmlydHVhbCIsIm1ha2VWaXJ0dWFsIiwidGFpbCIsInNpYiIsIm1vdmVWaXJ0dWFsIiwidXRpbCIsIlRhZyQkMSIsInRhZyQkMSIsInRhZzIkJDEiLCJtb3VudCQxIiwibWl4aW4kJDEiLCJ1cGRhdGUkJDEiLCJ1bnJlZ2lzdGVyJCQxIiwidmVyc2lvbiQkMSIsIm9ic2VydmFibGUiLCJyaW90JDEiLCJyaW90JDIiLCJzYWZlUmVnZXgiLCJvcHQiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwicGFyc2VycyQxIiwid2luIiwiX3AiLCJfciIsInBhcnNlciIsIl9yZXEiLCJyZW5kZXJQdWciLCJjb21waWxlck5hbWUiLCJ1cmwiLCJyZW5kZXIiLCJsb2ciLCJyZXQiLCJyZXN1bHQiLCJqcyIsInRyYW5zZm9ybSIsImxvb3NlIiwiYWxsb3dUb3BMZXZlbFRoaXMiLCJhc3luYyIsImFzeW5jR2VuZXJhdG9ycyIsImNvZGUiLCJjb21waWxlIiwiYmFyZSIsImhlYWRlciIsImphdmFzY3JpcHQiLCJub25lIiwiY29mZmVlc2NyaXB0IiwiY29mZmVlIiwidXRpbHMiLCJleHRlbmQkMSIsIlNfTElORVNUUiIsIlNfU1RSSU5HUyIsIkhUTUxfQVRUUlMiLCJIVE1MX0NPTU1TIiwiSFRNTF9UQUdTIiwiSFRNTF9QQUNLIiwiUklPVF9BVFRSUyIsIlZPSURfVEFHUyIsIlBSRV9UQUdTIiwiU1BFQ19UWVBFUyIsIklNUE9SVF9TVEFURU1FTlQiLCJUUklNX1RSQUlMIiwiUkVfSEFTRVhQUiIsIlJFX1JFUEVYUFIiLCJDSF9EUUNPREUiLCJEUSIsIlNRIiwiY2xlYW5Tb3VyY2UiLCJsZWZ0Q29udGV4dCIsInBhcnNlQXR0cmlicyIsInBjZXgiLCJ2ZXhwIiwic3BsaXRIdG1sIiwianNmbiIsIl9jb21waWxlSlMiLCJyZXN0b3JlRXhwciIsImQiLCJfY29tcGlsZUhUTUwiLCJlbmRzIiwid2hpdGVzcGFjZSIsInEiLCJzaGlmdCIsImNvbXBhY3QiLCJjb21waWxlSFRNTCIsIkpTX0VTNlNJR04iLCJKU19FUzZFTkQiLCJKU19DT01NUyIsInJpb3RqcyIsInRvZXM1IiwibWV0aG9kIiwicHJlZml4IiwiUkUiLCJybUNvbW1zIiwic2tpcEJvZHkiLCJyIiwicGFyc2VyT3B0cyIsImNvbXBpbGVKUyIsInVzZXJPcHRzIiwicGFyc2VyT3B0aW9ucyIsIkNTU19TRUxFQ1RPUiIsInNjb3BlZENTUyIsInNjb3BlIiwicDEiLCJwMiIsInNlbCIsIl9jb21waWxlQ1NTIiwiY29tcGlsZUNTUyIsIlRZUEVfQVRUUiIsIk1JU0NfQVRUUiIsIkVORF9UQUdTIiwiX3EiLCJta3RhZyIsImltcG9ydHMiLCJkZWJ1ZyIsInNwbGl0QmxvY2tzIiwibGFzdEluZGV4T2YiLCJuIiwiZ2V0VHlwZSIsImF0dHJpYnMiLCJnZXRBdHRyaWIiLCJ1bmVzY2FwZUhUTUwiLCJnZXRQYXJzZXJPcHRpb25zIiwicGFyc2UiLCJnZXRDb2RlIiwianNQYXJzZXJPcHRpb25zIiwiY3NzQ29kZSIsInBhcnNlclN0eWxlT3B0aW9ucyIsImV4dHJhT3B0cyIsImNvbXBpbGVUZW1wbGF0ZSIsImxhbmciLCJDVVNUX1RBRyIsIlNDUklQVFMiLCJTVFlMRVMiLCJjb21waWxlJDEiLCJpbmNsdWRlZCIsImRlZmF1bHRQYXJzZXJwdGlvbnMiLCJleGNsdWRlIiwidGVtcGxhdGUiLCJpbmRlbnQiLCJib2R5IiwiYm9keTIiLCJqc2NvZGUiLCJzdHlsZXMiLCJfbSIsIl9hdHRycyIsIl9zY3JpcHQiLCJfc3R5bGUiLCJibG9ja3MiLCJlbnRpdGllcyIsInZlcnNpb24kMiIsImNvbXBpbGVyIiwicHJvbWlzZSIsInJlYWR5IiwiR0VUIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0Iiwib3BlbiIsInNlbmQiLCJnbG9iYWxFdmFsIiwiY29tcGlsZVNjcmlwdHMiLCJ4b3B0Iiwic2NyaXB0cyIsInNjcmlwdHNBbW91bnQiLCJkb25lIiwiY29tcGlsZVRhZyIsInNjcmlwdCIsInBhcnNlcnMiLCJhcmciLCJtb3VudCQkMSIsInJpb3RfY29tcGlsZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUNDLFdBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0VBQ29DQyxjQUFBLEdBQWlCRCxTQUFoRixBQUFBO0NBREEsRUFJQ0UsY0FKRCxFQUlRLFlBQVk7OztNQUVqQkMsZUFBZSxFQUFuQjtNQUNJQyxhQUFhLEVBQWpCO01BQ0lDLGVBQWUsZ0JBQW5CO01BQ0lDLGVBQWUsT0FBbkI7TUFDSUMsaUJBQWlCLENBQUMsS0FBRCxFQUFRLFVBQVIsQ0FBckI7TUFDSUMsZUFBZSxTQUFuQjtNQUNJQyx3QkFBd0IsSUFBNUI7TUFDSUMsaUJBQWlCLE1BQXJCO01BQ0lDLDRCQUE0QixZQUFoQztNQUNJQyxpQkFBaUIsTUFBckI7TUFDSUMsaUJBQWlCLE1BQXJCO01BQ0lDLGtCQUFrQixpQkFBdEI7TUFDSUMsV0FBVyxRQUFmO01BQ0lDLFdBQVcsUUFBZjtNQUNJQyxVQUFXLFdBQWY7TUFDSUMsYUFBYSxVQUFqQjtNQUNJQyxXQUFXLDhCQUFmO01BQ0lD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
